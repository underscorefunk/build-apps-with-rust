<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Building Apps with Rust</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Preface</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Acknowledgements</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> About this Book</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> About the Author</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> If you get stuck</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Introductions</li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Programming</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> What it is</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Why it's worth it</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Why it's hard</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> Programmer Thinking</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Languages</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> Meaning and Interpretation</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Architectures</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> How your computer works</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> How the web works</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.3.</strong> The frontend-backend divide</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Tools and Languages</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">9.1.</strong> Bash and the terminal</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.2.</strong> Rust</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.3.</strong> Trunk</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.4.</strong> Web browsers</div></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Hello World</li><li class="chapter-item expanded "><a href="setup_intro.html"><strong aria-hidden="true">10.</strong> Setup</a></li><li class="chapter-item expanded "><a href="html_intro.html"><strong aria-hidden="true">11.</strong> Intro to HTML</a></li><li class="chapter-item expanded "><a href="view_macro_html.html"><strong aria-hidden="true">12.</strong> HTML and the view! macro</a></li><li class="chapter-item expanded "><a href="leptos_component_intro.html"><strong aria-hidden="true">13.</strong> Intro to Leptos Components</a></li><li class="chapter-item expanded "><a href="view_macro_variables.html"><strong aria-hidden="true">14.</strong> Variables and the view! macro</a></li><li class="chapter-item expanded "><a href="leptos_component_properties.html"><strong aria-hidden="true">15.</strong> Leptos Component properties</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Building an Application</li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Design Patterns and Application Structure</li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Common Problems</li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Building Apps with Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <ol>
<li>Install Rust</li>
<li>Using up-to-date versions of rustc with <code>Nightly</code></li>
<li>Using up-to-date versions of Leptos from git</li>
</ol>
<hr />
<h3 id="1-install-rust"><a class="header" href="#1-install-rust">1. Install Rust</a></h3>
<p>Detail instructions on how to install Rust for your computer can be found here: https://www.rust-lang.org/tools/install</p>
<p>Installing rust will add a few things to your system.</p>
<ol>
<li>rustc - the rust compiler</li>
<li>rustup - a tool for managing rustc and the rust toolchain (https://rustup.rs)</li>
<li>cargo - the package manager and helper tool for rust (https://doc.rust-lang.org/stable/cargo/)</li>
</ol>
<h3 id="2-using-up-to-date-versions-of-rustc-with-nightly"><a class="header" href="#2-using-up-to-date-versions-of-rustc-with-nightly">2. Using up-to-date versions of rustc with <code>Nightly</code></a></h3>
<p>rustc is the rust compiler. It's possible to run different versions of the compiler. The Rust<br />
community is always working away adding new features. These new features are available<br />
immediately through nightly builds. Leptos, being brand new, makes use of some of these new<br />
features and currently requires <code>nightly</code> to run.</p>
<p>To confirm that you're using the <code>nightly</code> build of rustc (the rust compiler), open your<br />
shell/terminal and run the following command:</p>
<pre><code class="language-bash">rustc -V  
</code></pre>
<p>It should output something like this with 'nightly' in it:</p>
<pre><code class="language-bash">rustc 1.67.0-nightly (e631891f7 2022-11-13)  
</code></pre>
<p>If your version isn't the nightly build, run the following shell/terminal command:</p>
<pre><code class="language-bash">rustup default nightly  
</code></pre>
<p>Rustup is used to manage rustc. By calling the above, rustc is updated to us the nightly build<br />
as its default. You can change this to stable by using the following shell/terminal command:</p>
<pre><code class="language-bash">rustup default stable  
</code></pre>
<h3 id="3-using-up-to-date-versions-of-leptos-from-git"><a class="header" href="#3-using-up-to-date-versions-of-leptos-from-git">3. Using up-to-date versions of Leptos from git</a></h3>
<p>Leptos is changing all the time as well. It's recommended to grab the latest version directly<br />
from their git repository instead of from crates.io (https://crates.io/crates/leptos).</p>
<p>I'll go into detail on exactly how to do this when we start building our app. Don't stress if<br />
the following looks unfamiliar.</p>
<pre><code class="language-toml">[dependencies]  
leptos = { git = &quot;https://github.com/gbj/leptos&quot; }  
</code></pre>
<hr />
<h2 id="creating-your-first-app"><a class="header" href="#creating-your-first-app">Creating your first app</a></h2>
<ol>
<li>Using cargo to create a new rust app</li>
<li>Running your first rust app</li>
<li>Adding Leptos to your application as a dependency</li>
<li>Adding index.html to your application</li>
<li>Serving your index.html and bundling WASM with trunk</li>
<li>Updating client side HTML using Leptos</li>
</ol>
<hr />
<h3 id="1-using-cargo-to-create-a-new-rust-app-cargo-new"><a class="header" href="#1-using-cargo-to-create-a-new-rust-app-cargo-new">1. Using cargo to create a new rust app (<code>cargo new</code>)</a></h3>
<p>New rust projects are created with the following terminal command:</p>
<p>I'm calling my project <code>tut-leptos-client-side-event</code>, keeping in mind thst we're testing out how to handle a simple client side event.</p>
<pre><code class="language-bash">cargo new tut-leptos-client-side-event  
</code></pre>
<blockquote>
<p><strong>Did you know?</strong><br />
Cargo new will create the new project in your current working directory. You  can add path specifications to the application name to change where it's scafolded to. For example, <code>cargo new ~/dev/my-new-app</code> will create a new rust app in the <code>dev</code> directory inside your <code>~/</code> use home directory. If you see <code>~/</code> know that it's a shorthand for your user<br />
home. On OSX that would be <code>/Users/your-user-name</code>.</p>
</blockquote>
<p>When <code>cargo</code> runs with the <code>new</code> command, it creates the folder <code>tut-leptos-client-side-event</code>.</p>
<p>This folder gets setup with a few important things.</p>
<ol>
<li>A <code>src</code> directory that will contain all of our source code</li>
<li>A <code>src\main.rs</code> file, which contains our main function which is our <code>app</code>. This is called to<br />
tart our application and everything is run by calling code inside of it.</li>
<li>A <code>cargo.toml</code> file which contains meta data about our app, and it's dependences.</li>
<li>A <code>target</code> directory that will contain compiled data of our app. Ignore this folder for now.</li>
</ol>
<h3 id="2-running-your-first-rust-app-cargo-run"><a class="header" href="#2-running-your-first-rust-app-cargo-run">2. Running your first rust app (<code>cargo run</code>)</a></h3>
<p>Recall that we just made a new app with <code>cargo new tut-leptos-client-side-event</code>. Now we want to run it! Using the termninal/shell command <code>cargo run</code> will compile and run our app. Entering this terminal/shell command will not work right away. You'll get an error message:</p>
<blockquote>
<p>error: could not find <code>Cargo.toml</code> in ` ....... or any parent directory</p>
</blockquote>
<p>Cargo needs that cargo.toml file for context. It has information about which version of rust to compile for, which external bits of code (dependencies) need to be gathered to do the  compilation, and so forth.</p>
<p><code>C</code>hanging the <code>d</code>irectory of your <code>p</code>resent <code>w</code>orking <code>d</code>irectory to the directory created by <code>cargo new</code> will allow us to use the cargo.toml file for context, letting us compile the app.</p>
<blockquote>
<p><code>cd</code> â€“ is the terminal/shell command for changing directory</p>
</blockquote>
<blockquote>
<p><code>pwd</code> â€“ is the terminal/shell command for printing the present working directory</p>
</blockquote>
<p>The following list of commands need to be input individual, one line at a time. The first command changes the present working directory to our user home directory:</p>
<pre><code class="language-bash">cd ~/  
cargo new tut-leptos-client-side-event  
cd tut-leptos-client-side-event  
cargo run  
</code></pre>
<p>The application will take a brief period to compile and it'll print <code>Hello, world!</code> to your terminal/shell.</p>
<h3 id="3-adding-leptos-to-your-application-as-a-dependency"><a class="header" href="#3-adding-leptos-to-your-application-as-a-dependency">3. Adding Leptos to your application as a dependency</a></h3>
<p>We're going to add leptos to the mix as a dependency for our rust application.</p>
<p>First let's take a look at our stock <code>cargo.toml</code></p>
<pre><code class="language-toml">[package]  
name = &quot;tut-leptos-client-side-event&quot;  
version = &quot;0.1.0&quot;  
edition = &quot;2021&quot;  
  
# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html  
  
[dependencies]  
</code></pre>
<p>Note that we have no dependencies listed. All that exists is the heading <code>[dependencies]</code>.</p>
<p>Normally we'd use <code>cargo</code> to help us add dependencies. We'd need to call <code>cargo</code> in the<br />
context of our rust application's <code>cargo.toml</code> like we did with <code>cargo run</code>.</p>
<p>From within the <code>tut-leptos-client-side-event</code> folder we can call the following terminal/shell<br />
command:</p>
<pre><code class="language-bash">cargo add leptos  
</code></pre>
<p>Our <code>Cargo.toml</code> now includes the following:</p>
<pre><code class="language-cargo.toml">[dependencies]  
leptos = &quot;0.0.18&quot;  
</code></pre>
<p>In getting started we talked about using the git repository to grab the most up to date version of the dependency instead of the version published on crates.io (the rust package repository).</p>
<p>To do this we'll actually change the leptos entry to:</p>
<pre><code class="language-cargo.toml">leptos = { git = &quot;https://github.com/gbj/leptos&quot; }  
</code></pre>
<h3 id="4-adding-indexhtml"><a class="header" href="#4-adding-indexhtml">4. Adding index.html</a></h3>
<p>Our rust application will compile to wasm. That wasm will interact with a web page to create our client side experience. For this to work, we'll need to create an index.html.</p>
<p>Create this file in the root of your app, alongside cargo.toml. Your app directory should look like this:</p>
<pre><code>/tut-leptos-client-side-event  
	/src
		main.rs
	cargo.toml
	index.html
</code></pre>
<p>Inside the index.html should contain the following:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;  
&lt;html&gt;  
&lt;head&gt;  
    &lt;title&gt;Leptos App&lt;/title&gt;
	&lt;link data-trunk rel=&quot;rust&quot; data-wasm-opt=&quot;z&quot;/&gt;
&lt;/head&gt;  
&lt;body&gt;&lt;/body&gt;  
&lt;/html&gt;    
</code></pre>
<p>The important part of this is the following tag:</p>
<pre><code class="language-html">&lt;link data-trunk rel=&quot;rust&quot; data-wasm-opt=&quot;z&quot;/&gt;
</code></pre>
<p>A tool called <code>trunk</code> is going to eventually put all of these pieces together. The above <code>&lt;link&gt;</code> element will be replaced with rust application, compiled to wasm.</p>
<h3 id="4-serving-your-indexhtml-and-bundling-wasm-with-trunk"><a class="header" href="#4-serving-your-indexhtml-and-bundling-wasm-with-trunk">4. Serving your index.html and bundling WASM with trunk</a></h3>
<p>To use our application on the web, we need to serve it and bundle the WASM with the HTML.</p>
<p>We're going to use a tool called <code>trunk</code> which will do a few things:</p>
<ol>
<li>It'll serve index.html so that we can view it in our browser</li>
<li>It'll use <code>cargo</code> to compile the application to WASM</li>
<li>It'll attach the compiled WASM to our index.html, replacing <code>&lt;link data-trunk rel=&quot;rust&quot; data-wasm-opt=&quot;z&quot;/&gt;</code></li>
</ol>
<p>You will need to install the <code>trunk</code> tool. Instructions can be found here: https://trunkrs.dev/#install</p>
<p>For covenience, this will probably work:</p>
<pre><code class="language-shell">cargo install --locked trunk
</code></pre>
<p>To serve your app, use the following terminal/shell command while your application root is your present working directory:</p>
<pre><code class="language-shell">trunk serve
</code></pre>
<p>You'll see a variety of diagnostic information output to your prompt. The important line is this&quot;</p>
<pre><code class="language-shell">2022-11-26T15:40:19.251657Z  INFO ðŸ“¡ serving static assets at -&gt; /
2022-11-26T15:40:19.251861Z  INFO ðŸ“¡ server listening at http://127.0.0.1:8080
</code></pre>
<p>Listening at <code>127.0.0.1:8080</code> means that you can type that into your web browser to send a <strong>request</strong> to the server and it will provide the static files with your WASM bundled in (because it is a static file) back as the <strong>response</strong>.</p>
<p>You now have a web page!</p>
<h3 id="5-updating-client-side-html-using-leptos"><a class="header" href="#5-updating-client-side-html-using-leptos">5. Updating client side HTML using Leptos</a></h3>
<h4 id="51-understanding-mainrs"><a class="header" href="#51-understanding-mainrs">5.1 Understanding main.rs</a></h4>
<p>At this point we have a Rust application which compiles to WASM and we have a server running, listening at <code>127.0.0.1:8080</code> for requests, responding with our index.html and linked assets, most importantly our Rust application in WASM form.</p>
<p>What we don't have here is anything that updates our index.html or any form of interaction between our Rust application (WASM) and the DOM (Document Object Model â€” a name for the hierarchy of html elements/nodes) in the index.html.</p>
<p>We've addd leptos to our application as a dependency, and now we're going to put it to use.</p>
<p>If we look in our <code>src/main.rs</code> we can see the following:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {  
    println!(&quot;Hello, world!&quot;);  
}</code></pre></pre>
<p>Here we have a function (using the keyword <code>fn</code>) with the name <code>main</code>.  The <code>(</code> and <code>)</code> are like bookends that encapsulate a functions <strong>parameters</strong> (buckets to hold arguments passed to them) and <strong>arguments</strong> (values assigned to the parameters when called) that the function might use to run. In this case, the main function doesn't require anything to run, so it has nothing between its parenthesis after the function name. The following set of curley braces <code>{</code> and <code>}</code> encapsulate the function body here. This is what will be evaluated when the function is run; the work being done. This is the most minimal example of a <strong>function signature</strong>. There are more things that can be added but we'll get into those later.</p>
<p>The body of the function contains a single expression. Expressions need to end with <code>;</code>. You can think of it as a terminator for the end of an instruction or step that you want the application to perform.</p>
<p>Let's look at the content of this line.</p>
<p>We have <code>println!(&quot;Hello, world!&quot;);</code></p>
<p>We can look at this as <code>some-command</code>(<code>some-arguments</code>)<code>end</code></p>
<p>The command is <code>println!</code>, the argument is a sequence of characters wrapped by quotes as a convenient way to tell the compiler that you mean the characters and not other commands or variables, and an end of expression character <code>;</code> semicolon.</p>
<p>The command <code>println!</code> is provided by Rust's standard library for you to use to output text to the terminal. If you run your application you'll see <code>Hello, world!</code>, and this is why.</p>
<blockquote>
<p>Important: We've glossed over how to write your own functions with parameters. We've also skipped over how to write functions that return values. Don't worry, we'll cover that when appropriate.</p>
</blockquote>
<h5 id="macros"><a class="header" href="#macros">Macros</a></h5>
<p>We saw before that the main function is written as <code>fn main(){}</code>. There is no <code>!</code> after <code>main</code>. But there is a <code>!</code> after <code>println!</code>.</p>
<p>The <code>!</code> indicates that command is a macro. Macros are like code snippits or code templates that get expanded by the Rust compiler before it's final compilation.</p>
<p>There are function like macros, which use <code>()</code> to encapsulate their argumens. There are also procedural macros, which use <code>{}</code> to encapsulate a body of code which gets consumed by the macro.</p>
<p>As you can imagine, there is a lot involved in actually printing something to the terminal, but we can ignore the complexity with things like <code>println!</code>.</p>
<p>Macros have parameters which you can pass arguments to, just like functions. Leptos makes extensive use of macros to make our lives easier. They're wonderful!</p>
<blockquote>
<p>Important: Macros have the ability to parse (read through to understand/process) their arguments differently from standard Rust code. Keep in mind that the macro author is usually trying to do things that make life easier for the developer using their macro. Sometimes this includes reduction of noisey syntax that would normally be required, or inferences that can be assumed.</p>
</blockquote>
<h4 id="52-updating-mainrs-to-use-leptos"><a class="header" href="#52-updating-mainrs-to-use-leptos">5.2 Updating main.rs to use Leptos</a></h4>
<p>Now that we understand how Rust functions work we can start to bring Leptos into our main.rs.</p>
<p>We do this by telling the compiler that we want to <code>use</code> leptos.
We've added <code>leptos</code> as a dependency in our cargo.toml, so it now exisgts is our 'application universe' as a thing.</p>
<p>But, it doesn't exist in our <code>main.rs</code> because we haven't brought it into scope yet. Bringing things into scope is like bringing things to a workbench or crafting table to use. You need those things at hand, where you're working, so that when you refer to them the compiler knows what you mean and has the bits of code to actually use.</p>
<p>When we write <code>use leptos::*;</code> at the top of our main.rs file, we're telling Rust, <code>use</code> and think called <code>leptos</code> which you should be aware of because we defined it in our cargo.toml, and bring ALL of it's pieces into scope for us to use. The <code>::</code> is a separator the same a slash is a separator for hierarchy in your computer's file system. The <code>*</code> refers to 'everything'.</p>
<p><code>use leptos::*;</code></p>
<p>reads as</p>
<p>use everything from leptos.</p>
<p>To visualize this, think of it as taking a box of tools called &quot;Leptos&quot; and dumping all of them out onn your work bench. You can now grab any one of them for use.</p>
<h4 id="53-updating-fn-main-to-interact-with-your-html"><a class="header" href="#53-updating-fn-main-to-interact-with-your-html">5.3 Updating fn main() to interact with your html</a></h4>
<p>In our main.rs we have a <code>fn main(){}</code>. Currently it prints &quot;Hello, world!&quot; to our standard out (terminal/console).</p>
<p>What we want to do is to change the HTML in index.html when the WASM loads, which is also when the <code>fn main()</code> runs.</p>
<p>We'll use a function called <code>mount_to_body</code>, which is provided as a tool in <code>leptos</code>, made available in this scope (this main.rs file) with the use statement.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

fn main() {
	mount_to_body()
}</code></pre></pre>
<p><code>mount_to_body</code> requires some arguments to run correctly.</p>
<p>Specifically, it requires a closure. It requires a value that is actually 'runable' or 'callable'.</p>
<h5 id="closures"><a class="header" href="#closures">Closures</a></h5>
<p>A closure is functionality as a <strong>first class citizen</strong>. This means that it's a function that can be stored as a value and passed around to be called later.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_hi(){
	println!(&quot;Hi&quot;);
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>A standard function definition.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">fn main(){
	// let tells the compiler to assign
 	// the value of greeter to whatever is 
 	// after the = and before the semicolon.
	let greeter = || {
		println!(&quot;Hi&quot;);
	};
}</code></pre></pre>
<blockquote>
<p>Single line comments in Rust are prefixed by <code>//</code> at the beginning of the commend. These tell the compiler to ignore anything after it.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>|| {
	println!(&quot;Hi&quot;);
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>A closure</p>
</blockquote>
<p>The above closure syntax is like a function, but it doesn't have a name because we're expecting to assign the functionality to a name. Like we did with greeter above.</p>
<p>The parenthesis that normally encapsulate a functions arguments are converted to pipe characters to diambiguate the two. The body of the closure, just like the body of a function, is encapsulated by curly braces.</p>
<p>The following shows how a function and a closure can be called:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print_hi(); // This was a function
greeter();  // This was a value `greeter`
<span class="boring">}</span></code></pre></pre>
<p>The coolest thing here is that we can see both <code>print_hi</code> and <code>greeter</code> are names that exist in or applications context. They're ideas. Both of them are callable. And we can call them by adding parenthesis at the end.</p>
<p>This starts to hint at some of the underlying simplicity of a lot of programming. At the end of the day, we're giving names to things so that we can specify to the computer, what is what. Then we evaluate or run a bit of functionality, and give the result a name so that we can do something else after. It's this over and over again, all the way down.</p>
<h5 id="using-mount_to_body"><a class="header" href="#using-mount_to_body">Using mount_to_body</a></h5>
<p>Recall that our application's main.rs looked like this</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

fn main() {
	mount_to_body()
}</code></pre></pre>
<p>We have <code>mount_to_body</code> function being called when the application runs as WASM, when index.html is server with the WASM resource.</p>
<p>This function needs functionality to call. It needs a closure. We have the opportunity to tell it what to do with the assumption that when mount_to_body runs, it'll provide us the context in which it's running. This of this as a scope. We can make this assumption because mount_to_body specifies that it needs a closure that makes use of an argument, which we know to be context, abbreviated here as <code>cx</code>.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

fn main() {
	mount_to_body(|cx|{})
}</code></pre></pre>
<p>The above shows what an empty closure being passed to mount_to_body looks like. What this doesn't show is that the closure needs to return something that can be mounted.</p>
<p>If you ran the above you're probably receive an error like:</p>
<pre><code class="language-bash">T: Mountable, required by this bound in `leptos::mount_to_body`
</code></pre>
<p>The error messages will get easier to read over time, but it essentially says, &quot;The return type of the closure can't be used by the internals of mount_to_body. It was expecting something specific to come out of your instructions.&quot;</p>
<p>To solve this problem we're going to use the <code>view!</code> macro provided by leptos.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

fn main() {
	mount_to_body(|cx|{
		view! {  
	        cx,  
	        &lt;h1&gt;&quot;Hello, world!&quot;&lt;/h1&gt;  
	    }
	})
}</code></pre></pre>
<p>We've written the following in the body of the closure, being provided to <code>mount_to_body</code> as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>view! {  
	cx,  
	&lt;h1&gt;
		&quot;Hello, world!&quot;
	&lt;/h1&gt;  
}
<span class="boring">}</span></code></pre></pre>
<p>This procedural macros <code>view!</code> has a body which starts with cx, the context that will be provided to it by mount_to_body when it's run (again, this is inside mount_to_body and evaluated at a later time) and the view or html to mount.</p>
<p>There must be one top level item and all text needs to be quoted. It's a JSX like syntax and beautifully streamlined to write.</p>
<p>If you had <code>trunk serve</code> running this whole time, you can visit http://127.0.0.1:8080 to see your &quot;Hello, world!&quot;</p>
<p>Or, make sure your present working directory is the root of your application, type <code>trunk serve</code> and visit http://127.0.0.1:8080 to see your first working leptos WASM client side awesomeness!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intro-to-html"><a class="header" href="#intro-to-html">Intro to HTML</a></h1>
<h1 id="what-we-know"><a class="header" href="#what-we-know">What we know</a></h1>
<p>In <a href="/setup_intro">Setup</a> we developed a cursory understanding of:</p>
<ul>
<li>how to create a generic Rust application</li>
<li>how to add <code>Leptos</code> as a dependency to our Rust application</li>
<li>how to serve a file with <code>trunk</code></li>
<li>how to update an HTML file with Rust, using <code>Leptos</code>'s <code>mount_to_body</code> function and it's <code>view!</code> macro</li>
</ul>
<h1 id="what-well-learn"><a class="header" href="#what-well-learn">What we'll learn</a></h1>
<ul>
<li>Working with HTML and developing a mental model</li>
</ul>
<h1 id="where-were-at"><a class="header" href="#where-were-at">Where we're at</a></h1>
<p>Code from our <code>main.rs</code> looks like this:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;h1&gt;&quot;Hello, world!&quot;&lt;/h1&gt;  
        }  
    })  
}</code></pre></pre>
<blockquote>
<p>The <code>main</code> function <code>fn</code> is run when our application runs as WASM.</p>
<p>Recall that the <code>trunk</code> tool uses <code>cargo</code> also a tool with <code>rustc</code> to compile it to the WASM target, which gets served and linked to our index.html. We view (request) the page in our browser, loading the html and linked WASM, kicking the whole thing off.</p>
<p>When the application runs the function <code>mount_to_body</code> is called (runs), which we pass (or provide) a closure (a big of functionality stored as a value) as an argument to it's callback parameter (the bucket that holds things that <code>mount_to_body</code> needs to run, <em>&quot;function dependencies&quot;</em>).</p>
<p>When <code>mount_to_body</code> runs, it takes the  functionality we've provided as a closure (a <em>strategy</em> if you will) and calls it (makes it run) with its runtime context <code>cx</code>. This does all of the heaving lifting to write our heading the body of our HTML page in index.html</p>
</blockquote>
<h1 id="lesson-working-with-html-and-developing-a-mental-model"><a class="header" href="#lesson-working-with-html-and-developing-a-mental-model">Lesson: Working with HTML and developing a mental model</a></h1>
<p>We're not doing much more than creating a static template. If this is all you need, better to stick with a plain old HTML file.</p>
<h2 id="html-elements-and-tags"><a class="header" href="#html-elements-and-tags">HTML Elements and Tags</a></h2>
<p>HTML is made up of Elements. There are a whole list of HTML elements ready for use and supported by all current browsers, from heading and paragraphs to form elements for collecting data from users like. These Elements are written using HTML tags, <code>&lt;h1&gt;</code>, <code>&lt;p&gt;</code>, and <code>&lt;input&gt;</code> respectively.</p>
<h3 id="tags-with-content"><a class="header" href="#tags-with-content">Tags with content</a></h3>
<p>Some tags have content. The syntax is to encapsulate the content or wrap it with opening and closing tags. The closing tag has a slash before the tag name.</p>
<pre><code class="language-html">	&lt;h1&gt;Some Content&lt;/h1&gt;
</code></pre>
<blockquote>
<p>This Heading 1 tag has content, which requies a closing tag so that it's content can be wrapped/encapsulated.</p>
</blockquote>
<p>What's neat about this opening and closing tag business is that it's not <em>that</em> different from when we called a function and provided an argument (value) for it's parameter. As time goes on you'll start to see a pattern emerging. The above isn't going to look at different from:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	h1(&quot;Some Content&quot;)
<span class="boring">}</span></code></pre></pre>
<h3 id="tags-without-content"><a class="header" href="#tags-without-content">Tags without content</a></h3>
<p>Some tags don't have content. To express a tag without content we add a backslash at the end of the tag of the tag. This tells browsers that there is no closing tag.</p>
<pre><code class="language-html">&lt;hr /&gt;
</code></pre>
<blockquote>
<p>This Horizontal Rule tag doesn't have a closing tag</p>
</blockquote>
<h3 id="tag-configuration-with-properties-and-attributes"><a class="header" href="#tag-configuration-with-properties-and-attributes">Tag configuration with properties and attributes</a></h3>
<p>HTML Elements can be configured by setting values for supported properties and attributes. If you've played around with HTML before you'll probably have seen commong properties like <code>id</code> and <code>class</code>:</p>
<pre><code class="language-html">&lt;h1 id=&quot;my-unique-heading&quot;&gt;Hello, world!&lt;/h1&gt;
</code></pre>
<blockquote>
<p>Some poperties have specific requirements for their values. <code>id</code> for example, should have a unique value across all Elements on the page.</p>
</blockquote>
<pre><code class="language-html">&lt;input name=&quot;first-name&quot; placeholder=&quot;Enter your name...&quot; type=&quot;text&quot; /&gt;
</code></pre>
<blockquote>
<p>The input tag has a <code>type</code> which completely changes how its rendered (displayed to the user).</p>
</blockquote>
<h3 id="the-browser-as-interpreter"><a class="header" href="#the-browser-as-interpreter">The browser as interpreter</a></h3>
<p>When you send a request to the server, it returns a response which has a body (the data, often as text) and headers (meta information about the body). Information in the headers tells the browser how to interpret the body.</p>
<blockquote>
<p>Analogy time: Imagine if you went to a library and asked a librarian for a book. This is like you, the web browser, submitted a request to a server. The librarian (the server) will then provide a response to your request. They may return with the book and a slip of paper saying, &quot;I found the book and this book is in english.&quot; We can now use our knowlege of the english language to parse the book (turn it into meaningful data) and understand it.</p>
</blockquote>
<p>Traditionally servers respond to web requests telling the browser that the body's response  is text/html. A browser very deeply wants to render your page for you, so it dutifully reads through what it's been told is html, parses it into meaningful data (the DOM, Document Object Model), and renders it to the screen.</p>
<p>Things like:</p>
<pre><code class="language-html">&lt;input name=&quot;first-name&quot; placeholder=&quot;Enter your name...&quot; type=&quot;text&quot; /&gt;
</code></pre>
<p>Turn more into an object (a thing) with the following properties:</p>
<pre><code>HTML Element Type = &quot;input&quot;
name = &quot;first-name&quot;
placeholder = &quot;Enter your name...&quot;
type = &quot;text&quot;
</code></pre>
<blockquote>
<p>This isn't real code, but it does look a lot like what we'll call a <strong>struct</strong> in Rust later. Once again we can see similar shared underlying principles. This idea of &quot;a thing with stuff&quot; comes up time and time agin.</p>
</blockquote>
<p>There may be bits of information that the browser doesn't understand. Instead of crashing it often ignores this unknown information, or makes assumptions about it to still continue to render the page.</p>
<p>Browsers and HTML rendering engines are extremely complex and down right magical. We can throw so much at them and they keep on going.</p>
<h3 id="what-the-element"><a class="header" href="#what-the-element">What the element?</a></h3>
<p>Recall that before we talked about HTML elements, properties, and attributes. It might feel like HTML is an expressive programming language, but it is actually what we would call a DSL (Domain Specific Language). They're instructions that pertain specific to rendering web pages that tell the browser our intent. We <strong>declare</strong> what we want and it's the browser's <strong>imperative</strong> to decide how to render it.</p>
<p>In standard HTML you can not just make up properties or Elements/tags. It might look like we're choosing to write <code>h1</code> because it's convenient for us to think about a primary heading as a <code>h1</code>, but this is actually part of the specification of HTML.</p>
<p>Developers can now create their own custom elements with Javascript, but we're going to ignore that for now. Just know that it does exist but more work is required than just writing you own tag names.</p>
<h3 id="what-does-this-mean-for-the-view-macro-and-which-html-elements-we-can-use-in-it"><a class="header" href="#what-does-this-mean-for-the-view-macro-and-which-html-elements-we-can-use-in-it">What does this mean for the <code>view!</code> macro and which HTML elements we can use in it?</a></h3>
<p>The content that we place in our <code>view!</code> macro is interpreted by the <code>view!</code> macro when the rust compiler expands it. It takes what we've provided and says, &quot;Ok, so this is what you want... but the rest of the application can't work with this. What you've written isn't actually HTML and it's not actually Rust. I'll parse this input and rewrite it so that the rest of our application can use it, saving you from the verbosity and potentially error prone nature of writing it yourself.&quot;</p>
<p>In the next lesson we'll learn about making components which we can compose and how Leptos allows us to have custom components/elements while still generating HTML that the browser can parse and understand according to the HTML spec.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="html-and-the-view-macro"><a class="header" href="#html-and-the-view-macro">HTML and the <code>view!</code> macro</a></h1>
<h2 id="what-we-know-1"><a class="header" href="#what-we-know-1">What we know</a></h2>
<ul>
<li>HTML is a specification for a domain specific language that is parsed by a web browser to render a web page</li>
<li>The web browser will do its best to render a page, ignoring or gracefully interpreting code in a page that doesn't match the HTML specification.</li>
<li>The <code>view!</code> macro accepts its arguments between curly braces <code>{}</code>, accepting a context <code>cx</code> and HTML like mark-up.</li>
</ul>
<h1 id="what-well-learn-1"><a class="header" href="#what-well-learn-1">What we'll learn</a></h1>
<ul>
<li>Creating custom components</li>
</ul>
<h1 id="where-were-at-1"><a class="header" href="#where-were-at-1">Where we're at</a></h1>
<p>Code from our <code>main.rs</code> looks like this:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;h1&gt;&quot;Hello, world!&quot;&lt;/h1&gt;  
        }  
    })  
}</code></pre></pre>
<blockquote>
<p>We can see that after the context variable we have some HTML like text. If this were HTML, you'd have a heading that reads <strong>&quot;Hello, world!&quot;</strong> with the quotes displaying. However, this isn't pure HTML and the macro will process the template to remove the quotes.</p>
</blockquote>
<h2 id="view-macro-syntax"><a class="header" href="#view-macro-syntax"><code>View!</code> macro syntax</a></h2>
<p>The <a href="https://docs.rs/leptos/latest/leptos/macro.view.html">view! macro documentation</a> is very nicely detailed with details about it's basic and advanced syntax. It's a JSX like syntax. We'll slowly touch on all of the features as we continue to learn Rust and <code>Leptos</code>.</p>
<p>For now, the important thing to remember is that strings need to be quoted.</p>
<p>@todo, highlight that a view contains element markup and text nodes. That's it</p>
<h2 id="adding-more-to-a-view"><a class="header" href="#adding-more-to-a-view">Adding more to a view</a></h2>
<p>You can continue to add other html elements as if you were writing plain HTML. Line breaks and indentation will not break the syntax. HTML code often has a lot of line breaks or white space from code formatting. Web browsers will ignore this unless you specify that you want the white space retained. We won't go into that in this guide. Multiple space characters will get coalesced into a single space.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>view! {  
	cx,  
	&lt;h1&gt;&quot;Hello, world!&quot;&lt;/h1&gt;
	&lt;p id=&quot;NiceAffirmation&quot;&gt;&quot;
		I know things are hard, 
		but I think you're doing great!&quot;
	&lt;/p&gt;
}  
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Note that we have an id attribute set for the paragraph with a quoted value.</p>
</blockquote>
<h2 id="custom-elements"><a class="header" href="#custom-elements">Custom elements</a></h2>
<p>Recall that our Rust <code>view!</code> macro input is not actually HTML. It gets processed and converted into HTML. This gives us some extra freedom, like the ability to write our own custom elements in Rust with their own templates.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>view! {  
	cx,  
	&lt;h1&gt;&quot;Hello, world!&quot;&lt;/h1&gt;
	&lt;NiceAffirmation /&gt;
}  
<span class="boring">}</span></code></pre></pre>
<p>The above code will be converted into the following HTML:</p>
<pre><code class="language-html">&lt;h1&gt;Hello, world!&lt;/h1&gt;
&lt;NiceAffirmation&gt;&lt;/NiceAffirmation&gt;
</code></pre>
<p>The browser doesn't know what to do with the tag <code>&lt;NiceAffirmation&gt;</code>, so it treates it as a generic element that doesn't do anything.</p>
<p>We can define a template for our &quot;NiceAffirmation&quot; component and have it render our as if the element existed in the HTML spec. In a sense, we can make up our own specification for our own application using domain specific component names, and then let <code>Leptos</code> handle the rest.</p>
<p>In <code>Leptos</code> we call custome elements <code>components</code></p>
<h2 id="registering-a-custom-element-with-a-component-function"><a class="header" href="#registering-a-custom-element-with-a-component-function">Registering a custom element with a component function</a></h2>
<p>You're probably already thinking, &quot;I can imagine how I would want to break my application down into small components which I can compose/combine together.&quot; Thankfully, <code>Leptos</code> makes that exceptionally easy to do.</p>
<p>We do this by writing a function that returns (or evaluates to) the result of a <code>view!</code> macro.</p>
<p>In the following example we're using a pseudo-HTML component tag (our <strong>Leptos component</strong> tag) <code>&lt;NiceAffirmation /&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>view! {  
	cx,  
	&lt;h1&gt;&quot;Hello, world!&quot;&lt;/h1&gt;
	&lt;NiceAffirmation /&gt;
}  
<span class="boring">}</span></code></pre></pre>
<p>When the macro runs and expands the code, it'll look for a function that can be used to replace the <code>&lt;NiceAffirmation&gt;</code> tag. Leptos is magical and will do this look up for us, calling that function and embedding the the correct template as a replacement for our <strong>Leptos component</strong> tag.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
pub fn NiceAffirmation(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;You look nice today.&quot;&lt;/p&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>The definition of the function that will handle template generation for <code>&lt;NiceAffirmation /&gt;</code></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-we-know-2"><a class="header" href="#what-we-know-2">What we know</a></h1>
<ul>
<li>The <code>view!</code> macro has a body encapsulated by <code>{...}</code> with two components, the context/scope and the template, separated by a comma.</li>
<li>The <code>view!</code> macro can accept:
<ul>
<li>Quoted text</li>
<li><em>HTML element</em> tags, written in lower case</li>
<li><em>Custom web component</em> element tags, written in kebab-case (i.e. my-custom-component)</li>
<li><em>Leptos component</em> tags, written in PascalCase (i.e. MyCustomComponent)</li>
</ul>
</li>
<li>Leptos components only know what to render in place of their component tag if we provide a function with the same name as the component (in PascalCase), with <code>#[component]</code> on the line directly before the function's definition.</li>
<li>Rust's basic function syntax of <code>fn my_function_name(){}</code>.</li>
</ul>
<h1 id="what-well-learn-2"><a class="header" href="#what-well-learn-2">What we'll learn</a></h1>
<ul>
<li>Creating custom components</li>
<li>How components work</li>
</ul>
<h1 id="the-lesson"><a class="header" href="#the-lesson">The lesson</a></h1>
<p>In the previous lesson we presented the following code for a Leptos component, but we did not explain the code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn NiceAffirmation(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;You look nice today.&quot;&lt;/p&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Above we have a Leptos component (render function) which when called yield the result of a view! macro. Within the macro we have our standard two pieces, the context/scope, and the template mark-up.</p>
</blockquote>
<h3 id="breakdown"><a class="header" href="#breakdown">Breakdown</a></h3>
<h4 id="the-component-attribute-and-meta-programming"><a class="header" href="#the-component-attribute-and-meta-programming">The <code>#[component]</code> attribute and &quot;meta programming&quot;</a></h4>
<p>Rust makes use of a special attribute syntax which the compiler can use to process your source code before it's compiled. This is often called &quot;meta programming&quot; because part of our application is responsible for writing another part of our application.</p>
<p>Library authors include features like this so that users of the library can focus on writing domain specific code (code relating to the specific problem they're solving).</p>
<p>The effect of this is that we, the user of Leptos, only have to worry about writing a function that tells the application what the result of rendering a component yields (returns). What we don't have to worry about is writing the code to make sure the function is called if the component is used in other <code>view!</code> macros.</p>
<h4 id="function-definition-arguments-types-and-returns"><a class="header" href="#function-definition-arguments-types-and-returns">Function definition, arguments, types, and returns</a></h4>
<p>The following line in our code is a function definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn NiceAffirmation(cx: Scope) -&gt; Element {  
<span class="boring">}</span></code></pre></pre>
<p>It defines the idea of doing some work with a noun (the function's name) so that we can refer to it in the context of our application.  This idea of, &quot;we know nothing until we define it,&quot; is an important concept in communication in general but especially so in programming.</p>
<h5 id="breaking-down-the-function-definition"><a class="header" href="#breaking-down-the-function-definition">Breaking down the function definition</a></h5>
<p><code>fn</code> - The definition starts with this keyword which is an abbreviation for function. It tells the compiler that we're about to define a term for a process/task that can be done (called).</p>
<p><code>NiceAffirmation</code> - The name of the function in PascalCase. This name allows us to refer to the function so that if we say, &quot;Hey computer, do NiceAffirmation,&quot; it'll know where to look up what that means. It is important to note that standard function naming in Rust is written with snake_case, all lowercase letters with words separted by underscores. Leptos components use PascalCase so that the function responsible for rendering a component will match its tag name. <em>This deviates from standard Rust convention</em></p>
<p><code>(...)</code> - Some tasks require additional &quot;things&quot; for the task to be carried out. I use the term things because the requirements can be varied. Some tasks may require specialized tools (other tasks/processes), some tasks may require something to be worked upon (a subject), and some tasks require anciliary information that act as a reference (reference data). Parenthesis after the function name encapsulates this required data. These are called <strong>function parameters</strong> and they are written out separated by a comma. The values passed into these parameteres are called <strong>function arguments</strong>.</p>
<p><code>cx: Scope</code> - Each parameter listend between  <code>(</code>and <code>)</code> in a function's definition are written using a name that we can use to refer to it when doing  the work in the body of the function and the classification of what it is (it's type). The parameter name exemplified here as <code>cx</code> is written in snake_case and the type, written here as <code>Scope</code> is written in PascalCase. This helps disambiguate the two. <strong>Rust requires us to know the type of everything!</strong> But when you think about it, this makes complete sense. For example, imagine if we described a task called <code>paint_fruit_still_life</code>. To do this work we need an artist who must be a Painter, and a subject to paint which must be Fruit. It's important to note that we're just making this stuff up. We're describing the interaction of data to the application. Programming is often about setting up relationships. We would also want to guarantee that we always expect the result of this task to be a Painting. <em>It is up to us to define what it means to be a Painter, what Fruits are, and what a Painting is!</em> A definition for this could look like <code>fn paint_fruit_still_life( artist: Painter, subject: Fruits) -&gt; Painting {}</code>.  In case of Leptos components, the first thing we're accepting is the runtime context which we give the name <code>cx</code> which is of the type <code>Scope</code>. Scope is defined by Leptos and brough into the context of our application with the previously described <code>use leptos::*</code> (include all <code>*</code>) use statement.</p>
<blockquote>
<p>It's kind of fun to think about how much we imply these types in real life. If any of you have interacted with kids you can witness first hand how important it is to define the nouns we use and be clear about expectations.</p>
</blockquote>
<p><code>-&gt; Element</code> - The thin arrow followed by the name of a type indicates the result of running a function or doing a task. In the case of our Leptos component, the return type is an Element. This type is defined by Leptos and imported by our previously described <code>use leptos::*</code> (include all <code>*</code>) use statement. Some functions may not have this if they do not return anything as the result of doing their work.</p>
<h4 id="function-body-and-expressions"><a class="header" href="#function-body-and-expressions">Function body and expressions</a></h4>
<p>The body of a function is encapsulated by curly braces.<code>{...}</code>.  This is a scope. What happens in the scope, stays in the scope. A function will return the result of evaluating the last statement of its function body. You can think of statements like sentences, only the end with semicolons. This means that the last statement without a semicolon acts as the 'final word' for what a function yields. This is why the <code>view!</code> macro in our example does not have a semicolon at the end. The function runs, the last expression is the view! macro, which when evaluated yields an Element. Rust allows you to cut your application short by placing the <code>return</code> keyboard before a statement as well.</p>
<h1 id="what-we-learned"><a class="header" href="#what-we-learned">What we learned</a></h1>
<p>By defining the following function with the <code>#[component]</code> annotation, we can tell Leptos how to render specific HTML in place of a Leptos component tag in other <code>view!</code> macro's templates.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;NiceAffirmation /&gt;  
        }  
    })  
}

#[component]  
fn NiceAffirmation(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;You look nice today.&quot;&lt;/p&gt;  
    }  
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-and-the-view-macro"><a class="header" href="#variables-and-the-view-macro">Variables and the view! macro</a></h1>
<h1 id="what-we-know-3"><a class="header" href="#what-we-know-3">What we know</a></h1>
<ul>
<li>The <code>view!</code> macro can be used to create html</li>
<li>The view! macro can contain <em>custom web components</em> (using kebab-case names and requiring at least one hypen) and <em>Leptos components</em> (using PascalCase)</li>
<li>Leptos components are defined by defining a function with the name of the component using a standardized function signature (parameters and return type), and adding meta data to a function so that rust will pre-process the function and turn it into a component function for you behind the scenes.</li>
<li>Leptos components can be nested in other Leptos components</li>
</ul>
<h1 id="what-well-learn-3"><a class="header" href="#what-well-learn-3">What we'll learn</a></h1>
<ul>
<li>How to a number text in a variable (define a variable)</li>
<li>A introduction to types and memory safety</li>
</ul>
<h1 id="the-lesson-1"><a class="header" href="#the-lesson-1">The lesson</a></h1>
<p>In the previous lesson we presented the following code</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;NiceAffirmation /&gt;  
        }  
    })  
}

#[component]  
fn NiceAffirmation(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;You look nice today.&quot;&lt;/p&gt;  
    }  
}
</code></pre></pre>
<h2 id="adding-a-feature"><a class="header" href="#adding-a-feature">Adding a feature</a></h2>
<p>Along with this affirmation we'd like to add some kind of lucky number for the day to go with this affirmation.</p>
<p>This example uses integers because they are a simple data type in Rust and a good entry point into variables and Rust's type system. It's a silly example, I know. ^.^</p>
<p>We are going to add some things to our code and change a few existing components. The process of splitting code up and moving it around to allow for different changes is known as <em>Refactoring</em>.</p>
<p>First, have a read through the result to see if you can spot the changes. We're using all of the same principles as before.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
           &lt;NiceAffirmation /&gt;  
           &lt;LuckyNunber /&gt;
        }  
    })  
}

#[component]  
fn NiceAffirmation(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;You look nice today.&quot;&lt;/p&gt;  
    }  
}
#[component]  
fn LuckyNumber(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is 4&quot;&lt;/p&gt;  
    }  
}
</code></pre></pre>
<h3 id="developer-thoughts"><a class="header" href="#developer-thoughts">Developer thoughts</a></h3>
<p>Throughout these tutorials I will try to include the innner monologue that I have when thinking through a problem in the hope that it'll help you all develop your own. I also hope that the simplicity of the steps will help keep you focused when trying to work through your own problems. Don't get too far ahead of the next step in you mind. Keep this simple and break things down into small improvements. You do not need to completely solve the problem in one go. <em>Write, review, revise, repeat.</em></p>
<p>The steps to get to the above code are as follows:</p>
<ol>
<li>I need to add a new component for the LuckyNumber, so I'll write the component with a lucky number.</li>
<li>I need to add the component to the web page. I could make a new component called MorningGreeting, which has a NiceAffirmation and a LuckyNumber, but I stopped myself. This extra component would add complexity without adding anything beneficial just yet. I do not need to group these two Leptos components. They do not need to be separated from anything else. This is an important lesson to not prematurely cut your code apart and make things too comlicated. As a solution I'll just add the LuckyNumber component to my main function's view.</li>
<li>I can't change the value of the lucky number. Hooray, I've outlined an improvement and a next task. I need to find a way to be able to provide a number to my component. My component needs a parameter for the lucky number which I can provide as an argument (value).</li>
</ol>
<h2 id="tokens-and-values-in-view-components"><a class="header" href="#tokens-and-values-in-view-components">Tokens and values in <code>view!</code> components</a></h2>
<p>We've established that we need to take the 4 and make it something that can change. We need to add a token, like a symbol, as a placeholder. We need a way of saying &quot;use whatever we're calling the_lucky_number here.&quot;</p>
<p>In the <code>view!</code> macro we know that text input needs to be encapsulated by <code>&quot;...&quot;</code> quotes.</p>
<p>Values need to be encapsulated by <code>{...}</code> curley braces.</p>
<p>We'll update the following line:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        &lt;p&gt;&quot;Today's lucky number is 4&quot;&lt;/p&gt;  
<span class="boring">}</span></code></pre></pre>
<p>To look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
    }  
}

<span class="boring">}</span></code></pre></pre>
<p>Note that the quoted text no longer has the number <code>4</code>. Importantly, note that the token we've added after the string is encapsulated by curley braces. There's a space between string's closing quote and the token's first curley brace. This space will not be printed, it's just for ease of reading for developers.</p>
<p>But there's a problem. We've used <code>the_lucky_number</code> (an idea/thing/noun) but we haven't defined <em>what</em> the this idea refers to. Rust's compiler and our application doesn't understand the idea. We know it because it's in our mind, but we need to share it with the application. Writing a program is a lot like explaining something to a person who has no prior knowedge or context to understand what you're talking about. We need to define what we're talking about and what we mean.</p>
<blockquote>
<p><strong>Aside:</strong> We use shared context a lot in our lives without even knowing it. We have our own languageâ€”even slag/colloquialismsâ€”that we use without even thinking about it. We may say, &quot;Hey, can you put this bag in the bin?&quot; Someone might think, &quot;bin in my mind is defined as the garbage and they want this to be thrown out,&quot; and another might think, &quot;by bin they mean that basket over there and they want me to put this in storage.&quot; These are vastly different outcomes! Programming is tricky because we need to be aware of how others (in this case, the computer) will interpret the meaining of the language we use. You'll also find that being aware of the importance of context and how it impacts the decoding and interpreting of meaning will make you a better communicator and will help you understan others by thinking about the context they're assuming you have when interpreting their messages.</p>
</blockquote>
<p>To solve this missing and undefined context we'll write a statement that explicitly states what we mean by <code>the_lucky_number</code>.</p>
<p>Rust's syntax is very intuitive for this.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let the_lucky_number = 42;
<span class="boring">}</span></code></pre></pre>
<p>Now rust knows exactly what we mean when we say <code>the_lucky_number</code>. In this line we're telling the compiler, &quot;Hey rust, let <code>the_lucky_number</code>(the idea of a thing we're referring to as the_lucky_number) be assigned to the value 42&quot;. We can actually add even more specificity to this to tell the compiler what type of number it is.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let the_lucky_number: i32 = 42;
<span class="boring">}</span></code></pre></pre>
<p>In the above we've added a type to the noun. The pattern is as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let the_name_of_the_thing : the_type = the_value ;
<span class="boring">}</span></code></pre></pre>
<p>We've said, &quot;let the_lucky_number be an integer that is 32 bits in size (<code>i32</code>) with a value of 42&quot;. The Rust compiler will do its best to infer (figure out) the type if you don't explicitly state it. Rust will also tell you there's a problem if you've tried to assign a value that isn't a valid 32 bit integer.</p>
<p>The compiler will infer that when youi say <code>42</code> you don't mean a text string with the characters <code>42</code>, or that you don't mean 42.0 (a floating point number).</p>
<p>Our updated function isn't fully there yet, but we are able to place a number, known to Rust as an integer, into the `view! template.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope) -&gt; Element {  
	let the_lucky_number:i32 = 42;
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<h2 id="rusts-type-system"><a class="header" href="#rusts-type-system">Rust's Type System</a></h2>
<h3 id="a-mental-model-for-understanding-types"><a class="header" href="#a-mental-model-for-understanding-types">A mental model for understanding types</a></h3>
<p>Specifying the type of something is the same as specifying the range (a group) of possible values. If we specify <code>bool</code> (a boolean value) as a type, the possible values are <code>0</code> and <code>1</code>.  This is a <code>1 bit</code>.</p>
<p>When we state <code>i32</code> as a type for <code>the_lucky_number</code>, we're telling the Rust compiler, numbers in this range must be between -2,147,483,648 and 2,147,483,647. These are the largest and smallest numbers that you can create with a sequence of 32 zeros and ones <code>bits</code> in boolean, interpreted as a single number.</p>
<h3 id="the-importance-of-a-values-size"><a class="header" href="#the-importance-of-a-values-size">The importance of a value's size</a></h3>
<p>The really neat thing about computers and programs is that at the end of the day, everything is a sequence of zeros and ones. All of the things we're writing eventually get turned into bits laid out in memory.</p>
<blockquote>
<p>The really brain breaking thing hereâ€”don't dwell on it too muchâ€”is that functions are also all turned into zeros and ones!</p>
</blockquote>
<p>When we say that an <code>i32</code> is a sequence of bits, iterpreted as a single number, we mean just that. The application, under the hood, knows that 32 bits should be grabbed from memory and interpreted as a binary number. Imagine if in that same sequence of zeros and ones you had two 16 bit <code>i16</code> numbers. They would take up the same amount of space in memory (16 x 2 = 32) but they are not a 32bit number!</p>
<p>Our application needs to know how many bits to pick-up and read sequentially to interpret as a value. It also needs to know how much space (how many bits) are available to store data for that type.</p>
<p>This is one of the main features/benefits of the Rust programming language and how it lets us write safe programs. Knowledge of the size of a type allows us to safely read and write to memory.</p>
<p>Rust will always make sure that we can't have a situation where two 16 bit numbers get written in a block of 32 bits, and vise versa.</p>
<p>I realize this is complicated. Rust takes care of all of this for us. But it's important to know why we need to specify the type of a value throughout Rust, where as other languages often don't care.</p>
<h3 id="types-are-value-constraints"><a class="header" href="#types-are-value-constraints">Types are value constraints</a></h3>
<p>Rust's type system adds constraint based on size, but it also adds it based on capability/use. We'll learn more about that later but it's important that the idea be introduced.</p>
<p>At the end of the day, an easy mental model to keep is that types are constraints. An untyped value could be literally any size, supporting any functionality.</p>
<p>It's a kin to if someone said, &quot;I have a thing.&quot; You don't know if that thing is a sandwich that can be eated, if that thing is a feeling, or if that thing is a surprise that you'll be thrown a party on your birthday.&quot; As you can imagine, writing a progam where any idea could be any type can be tricky. We'd need to keep those types in our mind so that we don't inadvetantly try to do something with &quot;things&quot; that can be done to or with them.</p>
<p>When I think about types, I think about them as a list of possible values.</p>
<p>If the type is a <code>bool</code> it's possible values are 0 and 1. I can deal with that! If the type is  <code>i8</code>, then I know that the value will be a number between -128 and 127.</p>
<p>And that really is the important thing about types as constraints for Rust. Rust wants all types to be known (or to be inferable/figure-out-able) so that there <em>no surprises</em>. Rust's compiler will actually highlight spots where it sees that you've accounted or some of the possible values, but not all of them. It doesn't want you to be surprised. The Rust compiler is so nice. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leptos-component-properties"><a class="header" href="#leptos-component-properties">Leptos Component Properties</a></h1>
<h1 id="what-we-know-4"><a class="header" href="#what-we-know-4">What we know</a></h1>
<ul>
<li>Components are created with specific function definitions and a [#component] function anotation.</li>
<li>Variables can be injected into <code>view!</code> macro templates</li>
</ul>
<h1 id="what-well-learn-4"><a class="header" href="#what-well-learn-4">What we'll learn</a></h1>
<ul>
<li>How to pass values to components</li>
</ul>
<h1 id="the-lesson-2"><a class="header" href="#the-lesson-2">The Lesson</a></h1>
<p>In the previous lesson we created a component with a number, but that number is hard coded. It is static and can not change.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope) -&gt; Element {  
	let the_lucky_number:i32 = 42;
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>If we've played around with HTML or recall from earlier lessons, we might remember that HTML elements have properties, or key-value pairs of data. For example, in  <code>&lt;h1 class=&quot;fancy&quot;&gt;Lah dee dah&lt;/h1&gt;</code> we have a heading 1 element which has a class with the string value &quot;fancy&quot;. Input elements provide a more data driven example in that <code>&lt;input type=&quot;number&quot; value=&quot;42&quot; /&gt;</code> is an element that as a value property, with a value of 42.</p>
<p>What we're going to focus on is being able to write <code>&lt;LuckyNumber number={42} /&gt;</code>, actually provide it a number! We'll pass the value into the component the same as we would pass the value (argument) to a function as a property.</p>
<h2 id="step-1-updating-the-component-function-to-accept-an-external-value-as-a-property"><a class="header" href="#step-1-updating-the-component-function-to-accept-an-external-value-as-a-property">Step 1: Updating the component function to accept an external value as a property</a></h2>
<p>We need to move our noun <code>the_lucky_number</code> &quot;up and out&quot; of our component function. It needs to be a requirement of the component. We'll need someone else to provide its value for the component to work. To do this, we'll list it as a function parameter and remove the <code>let</code> statement where we define it's value.</p>
<p>The following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope) -&gt; Element {  
	let the_lucky_number : i32 = 42;
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>Turns into this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number : i32) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>Note how we've extrated the middle bits of our <code>let</code> line, moving <code>the_lucky_number : 32</code> into the function's parameter list). The name of the parameter is listed, followed by a colon, and the type of value that it's allowed to be.</p>
<blockquote>
<p>It's worth the reminder that variable names are written in snake_case by convention.</p>
</blockquote>
<h2 id="step-2-update-component-props-to-pass-a-value-to-a-component"><a class="header" href="#step-2-update-component-props-to-pass-a-value-to-a-component">Step 2: Update component props to pass a value to a component</a></h2>
<p>Our main function had a <code>view!</code> macro template with <code>&lt;LuckyNumber /&gt;  </code> in it. We've introduced the idea of a property called <code>the_lucky_number</code> in our component's definition, so we can make use of it here.  We can add the property, with the same name parameter name we used in the component, and assign a value to it.</p>
<p><code>&lt;LuckyNumber the_lucky_number=32/&gt;  </code></p>
<p>The updated main function now looks like this:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;NiceAffirmation /&gt;  
	        &lt;LuckyNumber the_lucky_number=32 /&gt;  
        }  
    })  
}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
