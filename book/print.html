<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Building Apps with Rust</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="preface.html"><strong aria-hidden="true">1.</strong> Preface</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Acknowledgements</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> About this Book</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> About the Author</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> If you get stuck or lose steam</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Introductions</li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Programming</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> What it is</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Why it's worth it</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Why it's hard</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> Programmer Thinking</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Languages</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> Meaning and Interpretation</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Architectures</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> What is architecture</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> How your computer works</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.3.</strong> How the web works</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.4.</strong> The frontend-backend divide</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.5.</strong> General application architecture</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Tools and Languages</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">9.1.</strong> Web browsers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.2.</strong> HTML</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.3.</strong> Bash and the terminal</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.4.</strong> Rust</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.5.</strong> Trunk</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.6.</strong> Cargo Leptos</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Other Resources</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro/other_resources/rust.html"><strong aria-hidden="true">10.1.</strong> Rust</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Getting Started with Rust and Leptos</li><li class="chapter-item expanded "><a href="getting_started/setup.html"><strong aria-hidden="true">11.</strong> Setup</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Foundations</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting_started/html_intro.html"><strong aria-hidden="true">12.1.</strong> Intro to HTML</a></li><li class="chapter-item expanded "><a href="getting_started/view_macro_html.html"><strong aria-hidden="true">12.2.</strong> HTML and the view! macro</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> Architecture</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">13.1.</strong> Leptos Components - #[component]</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.2.</strong> Signals (reactive values) - create_signal</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.3.</strong> Effects (side effects) - create_effect</div></li></ol></li><li class="chapter-item expanded "><li class="part-title">Generting UI</li><li class="chapter-item expanded "><a href="ui/leptos_component_intro.html"><strong aria-hidden="true">14.</strong> Introduction to Leptos components</a></li><li class="chapter-item expanded "><a href="ui/view_macro_variables.html"><strong aria-hidden="true">15.</strong> Variables and the view! macro</a></li><li class="chapter-item expanded "><a href="ui/leptos_component_properties.html"><strong aria-hidden="true">16.</strong> Component properties</a></li><li class="chapter-item expanded "><a href="ui/leptos_component_dynamic_content_separation.html"><strong aria-hidden="true">17.</strong> Component dynamic content separation</a></li><li class="chapter-item expanded "><a href="ui/loops_and_the_for_view_macro_tag.html"><strong aria-hidden="true">18.</strong> Loops and the &lt;For /&gt; view! macro tag</a></li><li class="chapter-item expanded "><a href="ui/conditional_display_and_the_show_macro.html"><strong aria-hidden="true">19.</strong> Conditional display and the &lt;Show&gt; view! macro tag</a></li><li class="chapter-item expanded "><a href="ui/tables_and_data_sets.html"><strong aria-hidden="true">20.</strong> Tables and data sets</a></li><li class="chapter-item expanded affix "><li class="part-title">Client Side</li><li class="chapter-item expanded "><div><strong aria-hidden="true">21.</strong> Responding to Events</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="client/responding/leptos_component_logging_events.html"><strong aria-hidden="true">21.1.</strong> Witnessing events</a></li><li class="chapter-item expanded "><a href="client/responding/leptos_component_update_from_event.html"><strong aria-hidden="true">21.2.</strong> Reacting to events with event handlers</a></li><li class="chapter-item expanded "><a href="client/responding/event_handlers_as_props.html"><strong aria-hidden="true">21.3.</strong> Event handers as props</a></li><li class="chapter-item expanded "><a href="client/responding/event_bubbling_and_signal_generics.html"><strong aria-hidden="true">21.4.</strong> Event Bubbling and Signal Generics</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">21.5.</strong> Preventing bubbling and default event behaviours </div></li><li class="chapter-item expanded "><a href="client/responding/custom_events.html"><strong aria-hidden="true">21.6.</strong> Custom Events</a></li><li class="chapter-item expanded "><a href="client/responding/custom_event_data.html"><strong aria-hidden="true">21.7.</strong> Custom Event Data</a></li><li class="chapter-item expanded "><a href="client/responding/custom_event_module.html"><strong aria-hidden="true">21.8.</strong> Custom Event Module</a></li><li class="chapter-item expanded "><a href="client/responding/custom_event_module_with_data.html"><strong aria-hidden="true">21.9.</strong> Custom Event Module with Data</a></li><li class="chapter-item expanded "><a href="client/responding/custom_event_data_with_signals_and_effects.html"><strong aria-hidden="true">21.10.</strong> Custom Event Data with Signals and Effects</a></li><li class="chapter-item expanded "><a href="client/responding/custom_event_data_with_signals_and_effects_part2.html"><strong aria-hidden="true">21.11.</strong> Custom Event Data with Signals and Effects - Part 2</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.</strong> Sending Data</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="client/responding/forms.html"><strong aria-hidden="true">22.1.</strong> Forms</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.2.</strong> Acton Forms</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.</strong> Sending and Receiving Data</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">23.1.</strong> Fetch</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.2.</strong> Web Socket</div></li></ol></li><li class="chapter-item expanded "><a href="client/store_data/summary.html"><strong aria-hidden="true">24.</strong> Saving/Persisting Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="client/store_data/web_storage.html"><strong aria-hidden="true">24.1.</strong> Local Storage</a></li><li class="chapter-item expanded "><a href="client/store_data/cookies.html"><strong aria-hidden="true">24.2.</strong> Cookies</a></li><li class="chapter-item expanded "><a href="client/store_data/indexeddb.html"><strong aria-hidden="true">24.3.</strong> IndexedDB</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Cargo Leptos</li><li class="chapter-item expanded affix "><li class="part-title">Server Side</li><li class="chapter-item expanded "><div><strong aria-hidden="true">25.</strong> Setup</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.</strong> Responding to Requests</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">27.</strong> Sending Data</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">27.1.</strong> Cookies</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">28.</strong> Saving/Persisting Data</div></li><li class="chapter-item expanded affix "><li class="part-title">Application Behaviours</li><li class="chapter-item expanded "><div><strong aria-hidden="true">29.</strong> Form Validation</div></li><li class="chapter-item expanded affix "><li class="part-title">Application Patterns</li><li class="chapter-item expanded "><div><strong aria-hidden="true">30.</strong> Event Sourcing</div></li><li class="chapter-item expanded affix "><li class="part-title">Common Problems</li><li class="chapter-item expanded "><div><strong aria-hidden="true">31.</strong> Offline Support and Data Sync</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">32.</strong> Observability and Logging</div></li><li class="chapter-item expanded affix "><li class="part-title">Usability Patterns and Performance Concerns</li><li class="chapter-item expanded "><div><strong aria-hidden="true">33.</strong> Bundle Size</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">34.</strong> Partial Hydration</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">35.</strong> UI Response Time</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Tutorial Projects</li><li class="chapter-item expanded "><a href="tutorial_projects/initiative_tracker/summary.html"><strong aria-hidden="true">36.</strong> RPG Initiative Tracker</a></li><li class="chapter-item expanded "><a href="tutorial_projects/chat/summary.html"><strong aria-hidden="true">37.</strong> Chat</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Building Apps with Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<p>This book is in a notes status, formed as a collection of lessons. The structure of the book and its content will change significantly through its development. It is published online in this state, in an effort to share continued development and progress. My hope that the information here in is useful in some capacity. A document of this scope is a significant undertaking and getting it right as Leptos and Rust evolve in context of my own knowledge will take time.</p>
<p>And so, pardon the multitude of typos, partial thoughts, potentially out of date bits of code—caveat emptor and enjoy.</p>
<p>Peace,
John</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-places-to-learn-rust"><a class="header" href="#other-places-to-learn-rust">Other places to learn Rust</a></h1>
<h2 id="websites"><a class="header" href="#websites">Websites</a></h2>
<ul>
<li>https://tourofrust.com — A fantastic step by step overview of Rust's language features</li>
</ul>
<h2 id="videos"><a class="header" href="#videos">Videos</a></h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=OX9HJsJUDxA&amp;list=PLai5B987bZ9CoVR-QEIN9foz4QCJ0H2Y8">The Rust Lang Book by Let's Get Rusty</a> — An in-depth guide through major laguage faeatures</li>
<li><a href="https://www.youtube.com/watch?v=bR4nGWmfzTk&amp;list=PLVhhUNGAUIQScqB26DdUq4n1Y2n3auM7X">The Rust Programming Language by Crazcalm</a> — A chapter by chapter video series of <em>The Rust Programming Language</em> book</li>
</ul>
<h2 id="books"><a class="header" href="#books">Books</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/">The Rust Programming Language</a> — Also known as &quot;The Book&quot;</li>
<li><a href="https://bfnightly.bracketproductions.com">Roguelike Tutorial - In Rust</a> — A virual copy of <em>Hands-on Rust</em></li>
</ul>
<h2 id="interactive-exercises"><a class="header" href="#interactive-exercises">Interactive Exercises</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rustlings">Rustlings</a> — A set of Rust examples with problems that you'll need to fix to progress through the exercises. </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li>Install Rust</li>
<li>Using up-to-date versions of rustc with <code>Nightly</code></li>
<li>Using up-to-date versions of Leptos from git</li>
</ol>
<hr />
<h3 id="1-install-rust"><a class="header" href="#1-install-rust">1. Install Rust</a></h3>
<p>Detail instructions on how to install Rust for your computer can be found here: https://www.rust-lang.org/tools/install</p>
<p>Installing rust will add a few things to your system.</p>
<ol>
<li>rustc - the rust compiler</li>
<li>rustup - a tool for managing rustc and the rust toolchain (https://rustup.rs)</li>
<li>cargo - the package manager and helper tool for rust (https://doc.rust-lang.org/stable/cargo/)</li>
</ol>
<h3 id="2-using-up-to-date-versions-of-rustc-with-nightly"><a class="header" href="#2-using-up-to-date-versions-of-rustc-with-nightly">2. Using up-to-date versions of rustc with <code>Nightly</code></a></h3>
<p>rustc is the rust compiler. It's possible to run different versions of the compiler. The Rust<br />
community is always working away adding new features. These new features are available<br />
immediately through nightly builds. Leptos, being brand new, makes use of some of these new<br />
features and currently requires <code>nightly</code> to run.</p>
<p>To confirm that you're using the <code>nightly</code> build of rustc (the rust compiler), open your<br />
shell/terminal and run the following command:</p>
<pre><code class="language-bash">rustc -V  
</code></pre>
<p>It should output something like this with 'nightly' in it:</p>
<pre><code class="language-bash">rustc 1.67.0-nightly (e631891f7 2022-11-13)  
</code></pre>
<p>If your version isn't the nightly build, run the following shell/terminal command:</p>
<pre><code class="language-bash">rustup default nightly  
</code></pre>
<p>Rustup is used to manage rustc. By calling the above, rustc is updated to us the nightly build<br />
as its default. You can change this to stable by using the following shell/terminal command:</p>
<pre><code class="language-bash">rustup default stable  
</code></pre>
<h3 id="3-using-up-to-date-versions-of-leptos-from-git"><a class="header" href="#3-using-up-to-date-versions-of-leptos-from-git">3. Using up-to-date versions of Leptos from git</a></h3>
<p>Leptos is changing all the time as well. It's recommended to grab the latest version directly<br />
from their git repository instead of from crates.io (https://crates.io/crates/leptos).</p>
<p>I'll go into detail on exactly how to do this when we start building our app. Don't stress if<br />
the following looks unfamiliar.</p>
<pre><code class="language-toml">[dependencies]  
leptos = { git = &quot;https://github.com/gbj/leptos&quot; }  
</code></pre>
<hr />
<h2 id="creating-your-first-app"><a class="header" href="#creating-your-first-app">Creating your first app</a></h2>
<ol>
<li>Using cargo to create a new rust app</li>
<li>Running your first rust app</li>
<li>Adding Leptos to your application as a dependency</li>
<li>Adding index.html to your application</li>
<li>Serving your index.html and bundling WASM with trunk</li>
<li>Updating client side HTML using Leptos</li>
</ol>
<hr />
<h3 id="1-using-cargo-to-create-a-new-rust-app-cargo-new"><a class="header" href="#1-using-cargo-to-create-a-new-rust-app-cargo-new">1. Using cargo to create a new rust app (<code>cargo new</code>)</a></h3>
<p>New rust projects are created with the following terminal command:</p>
<p>I'm calling my project <code>tut-leptos-client-side-event</code>, keeping in mind thst we're testing out how to handle a simple client side event.</p>
<pre><code class="language-bash">cargo new tut-leptos-client-side-event  
</code></pre>
<blockquote>
<p><strong>Did you know?</strong><br />
Cargo new will create the new project in your current working directory. You  can add path specifications to the application name to change where it's scafolded to. For example, <code>cargo new ~/dev/my-new-app</code> will create a new rust app in the <code>dev</code> directory inside your <code>~/</code> use home directory. If you see <code>~/</code> know that it's a shorthand for your user<br />
home. On OSX that would be <code>/Users/your-user-name</code>.</p>
</blockquote>
<p>When <code>cargo</code> runs with the <code>new</code> command, it creates the folder <code>tut-leptos-client-side-event</code>.</p>
<p>This folder gets setup with a few important things.</p>
<ol>
<li>A <code>src</code> directory that will contain all of our source code</li>
<li>A <code>src\main.rs</code> file, which contains our main function which is our <code>app</code>. This is called to<br />
tart our application and everything is run by calling code inside of it.</li>
<li>A <code>cargo.toml</code> file which contains meta data about our app, and it's dependences.</li>
<li>A <code>target</code> directory that will contain compiled data of our app. Ignore this folder for now.</li>
</ol>
<h3 id="2-running-your-first-rust-app-cargo-run"><a class="header" href="#2-running-your-first-rust-app-cargo-run">2. Running your first rust app (<code>cargo run</code>)</a></h3>
<p>Recall that we just made a new app with <code>cargo new tut-leptos-client-side-event</code>. Now we want to run it! Using the termninal/shell command <code>cargo run</code> will compile and run our app. Entering this terminal/shell command will not work right away. You'll get an error message:</p>
<blockquote>
<p>error: could not find <code>Cargo.toml</code> in ` ....... or any parent directory</p>
</blockquote>
<p>Cargo needs that cargo.toml file for context. It has information about which version of rust to compile for, which external bits of code (dependencies) need to be gathered to do the  compilation, and so forth.</p>
<p><code>C</code>hanging the <code>d</code>irectory of your <code>p</code>resent <code>w</code>orking <code>d</code>irectory to the directory created by <code>cargo new</code> will allow us to use the cargo.toml file for context, letting us compile the app.</p>
<blockquote>
<p><code>cd</code> – is the terminal/shell command for changing directory</p>
</blockquote>
<blockquote>
<p><code>pwd</code> – is the terminal/shell command for printing the present working directory</p>
</blockquote>
<p>The following list of commands need to be input individual, one line at a time. The first command changes the present working directory to our user home directory:</p>
<pre><code class="language-bash">cd ~/  
cargo new tut-leptos-client-side-event  
cd tut-leptos-client-side-event  
cargo run  
</code></pre>
<p>The application will take a brief period to compile and it'll print <code>Hello, world!</code> to your terminal/shell.</p>
<h3 id="3-adding-leptos-to-your-application-as-a-dependency"><a class="header" href="#3-adding-leptos-to-your-application-as-a-dependency">3. Adding Leptos to your application as a dependency</a></h3>
<p>We're going to add leptos to the mix as a dependency for our rust application.</p>
<p>First let's take a look at our stock <code>cargo.toml</code></p>
<pre><code class="language-toml">[package]  
name = &quot;tut-leptos-client-side-event&quot;  
version = &quot;0.1.0&quot;  
edition = &quot;2021&quot;  
  
# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html  
  
[dependencies]  
</code></pre>
<p>Note that we have no dependencies listed. All that exists is the heading <code>[dependencies]</code>.</p>
<p>Normally we'd use <code>cargo</code> to help us add dependencies. We'd need to call <code>cargo</code> in the<br />
context of our rust application's <code>cargo.toml</code> like we did with <code>cargo run</code>.</p>
<p>From within the <code>tut-leptos-client-side-event</code> folder we can call the following terminal/shell<br />
command:</p>
<pre><code class="language-bash">cargo add leptos  
</code></pre>
<p>Our <code>Cargo.toml</code> now includes the following:</p>
<pre><code class="language-cargo.toml">[dependencies]  
leptos = &quot;0.0.18&quot;  
</code></pre>
<p>In getting started we talked about using the git repository to grab the most up to date version of the dependency instead of the version published on crates.io (the rust package repository).</p>
<p>To do this we'll actually change the leptos entry to:</p>
<pre><code class="language-cargo.toml">leptos = { git = &quot;https://github.com/gbj/leptos&quot; }  
</code></pre>
<h3 id="4-adding-indexhtml"><a class="header" href="#4-adding-indexhtml">4. Adding index.html</a></h3>
<p>Our rust application will compile to wasm. That wasm will interact with a web page to create our client side experience. For this to work, we'll need to create an index.html.</p>
<p>Create this file in the root of your app, alongside cargo.toml. Your app directory should look like this:</p>
<pre><code>/tut-leptos-client-side-event  
	/src
		main.rs
	cargo.toml
	index.html
</code></pre>
<p>Inside the index.html should contain the following:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;  
&lt;html&gt;  
&lt;head&gt;  
    &lt;title&gt;Leptos App&lt;/title&gt;
	&lt;link data-trunk rel=&quot;rust&quot; data-wasm-opt=&quot;z&quot;/&gt;
&lt;/head&gt;  
&lt;body&gt;&lt;/body&gt;  
&lt;/html&gt;    
</code></pre>
<p>The important part of this is the following tag:</p>
<pre><code class="language-html">&lt;link data-trunk rel=&quot;rust&quot; data-wasm-opt=&quot;z&quot;/&gt;
</code></pre>
<p>A tool called <code>trunk</code> is going to eventually put all of these pieces together. The above <code>&lt;link&gt;</code> element will be replaced with rust application, compiled to wasm.</p>
<h3 id="4-serving-your-indexhtml-and-bundling-wasm-with-trunk"><a class="header" href="#4-serving-your-indexhtml-and-bundling-wasm-with-trunk">4. Serving your index.html and bundling WASM with trunk</a></h3>
<p>To use our application on the web, we need to serve it and bundle the WASM with the HTML.</p>
<p>We're going to use a tool called <code>trunk</code> which will do a few things:</p>
<ol>
<li>It'll serve index.html so that we can view it in our browser</li>
<li>It'll use <code>cargo</code> to compile the application to WASM</li>
<li>It'll attach the compiled WASM to our index.html, replacing <code>&lt;link data-trunk rel=&quot;rust&quot; data-wasm-opt=&quot;z&quot;/&gt;</code></li>
</ol>
<p>You will need to install the <code>trunk</code> tool. Instructions can be found here: https://trunkrs.dev/#install</p>
<p>For covenience, this will probably work:</p>
<pre><code class="language-shell">cargo install --locked trunk
</code></pre>
<p>To serve your app, use the following terminal/shell command while your application root is your present working directory:</p>
<pre><code class="language-shell">trunk serve
</code></pre>
<p>You'll see a variety of diagnostic information output to your prompt. The important line is this&quot;</p>
<pre><code class="language-shell">2022-11-26T15:40:19.251657Z  INFO 📡 serving static assets at -&gt; /
2022-11-26T15:40:19.251861Z  INFO 📡 server listening at http://127.0.0.1:8080
</code></pre>
<p>Listening at <code>127.0.0.1:8080</code> means that you can type that into your web browser to send a <strong>request</strong> to the server and it will provide the static files with your WASM bundled in (because it is a static file) back as the <strong>response</strong>.</p>
<p>You now have a web page!</p>
<h3 id="5-updating-client-side-html-using-leptos"><a class="header" href="#5-updating-client-side-html-using-leptos">5. Updating client side HTML using Leptos</a></h3>
<h4 id="51-understanding-mainrs"><a class="header" href="#51-understanding-mainrs">5.1 Understanding main.rs</a></h4>
<p>At this point we have a Rust application which compiles to WASM and we have a server running, listening at <code>127.0.0.1:8080</code> for requests, responding with our index.html and linked assets, most importantly our Rust application in WASM form.</p>
<p>What we don't have here is anything that updates our index.html or any form of interaction between our Rust application (WASM) and the DOM (Document Object Model — a name for the hierarchy of html elements/nodes) in the index.html.</p>
<p>We've addd leptos to our application as a dependency, and now we're going to put it to use.</p>
<p>If we look in our <code>src/main.rs</code> we can see the following:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {  
    println!(&quot;Hello, world!&quot;);  
}</code></pre></pre>
<p>Here we have a function (using the keyword <code>fn</code>) with the name <code>main</code>.  The <code>(</code> and <code>)</code> are like bookends that encapsulate a functions <strong>parameters</strong> (buckets to hold arguments passed to them) and <strong>arguments</strong> (values assigned to the parameters when called) that the function might use to run. In this case, the main function doesn't require anything to run, so it has nothing between its parenthesis after the function name. The following set of curley braces <code>{</code> and <code>}</code> encapsulate the function body here. This is what will be evaluated when the function is run; the work being done. This is the most minimal example of a <strong>function signature</strong>. There are more things that can be added but we'll get into those later.</p>
<p>The body of the function contains a single expression. Expressions need to end with <code>;</code>. You can think of it as a terminator for the end of an instruction or step that you want the application to perform.</p>
<p>Let's look at the content of this line.</p>
<p>We have <code>println!(&quot;Hello, world!&quot;);</code></p>
<p>We can look at this as <code>some-command</code>(<code>some-arguments</code>)<code>end</code></p>
<p>The command is <code>println!</code>, the argument is a sequence of characters wrapped by quotes as a convenient way to tell the compiler that you mean the characters and not other commands or variables, and an end of expression character <code>;</code> semicolon.</p>
<p>The command <code>println!</code> is provided by Rust's standard library for you to use to output text to the terminal. If you run your application you'll see <code>Hello, world!</code>, and this is why.</p>
<blockquote>
<p>Important: We've glossed over how to write your own functions with parameters. We've also skipped over how to write functions that return values. Don't worry, we'll cover that when appropriate.</p>
</blockquote>
<h5 id="macros"><a class="header" href="#macros">Macros</a></h5>
<p>We saw before that the main function is written as <code>fn main(){}</code>. There is no <code>!</code> after <code>main</code>. But there is a <code>!</code> after <code>println!</code>.</p>
<p>The <code>!</code> indicates that command is a macro. Macros are like code snippits or code templates that get expanded by the Rust compiler before it's final compilation.</p>
<p>There are function like macros, which use <code>()</code> to encapsulate their argumens. There are also procedural macros, which use <code>{}</code> to encapsulate a body of code which gets consumed by the macro.</p>
<p>As you can imagine, there is a lot involved in actually printing something to the terminal, but we can ignore the complexity with things like <code>println!</code>.</p>
<p>Macros have parameters which you can pass arguments to, just like functions. Leptos makes extensive use of macros to make our lives easier. They're wonderful!</p>
<blockquote>
<p>Important: Macros have the ability to parse (read through to understand/process) their arguments differently from standard Rust code. Keep in mind that the macro author is usually trying to do things that make life easier for the developer using their macro. Sometimes this includes reduction of noisey syntax that would normally be required, or inferences that can be assumed.</p>
</blockquote>
<h4 id="52-updating-mainrs-to-use-leptos"><a class="header" href="#52-updating-mainrs-to-use-leptos">5.2 Updating main.rs to use Leptos</a></h4>
<p>Now that we understand how Rust functions work we can start to bring Leptos into our main.rs.</p>
<p>We do this by telling the compiler that we want to <code>use</code> leptos.
We've added <code>leptos</code> as a dependency in our cargo.toml, so it now exisgts is our 'application universe' as a thing.</p>
<p>But, it doesn't exist in our <code>main.rs</code> because we haven't brought it into scope yet. Bringing things into scope is like bringing things to a workbench or crafting table to use. You need those things at hand, where you're working, so that when you refer to them the compiler knows what you mean and has the bits of code to actually use.</p>
<p>When we write <code>use leptos::*;</code> at the top of our main.rs file, we're telling Rust, <code>use</code> and think called <code>leptos</code> which you should be aware of because we defined it in our cargo.toml, and bring ALL of it's pieces into scope for us to use. The <code>::</code> is a separator the same a slash is a separator for hierarchy in your computer's file system. The <code>*</code> refers to 'everything'.</p>
<p><code>use leptos::*;</code></p>
<p>reads as</p>
<p>use everything from leptos.</p>
<p>To visualize this, think of it as taking a box of tools called &quot;Leptos&quot; and dumping all of them out onn your work bench. You can now grab any one of them for use.</p>
<h4 id="53-updating-fn-main-to-interact-with-your-html"><a class="header" href="#53-updating-fn-main-to-interact-with-your-html">5.3 Updating fn main() to interact with your html</a></h4>
<p>In our main.rs we have a <code>fn main(){}</code>. Currently it prints &quot;Hello, world!&quot; to our standard out (terminal/console).</p>
<p>What we want to do is to change the HTML in index.html when the WASM loads, which is also when the <code>fn main()</code> runs.</p>
<p>We'll use a function called <code>mount_to_body</code>, which is provided as a tool in <code>leptos</code>, made available in this scope (this main.rs file) with the use statement.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

fn main() {
	mount_to_body()
}</code></pre></pre>
<p><code>mount_to_body</code> requires some arguments to run correctly.</p>
<p>Specifically, it requires a closure. It requires a value that is actually 'runable' or 'callable'.</p>
<h5 id="closures"><a class="header" href="#closures">Closures</a></h5>
<p>A closure is functionality as a <strong>first class citizen</strong>. This means that it's a function that can be stored as a value and passed around to be called later.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_hi(){
	println!(&quot;Hi&quot;);
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>A standard function definition.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">fn main(){
	// let tells the compiler to assign
 	// the value of greeter to whatever is 
 	// after the = and before the semicolon.
	let greeter = || {
		println!(&quot;Hi&quot;);
	};
}</code></pre></pre>
<blockquote>
<p>Single line comments in Rust are prefixed by <code>//</code> at the beginning of the commend. These tell the compiler to ignore anything after it.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>|| {
	println!(&quot;Hi&quot;);
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>A closure</p>
</blockquote>
<p>The above closure syntax is like a function, but it doesn't have a name because we're expecting to assign the functionality to a name. Like we did with greeter above.</p>
<p>The parenthesis that normally encapsulate a functions arguments are converted to pipe characters to diambiguate the two. The body of the closure, just like the body of a function, is encapsulated by curly braces.</p>
<p>The following shows how a function and a closure can be called:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print_hi(); // This was a function
greeter();  // This was a value `greeter`
<span class="boring">}</span></code></pre></pre>
<p>The coolest thing here is that we can see both <code>print_hi</code> and <code>greeter</code> are names that exist in or applications context. They're ideas. Both of them are callable. And we can call them by adding parenthesis at the end.</p>
<p>This starts to hint at some of the underlying simplicity of a lot of programming. At the end of the day, we're giving names to things so that we can specify to the computer, what is what. Then we evaluate or run a bit of functionality, and give the result a name so that we can do something else after. It's this over and over again, all the way down.</p>
<h5 id="using-mount_to_body"><a class="header" href="#using-mount_to_body">Using mount_to_body</a></h5>
<p>Recall that our application's main.rs looked like this</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

fn main() {
	mount_to_body()
}</code></pre></pre>
<p>We have <code>mount_to_body</code> function being called when the application runs as WASM, when index.html is server with the WASM resource.</p>
<p>This function needs functionality to call. It needs a closure. We have the opportunity to tell it what to do with the assumption that when mount_to_body runs, it'll provide us the context in which it's running. This of this as a scope. We can make this assumption because mount_to_body specifies that it needs a closure that makes use of an argument, which we know to be context, abbreviated here as <code>cx</code>.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

fn main() {
	mount_to_body(|cx|{})
}</code></pre></pre>
<p>The above shows what an empty closure being passed to mount_to_body looks like. What this doesn't show is that the closure needs to return something that can be mounted.</p>
<p>If you ran the above you're probably receive an error like:</p>
<pre><code class="language-bash">T: Mountable, required by this bound in `leptos::mount_to_body`
</code></pre>
<p>The error messages will get easier to read over time, but it essentially says, &quot;The return type of the closure can't be used by the internals of mount_to_body. It was expecting something specific to come out of your instructions.&quot;</p>
<p>To solve this problem we're going to use the <code>view!</code> macro provided by leptos.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

fn main() {
	mount_to_body(|cx|{
		view! {  
	        cx,  
	        &lt;h1&gt;&quot;Hello, world!&quot;&lt;/h1&gt;  
	    }
	})
}</code></pre></pre>
<p>We've written the following in the body of the closure, being provided to <code>mount_to_body</code> as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>view! {  
	cx,  
	&lt;h1&gt;
		&quot;Hello, world!&quot;
	&lt;/h1&gt;  
}
<span class="boring">}</span></code></pre></pre>
<p>This procedural macros <code>view!</code> has a body which starts with cx, the context that will be provided to it by mount_to_body when it's run (again, this is inside mount_to_body and evaluated at a later time) and the view or html to mount.</p>
<p>There must be one top level item and all text needs to be quoted. It's a JSX like syntax and beautifully streamlined to write.</p>
<p>If you had <code>trunk serve</code> running this whole time, you can visit http://127.0.0.1:8080 to see your &quot;Hello, world!&quot;</p>
<p>Or, make sure your present working directory is the root of your application, type <code>trunk serve</code> and visit http://127.0.0.1:8080 to see your first working leptos WASM client side awesomeness!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intro-to-html"><a class="header" href="#intro-to-html">Intro to HTML</a></h1>
<h1 id="what-we-know"><a class="header" href="#what-we-know">What we know</a></h1>
<p>In <a href="getting_started/setup.html">Setup</a> we developed a cursory understanding of:</p>
<ul>
<li>how to create a generic Rust application</li>
<li>how to add <code>Leptos</code> as a dependency to our Rust application</li>
<li>how to serve a file with <code>trunk</code></li>
<li>how to update an HTML file with Rust, using <code>Leptos</code>'s <code>mount_to_body</code> function and it's <code>view!</code> macro</li>
</ul>
<h1 id="what-well-learn"><a class="header" href="#what-well-learn">What we'll learn</a></h1>
<ul>
<li>Working with HTML and developing a mental model</li>
</ul>
<h1 id="where-were-at"><a class="header" href="#where-were-at">Where we're at</a></h1>
<p>Code from our <code>main.rs</code> looks like this:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;h1&gt;&quot;Hello, world!&quot;&lt;/h1&gt;  
        }  
    })  
}</code></pre></pre>
<blockquote>
<p>The <code>main</code> function <code>fn</code> is run when our application runs as WASM.</p>
<p>Recall that the <code>trunk</code> tool uses <code>cargo</code> also a tool with <code>rustc</code> to compile it to the WASM target, which gets served and linked to our index.html. We view (request) the page in our browser, loading the html and linked WASM, kicking the whole thing off.</p>
<p>When the application runs the function <code>mount_to_body</code> is called (runs), which we pass (or provide) a closure (a big of functionality stored as a value) as an argument to it's callback parameter (the bucket that holds things that <code>mount_to_body</code> needs to run, <em>&quot;function dependencies&quot;</em>).</p>
<p>When <code>mount_to_body</code> runs, it takes the  functionality we've provided as a closure (a <em>strategy</em> if you will) and calls it (makes it run) with its runtime context <code>cx</code>. This does all of the heaving lifting to write our heading the body of our HTML page in index.html</p>
</blockquote>
<h1 id="lesson-working-with-html-and-developing-a-mental-model"><a class="header" href="#lesson-working-with-html-and-developing-a-mental-model">Lesson: Working with HTML and developing a mental model</a></h1>
<p>We're not doing much more than creating a static template. If this is all you need, better to stick with a plain old HTML file.</p>
<h2 id="html-elements-and-tags"><a class="header" href="#html-elements-and-tags">HTML Elements and Tags</a></h2>
<p>HTML is made up of Elements. There are a whole list of HTML elements ready for use and supported by all current browsers, from heading and paragraphs to form elements for collecting data from users like. These Elements are written using HTML tags, <code>&lt;h1&gt;</code>, <code>&lt;p&gt;</code>, and <code>&lt;input&gt;</code> respectively.</p>
<h3 id="tags-with-content"><a class="header" href="#tags-with-content">Tags with content</a></h3>
<p>Some tags have content. The syntax is to encapsulate the content or wrap it with opening and closing tags. The closing tag has a slash before the tag name.</p>
<pre><code class="language-html">	&lt;h1&gt;Some Content&lt;/h1&gt;
</code></pre>
<blockquote>
<p>This Heading 1 tag has content, which requies a closing tag so that it's content can be wrapped/encapsulated.</p>
</blockquote>
<p>What's neat about this opening and closing tag business is that it's not <em>that</em> different from when we called a function and provided an argument (value) for it's parameter. As time goes on you'll start to see a pattern emerging. The above isn't going to look at different from:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	h1(&quot;Some Content&quot;)
<span class="boring">}</span></code></pre></pre>
<h3 id="tags-without-content"><a class="header" href="#tags-without-content">Tags without content</a></h3>
<p>Some tags don't have content. To express a tag without content we add a backslash at the end of the tag of the tag. This tells browsers that there is no closing tag.</p>
<pre><code class="language-html">&lt;hr /&gt;
</code></pre>
<blockquote>
<p>This Horizontal Rule tag doesn't have a closing tag</p>
</blockquote>
<h3 id="tag-configuration-with-properties-and-attributes"><a class="header" href="#tag-configuration-with-properties-and-attributes">Tag configuration with properties and attributes</a></h3>
<p>HTML Elements can be configured by setting values for supported properties and attributes. If you've played around with HTML before you'll probably have seen commong properties like <code>id</code> and <code>class</code>:</p>
<pre><code class="language-html">&lt;h1 id=&quot;my-unique-heading&quot;&gt;Hello, world!&lt;/h1&gt;
</code></pre>
<blockquote>
<p>Some poperties have specific requirements for their values. <code>id</code> for example, should have a unique value across all Elements on the page.</p>
</blockquote>
<pre><code class="language-html">&lt;input name=&quot;first-name&quot; placeholder=&quot;Enter your name...&quot; type=&quot;text&quot; /&gt;
</code></pre>
<blockquote>
<p>The input tag has a <code>type</code> which completely changes how its rendered (displayed to the user).</p>
</blockquote>
<h3 id="the-browser-as-interpreter"><a class="header" href="#the-browser-as-interpreter">The browser as interpreter</a></h3>
<p>When you send a request to the server, it returns a response which has a body (the data, often as text) and headers (meta information about the body). Information in the headers tells the browser how to interpret the body.</p>
<blockquote>
<p>Analogy time: Imagine if you went to a library and asked a librarian for a book. This is like you, the web browser, submitted a request to a server. The librarian (the server) will then provide a response to your request. They may return with the book and a slip of paper saying, &quot;I found the book and this book is in english.&quot; We can now use our knowlege of the english language to parse the book (turn it into meaningful data) and understand it.</p>
</blockquote>
<p>Traditionally servers respond to web requests telling the browser that the body's response  is text/html. A browser very deeply wants to render your page for you, so it dutifully reads through what it's been told is html, parses it into meaningful data (the DOM, Document Object Model), and renders it to the screen.</p>
<p>Things like:</p>
<pre><code class="language-html">&lt;input name=&quot;first-name&quot; placeholder=&quot;Enter your name...&quot; type=&quot;text&quot; /&gt;
</code></pre>
<p>Turn more into an object (a thing) with the following properties:</p>
<pre><code>HTML Element Type = &quot;input&quot;
name = &quot;first-name&quot;
placeholder = &quot;Enter your name...&quot;
type = &quot;text&quot;
</code></pre>
<blockquote>
<p>This isn't real code, but it does look a lot like what we'll call a <strong>struct</strong> in Rust later. Once again we can see similar shared underlying principles. This idea of &quot;a thing with stuff&quot; comes up time and time agin.</p>
</blockquote>
<p>There may be bits of information that the browser doesn't understand. Instead of crashing it often ignores this unknown information, or makes assumptions about it to still continue to render the page.</p>
<p>Browsers and HTML rendering engines are extremely complex and down right magical. We can throw so much at them and they keep on going.</p>
<h3 id="what-the-element"><a class="header" href="#what-the-element">What the element?</a></h3>
<p>Recall that before we talked about HTML elements, properties, and attributes. It might feel like HTML is an expressive programming language, but it is actually what we would call a DSL (Domain Specific Language). They're instructions that pertain specific to rendering web pages that tell the browser our intent. We <strong>declare</strong> what we want and it's the browser's <strong>imperative</strong> to decide how to render it.</p>
<p>In standard HTML you can not just make up properties or Elements/tags. It might look like we're choosing to write <code>h1</code> because it's convenient for us to think about a primary heading as a <code>h1</code>, but this is actually part of the specification of HTML.</p>
<p>Developers can now create their own custom elements with Javascript, but we're going to ignore that for now. Just know that it does exist but more work is required than just writing you own tag names.</p>
<h3 id="what-does-this-mean-for-the-view-macro-and-which-html-elements-we-can-use-in-it"><a class="header" href="#what-does-this-mean-for-the-view-macro-and-which-html-elements-we-can-use-in-it">What does this mean for the <code>view!</code> macro and which HTML elements we can use in it?</a></h3>
<p>The content that we place in our <code>view!</code> macro is interpreted by the <code>view!</code> macro when the rust compiler expands it. It takes what we've provided and says, &quot;Ok, so this is what you want... but the rest of the application can't work with this. What you've written isn't actually HTML and it's not actually Rust. I'll parse this input and rewrite it so that the rest of our application can use it, saving you from the verbosity and potentially error prone nature of writing it yourself.&quot;</p>
<p>In the next lesson we'll learn about making components which we can compose and how Leptos allows us to have custom components/elements while still generating HTML that the browser can parse and understand according to the HTML spec.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="html-and-the-view-macro"><a class="header" href="#html-and-the-view-macro">HTML and the <code>view!</code> macro</a></h1>
<h2 id="what-we-know-1"><a class="header" href="#what-we-know-1">What we know</a></h2>
<ul>
<li>HTML is a specification for a domain specific language that is parsed by a web browser to render a web page</li>
<li>The web browser will do its best to render a page, ignoring or gracefully interpreting code in a page that doesn't match the HTML specification.</li>
<li>The <code>view!</code> macro accepts its arguments between curly braces <code>{}</code>, accepting a context <code>cx</code> and HTML like mark-up.</li>
</ul>
<h1 id="what-well-learn-1"><a class="header" href="#what-well-learn-1">What we'll learn</a></h1>
<ul>
<li>Creating custom components</li>
</ul>
<h1 id="where-were-at-1"><a class="header" href="#where-were-at-1">Where we're at</a></h1>
<p>Code from our <code>main.rs</code> looks like this:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;h1&gt;&quot;Hello, world!&quot;&lt;/h1&gt;  
        }  
    })  
}</code></pre></pre>
<blockquote>
<p>We can see that after the context variable we have some HTML like text. If this were HTML, you'd have a heading that reads <strong>&quot;Hello, world!&quot;</strong> with the quotes displaying. However, this isn't pure HTML and the macro will process the template to remove the quotes.</p>
</blockquote>
<h2 id="view-macro-syntax"><a class="header" href="#view-macro-syntax"><code>View!</code> macro syntax</a></h2>
<p>The <a href="https://docs.rs/leptos/latest/leptos/macro.view.html">view! macro documentation</a> is very nicely detailed with details about it's basic and advanced syntax. It's a JSX like syntax. We'll slowly touch on all of the features as we continue to learn Rust and <code>Leptos</code>.</p>
<p>For now, the important thing to remember is that strings need to be quoted.</p>
<p>@todo, highlight that a view contains element markup and text nodes. That's it</p>
<h2 id="adding-more-to-a-view"><a class="header" href="#adding-more-to-a-view">Adding more to a view</a></h2>
<p>You can continue to add other html elements as if you were writing plain HTML. Line breaks and indentation will not break the syntax. HTML code often has a lot of line breaks or white space from code formatting. Web browsers will ignore this unless you specify that you want the white space retained. We won't go into that in this guide. Multiple space characters will get coalesced into a single space.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>view! {  
	cx,  
	&lt;h1&gt;&quot;Hello, world!&quot;&lt;/h1&gt;
	&lt;p id=&quot;NiceAffirmation&quot;&gt;&quot;
		I know things are hard, 
		but I think you're doing great!&quot;
	&lt;/p&gt;
}  
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Note that we have an id attribute set for the paragraph with a quoted value.</p>
</blockquote>
<h2 id="custom-elements"><a class="header" href="#custom-elements">Custom elements</a></h2>
<p>Recall that our Rust <code>view!</code> macro input is not actually HTML. It gets processed and converted into HTML. This gives us some extra freedom, like the ability to write our own custom elements in Rust with their own templates.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>view! {  
	cx,  
	&lt;h1&gt;&quot;Hello, world!&quot;&lt;/h1&gt;
	&lt;NiceAffirmation /&gt;
}  
<span class="boring">}</span></code></pre></pre>
<p>The above code will be converted into the following HTML:</p>
<pre><code class="language-html">&lt;h1&gt;Hello, world!&lt;/h1&gt;
&lt;NiceAffirmation&gt;&lt;/NiceAffirmation&gt;
</code></pre>
<p>The browser doesn't know what to do with the tag <code>&lt;NiceAffirmation&gt;</code>, so it treates it as a generic element that doesn't do anything.</p>
<p>We can define a template for our &quot;NiceAffirmation&quot; component and have it render our as if the element existed in the HTML spec. In a sense, we can make up our own specification for our own application using domain specific component names, and then let <code>Leptos</code> handle the rest.</p>
<p>In <code>Leptos</code> we call custome elements <code>components</code></p>
<h2 id="registering-a-custom-element-with-a-component-function"><a class="header" href="#registering-a-custom-element-with-a-component-function">Registering a custom element with a component function</a></h2>
<p>You're probably already thinking, &quot;I can imagine how I would want to break my application down into small components which I can compose/combine together.&quot; Thankfully, <code>Leptos</code> makes that exceptionally easy to do.</p>
<p>We do this by writing a function that returns (or evaluates to) the result of a <code>view!</code> macro.</p>
<p>In the following example we're using a pseudo-HTML component tag (our <strong>Leptos component</strong> tag) <code>&lt;NiceAffirmation /&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>view! {  
	cx,  
	&lt;h1&gt;&quot;Hello, world!&quot;&lt;/h1&gt;
	&lt;NiceAffirmation /&gt;
}  
<span class="boring">}</span></code></pre></pre>
<p>When the macro runs and expands the code, it'll look for a function that can be used to replace the <code>&lt;NiceAffirmation&gt;</code> tag. Leptos is magical and will do this look up for us, calling that function and embedding the the correct template as a replacement for our <strong>Leptos component</strong> tag.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
pub fn NiceAffirmation(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;You look nice today.&quot;&lt;/p&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>The definition of the function that will handle template generation for <code>&lt;NiceAffirmation /&gt;</code></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-we-know-2"><a class="header" href="#what-we-know-2">What we know</a></h1>
<ul>
<li>The <code>view!</code> macro has a body encapsulated by <code>{...}</code> with two components, the context/scope and the template, separated by a comma.</li>
<li>The <code>view!</code> macro can accept:
<ul>
<li>Quoted text</li>
<li><em>HTML element</em> tags, written in lower case</li>
<li><em>Custom web component</em> element tags, written in kebab-case (i.e. my-custom-component)</li>
<li><em>Leptos component</em> tags, written in PascalCase (i.e. MyCustomComponent)</li>
</ul>
</li>
<li>Leptos components only know what to render in place of their component tag if we provide a function with the same name as the component (in PascalCase), with <code>#[component]</code> on the line directly before the function's definition.</li>
<li>Rust's basic function syntax of <code>fn my_function_name(){}</code>.</li>
</ul>
<h1 id="what-well-learn-2"><a class="header" href="#what-well-learn-2">What we'll learn</a></h1>
<ul>
<li>Creating custom components</li>
<li>How components work</li>
</ul>
<h1 id="the-lesson"><a class="header" href="#the-lesson">The lesson</a></h1>
<p>In the previous lesson we presented the following code for a Leptos component, but we did not explain the code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn NiceAffirmation(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;You look nice today.&quot;&lt;/p&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Above we have a Leptos component (render function) which when called yield the result of a view! macro. Within the macro we have our standard two pieces, the context/scope, and the template mark-up.</p>
</blockquote>
<h3 id="breakdown"><a class="header" href="#breakdown">Breakdown</a></h3>
<h4 id="the-component-attribute-and-meta-programming"><a class="header" href="#the-component-attribute-and-meta-programming">The <code>#[component]</code> attribute and &quot;meta programming&quot;</a></h4>
<p>Rust makes use of a special attribute syntax which the compiler can use to process your source code before it's compiled. This is often called &quot;meta programming&quot; because part of our application is responsible for writing another part of our application.</p>
<p>Library authors include features like this so that users of the library can focus on writing domain specific code (code relating to the specific problem they're solving).</p>
<p>The effect of this is that we, the user of Leptos, only have to worry about writing a function that tells the application what the result of rendering a component yields (returns). What we don't have to worry about is writing the code to make sure the function is called if the component is used in other <code>view!</code> macros.</p>
<h4 id="function-definition-arguments-types-and-returns"><a class="header" href="#function-definition-arguments-types-and-returns">Function definition, arguments, types, and returns</a></h4>
<p>The following line in our code is a function definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn NiceAffirmation(cx: Scope) -&gt; Element {  
<span class="boring">}</span></code></pre></pre>
<p>It defines the idea of doing some work with a noun (the function's name) so that we can refer to it in the context of our application.  This idea of, &quot;we know nothing until we define it,&quot; is an important concept in communication in general but especially so in programming.</p>
<h5 id="breaking-down-the-function-definition"><a class="header" href="#breaking-down-the-function-definition">Breaking down the function definition</a></h5>
<p><code>fn</code> - The definition starts with this keyword which is an abbreviation for function. It tells the compiler that we're about to define a term for a process/task that can be done (called).</p>
<p><code>NiceAffirmation</code> - The name of the function in PascalCase. This name allows us to refer to the function so that if we say, &quot;Hey computer, do NiceAffirmation,&quot; it'll know where to look up what that means. It is important to note that standard function naming in Rust is written with snake_case, all lowercase letters with words separted by underscores. Leptos components use PascalCase so that the function responsible for rendering a component will match its tag name. <em>This deviates from standard Rust convention</em></p>
<p><code>(...)</code> - Some tasks require additional &quot;things&quot; for the task to be carried out. I use the term things because the requirements can be varied. Some tasks may require specialized tools (other tasks/processes), some tasks may require something to be worked upon (a subject), and some tasks require anciliary information that act as a reference (reference data). Parenthesis after the function name encapsulates this required data. These are called <strong>function parameters</strong> and they are written out separated by a comma. The values passed into these parameteres are called <strong>function arguments</strong>.</p>
<p><code>cx: Scope</code> - Each parameter listend between  <code>(</code>and <code>)</code> in a function's definition are written using a name that we can use to refer to it when doing  the work in the body of the function and the classification of what it is (it's type). The parameter name exemplified here as <code>cx</code> is written in snake_case and the type, written here as <code>Scope</code> is written in PascalCase. This helps disambiguate the two. <strong>Rust requires us to know the type of everything!</strong> But when you think about it, this makes complete sense. For example, imagine if we described a task called <code>paint_fruit_still_life</code>. To do this work we need an artist who must be a Painter, and a subject to paint which must be Fruit. It's important to note that we're just making this stuff up. We're describing the interaction of data to the application. Programming is often about setting up relationships. We would also want to guarantee that we always expect the result of this task to be a Painting. <em>It is up to us to define what it means to be a Painter, what Fruits are, and what a Painting is!</em> A definition for this could look like <code>fn paint_fruit_still_life( artist: Painter, subject: Fruits) -&gt; Painting {}</code>.  In case of Leptos components, the first thing we're accepting is the runtime context which we give the name <code>cx</code> which is of the type <code>Scope</code>. Scope is defined by Leptos and brough into the context of our application with the previously described <code>use leptos::*</code> (include all <code>*</code>) use statement.</p>
<blockquote>
<p>It's kind of fun to think about how much we imply these types in real life. If any of you have interacted with kids you can witness first hand how important it is to define the nouns we use and be clear about expectations.</p>
</blockquote>
<p><code>-&gt; Element</code> - The thin arrow followed by the name of a type indicates the result of running a function or doing a task. In the case of our Leptos component, the return type is an Element. This type is defined by Leptos and imported by our previously described <code>use leptos::*</code> (include all <code>*</code>) use statement. Some functions may not have this if they do not return anything as the result of doing their work.</p>
<h4 id="function-body-and-expressions"><a class="header" href="#function-body-and-expressions">Function body and expressions</a></h4>
<p>The body of a function is encapsulated by curly braces.<code>{...}</code>.  This is a scope. What happens in the scope, stays in the scope. A function will return the result of evaluating the last statement of its function body. You can think of statements like sentences, only the end with semicolons. This means that the last statement without a semicolon acts as the 'final word' for what a function yields. This is why the <code>view!</code> macro in our example does not have a semicolon at the end. The function runs, the last expression is the view! macro, which when evaluated yields an Element. Rust allows you to cut your application short by placing the <code>return</code> keyboard before a statement as well.</p>
<h1 id="what-we-learned"><a class="header" href="#what-we-learned">What we learned</a></h1>
<p>By defining the following function with the <code>#[component]</code> annotation, we can tell Leptos how to render specific HTML in place of a Leptos component tag in other <code>view!</code> macro's templates.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;NiceAffirmation /&gt;  
        }  
    })  
}

#[component]  
fn NiceAffirmation(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;You look nice today.&quot;&lt;/p&gt;  
    }  
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-and-the-view-macro"><a class="header" href="#variables-and-the-view-macro">Variables and the view! macro</a></h1>
<h1 id="what-we-know-3"><a class="header" href="#what-we-know-3">What we know</a></h1>
<ul>
<li>The <code>view!</code> macro can be used to create html</li>
<li>The view! macro can contain <em>custom web components</em> (using kebab-case names and requiring at least one hypen) and <em>Leptos components</em> (using PascalCase)</li>
<li>Leptos components are defined by defining a function with the name of the component using a standardized function signature (parameters and return type), and adding meta data to a function so that rust will pre-process the function and turn it into a component function for you behind the scenes.</li>
<li>Leptos components can be nested in other Leptos components</li>
</ul>
<h1 id="what-well-learn-3"><a class="header" href="#what-well-learn-3">What we'll learn</a></h1>
<ul>
<li>How to a number text in a variable (define a variable)</li>
<li>A introduction to types and memory safety</li>
</ul>
<h1 id="the-lesson-1"><a class="header" href="#the-lesson-1">The lesson</a></h1>
<p>In the previous lesson we presented the following code</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;NiceAffirmation /&gt;  
        }  
    })  
}

#[component]  
fn NiceAffirmation(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;You look nice today.&quot;&lt;/p&gt;  
    }  
}
</code></pre></pre>
<h2 id="adding-a-feature"><a class="header" href="#adding-a-feature">Adding a feature</a></h2>
<p>Along with this affirmation we'd like to add some kind of lucky number for the day to go with this affirmation.</p>
<p>This example uses integers because they are a simple data type in Rust and a good entry point into variables and Rust's type system. It's a silly example, I know. ^.^</p>
<p>We are going to add some things to our code and change a few existing components. The process of splitting code up and moving it around to allow for different changes is known as <em>Refactoring</em>.</p>
<p>First, have a read through the result to see if you can spot the changes. We're using all of the same principles as before.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
           &lt;NiceAffirmation /&gt;  
           &lt;LuckyNunber /&gt;
        }  
    })  
}

#[component]  
fn NiceAffirmation(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;You look nice today.&quot;&lt;/p&gt;  
    }  
}
#[component]  
fn LuckyNumber(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is 4&quot;&lt;/p&gt;  
    }  
}
</code></pre></pre>
<h3 id="developer-thoughts"><a class="header" href="#developer-thoughts">Developer thoughts</a></h3>
<p>Throughout these tutorials I will try to include the innner monologue that I have when thinking through a problem in the hope that it'll help you all develop your own. I also hope that the simplicity of the steps will help keep you focused when trying to work through your own problems. Don't get too far ahead of the next step in you mind. Keep this simple and break things down into small improvements. You do not need to completely solve the problem in one go. <em>Write, review, revise, repeat.</em></p>
<p>The steps to get to the above code are as follows:</p>
<ol>
<li>I need to add a new component for the LuckyNumber, so I'll write the component with a lucky number.</li>
<li>I need to add the component to the web page. I could make a new component called MorningGreeting, which has a NiceAffirmation and a LuckyNumber, but I stopped myself. This extra component would add complexity without adding anything beneficial just yet. I do not need to group these two Leptos components. They do not need to be separated from anything else. This is an important lesson to not prematurely cut your code apart and make things too comlicated. As a solution I'll just add the LuckyNumber component to my main function's view.</li>
<li>I can't change the value of the lucky number. Hooray, I've outlined an improvement and a next task. I need to find a way to be able to provide a number to my component. My component needs a parameter for the lucky number which I can provide as an argument (value).</li>
</ol>
<h2 id="tokens-and-values-in-view-components"><a class="header" href="#tokens-and-values-in-view-components">Tokens and values in <code>view!</code> components</a></h2>
<p>We've established that we need to take the 4 and make it something that can change. We need to add a token, like a symbol, as a placeholder. We need a way of saying &quot;use whatever we're calling the_lucky_number here.&quot;</p>
<p>In the <code>view!</code> macro we know that text input needs to be encapsulated by <code>&quot;...&quot;</code> quotes.</p>
<p>Values need to be encapsulated by <code>{...}</code> curley braces.</p>
<p>We'll update the following line:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        &lt;p&gt;&quot;Today's lucky number is 4&quot;&lt;/p&gt;  
<span class="boring">}</span></code></pre></pre>
<p>To look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
    }  
}

<span class="boring">}</span></code></pre></pre>
<p>Note that the quoted text no longer has the number <code>4</code>. Importantly, note that the token we've added after the string is encapsulated by curley braces. There's a space between string's closing quote and the token's first curley brace. This space will not be printed, it's just for ease of reading for developers.</p>
<p>But there's a problem. We've used <code>the_lucky_number</code> (an idea/thing/noun) but we haven't defined <em>what</em> the this idea refers to. Rust's compiler and our application doesn't understand the idea. We know it because it's in our mind, but we need to share it with the application. Writing a program is a lot like explaining something to a person who has no prior knowedge or context to understand what you're talking about. We need to define what we're talking about and what we mean.</p>
<blockquote>
<p><strong>Aside:</strong> We use shared context a lot in our lives without even knowing it. We have our own language—even slag/colloquialisms—that we use without even thinking about it. We may say, &quot;Hey, can you put this bag in the bin?&quot; Someone might think, &quot;bin in my mind is defined as the garbage and they want this to be thrown out,&quot; and another might think, &quot;by bin they mean that basket over there and they want me to put this in storage.&quot; These are vastly different outcomes! Programming is tricky because we need to be aware of how others (in this case, the computer) will interpret the meaining of the language we use. You'll also find that being aware of the importance of context and how it impacts the decoding and interpreting of meaning will make you a better communicator and will help you understan others by thinking about the context they're assuming you have when interpreting their messages.</p>
</blockquote>
<p>To solve this missing and undefined context we'll write a statement that explicitly states what we mean by <code>the_lucky_number</code>.</p>
<p>Rust's syntax is very intuitive for this.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let the_lucky_number = 42;
<span class="boring">}</span></code></pre></pre>
<p>Now rust knows exactly what we mean when we say <code>the_lucky_number</code>. In this line we're telling the compiler, &quot;Hey rust, let <code>the_lucky_number</code>(the idea of a thing we're referring to as the_lucky_number) be assigned to the value 42&quot;. We can actually add even more specificity to this to tell the compiler what type of number it is.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let the_lucky_number: i32 = 42;
<span class="boring">}</span></code></pre></pre>
<p>In the above we've added a type to the noun. The pattern is as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let the_name_of_the_thing : the_type = the_value ;
<span class="boring">}</span></code></pre></pre>
<p>We've said, &quot;let the_lucky_number be an integer that is 32 bits in size (<code>i32</code>) with a value of 42&quot;. The Rust compiler will do its best to infer (figure out) the type if you don't explicitly state it. Rust will also tell you there's a problem if you've tried to assign a value that isn't a valid 32 bit integer.</p>
<p>The compiler will infer that when youi say <code>42</code> you don't mean a text string with the characters <code>42</code>, or that you don't mean 42.0 (a floating point number).</p>
<p>Our updated function isn't fully there yet, but we are able to place a number, known to Rust as an integer, into the `view! template.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope) -&gt; Element {  
	let the_lucky_number:i32 = 42;
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<h2 id="rusts-type-system"><a class="header" href="#rusts-type-system">Rust's Type System</a></h2>
<h3 id="a-mental-model-for-understanding-types"><a class="header" href="#a-mental-model-for-understanding-types">A mental model for understanding types</a></h3>
<p>Specifying the type of something is the same as specifying the range (a group) of possible values. If we specify <code>bool</code> (a boolean value) as a type, the possible values are <code>0</code> and <code>1</code>.  This is a <code>1 bit</code>.</p>
<p>When we state <code>i32</code> as a type for <code>the_lucky_number</code>, we're telling the Rust compiler, numbers in this range must be between -2,147,483,648 and 2,147,483,647. These are the largest and smallest numbers that you can create with a sequence of 32 zeros and ones <code>bits</code> in boolean, interpreted as a single number.</p>
<h3 id="the-importance-of-a-values-size"><a class="header" href="#the-importance-of-a-values-size">The importance of a value's size</a></h3>
<p>The really neat thing about computers and programs is that at the end of the day, everything is a sequence of zeros and ones. All of the things we're writing eventually get turned into bits laid out in memory.</p>
<blockquote>
<p>The really brain breaking thing here—don't dwell on it too much—is that functions are also all turned into zeros and ones!</p>
</blockquote>
<p>When we say that an <code>i32</code> is a sequence of bits, iterpreted as a single number, we mean just that. The application, under the hood, knows that 32 bits should be grabbed from memory and interpreted as a binary number. Imagine if in that same sequence of zeros and ones you had two 16 bit <code>i16</code> numbers. They would take up the same amount of space in memory (16 x 2 = 32) but they are not a 32bit number!</p>
<p>Our application needs to know how many bits to pick-up and read sequentially to interpret as a value. It also needs to know how much space (how many bits) are available to store data for that type.</p>
<p>This is one of the main features/benefits of the Rust programming language and how it lets us write safe programs. Knowledge of the size of a type allows us to safely read and write to memory.</p>
<p>Rust will always make sure that we can't have a situation where two 16 bit numbers get written in a block of 32 bits, and vise versa.</p>
<p>I realize this is complicated. Rust takes care of all of this for us. But it's important to know why we need to specify the type of a value throughout Rust, where as other languages often don't care.</p>
<h3 id="types-are-value-constraints"><a class="header" href="#types-are-value-constraints">Types are value constraints</a></h3>
<p>Rust's type system adds constraint based on size, but it also adds it based on capability/use. We'll learn more about that later but it's important that the idea be introduced.</p>
<p>At the end of the day, an easy mental model to keep is that types are constraints. An untyped value could be literally any size, supporting any functionality.</p>
<p>It's a kin to if someone said, &quot;I have a thing.&quot; You don't know if that thing is a sandwich that can be eated, if that thing is a feeling, or if that thing is a surprise that you'll be thrown a party on your birthday.&quot; As you can imagine, writing a progam where any idea could be any type can be tricky. We'd need to keep those types in our mind so that we don't inadvetantly try to do something with &quot;things&quot; that can be done to or with them.</p>
<p>When I think about types, I think about them as a list of possible values.</p>
<p>If the type is a <code>bool</code> it's possible values are 0 and 1. I can deal with that! If the type is  <code>i8</code>, then I know that the value will be a number between -128 and 127.</p>
<p>And that really is the important thing about types as constraints for Rust. Rust wants all types to be known (or to be inferable/figure-out-able) so that there <em>no surprises</em>. Rust's compiler will actually highlight spots where it sees that you've accounted or some of the possible values, but not all of them. It doesn't want you to be surprised. The Rust compiler is so nice. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leptos-component-properties"><a class="header" href="#leptos-component-properties">Leptos Component Properties</a></h1>
<h1 id="what-we-know-4"><a class="header" href="#what-we-know-4">What we know</a></h1>
<ul>
<li>Components are created with specific function definitions and a [#component] function anotation.</li>
<li>Variables can be injected into <code>view!</code> macro templates</li>
</ul>
<h1 id="what-well-learn-4"><a class="header" href="#what-well-learn-4">What we'll learn</a></h1>
<ul>
<li>How to pass values to components</li>
</ul>
<h1 id="the-lesson-2"><a class="header" href="#the-lesson-2">The Lesson</a></h1>
<p>In the previous lesson we created a component with a number, but that number is hard coded. It is static and can not change.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope) -&gt; Element {  
	let the_lucky_number:i32 = 42;
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>If we've played around with HTML or recall from earlier lessons, we might remember that HTML elements have properties, or key-value pairs of data. For example, in  <code>&lt;h1 class=&quot;fancy&quot;&gt;Lah dee dah&lt;/h1&gt;</code> we have a heading 1 element which has a class with the string value &quot;fancy&quot;. Input elements provide a more data driven example in that <code>&lt;input type=&quot;number&quot; value=&quot;42&quot; /&gt;</code> is an element that as a value property, with a value of 42.</p>
<p>What we're going to focus on is being able to write <code>&lt;LuckyNumber number={42} /&gt;</code>, actually provide it a number! We'll pass the value into the component the same as we would pass the value (argument) to a function as a property.</p>
<h2 id="step-1-updating-the-component-function-to-accept-an-external-value-as-a-property"><a class="header" href="#step-1-updating-the-component-function-to-accept-an-external-value-as-a-property">Step 1: Updating the component function to accept an external value as a property</a></h2>
<p>We need to move our noun <code>the_lucky_number</code> &quot;up and out&quot; of our component function. It needs to be a requirement of the component. We'll need someone else to provide its value for the component to work. To do this, we'll list it as a function parameter and remove the <code>let</code> statement where we define it's value.</p>
<p>The following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope) -&gt; Element {  
	let the_lucky_number : i32 = 42;
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>Turns into this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number : i32) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>Note how we've extrated the middle bits of our <code>let</code> line, moving <code>the_lucky_number : 32</code> into the function's parameter list). The name of the parameter is listed, followed by a colon, and the type of value that it's allowed to be.</p>
<blockquote>
<p>It's worth the reminder that variable names are written in snake_case by convention.</p>
</blockquote>
<h2 id="step-2-update-component-props-to-pass-a-value-to-a-component"><a class="header" href="#step-2-update-component-props-to-pass-a-value-to-a-component">Step 2: Update component props to pass a value to a component</a></h2>
<p>Our main function had a <code>view!</code> macro template with <code>&lt;LuckyNumber /&gt;  </code> in it. We've introduced the idea of a property called <code>the_lucky_number</code> in our component's definition, so we can make use of it here.  We can add the property, with the same name parameter name we used in the component, and assign a value to it.</p>
<p><code>&lt;LuckyNumber the_lucky_number=32/&gt;  </code></p>
<p>The updated main function now looks like this:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;NiceAffirmation /&gt;  
	        &lt;LuckyNumber the_lucky_number=32 /&gt;  
        }  
    })  
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leptos-component-dynamic-content-separation"><a class="header" href="#leptos-component-dynamic-content-separation">Leptos component dynamic content separation</a></h1>
<h2 id="what-we-know-5"><a class="header" href="#what-we-know-5">What we know</a></h2>
<ul>
<li>Leptos components can accept properties and use them in their <code>view!</code> templates.</li>
</ul>
<h2 id="what-well-learn-5"><a class="header" href="#what-well-learn-5">What we'll learn</a></h2>
<ul>
<li>How Leptos' components are able to differentiate between dynamic and static content in their templates</li>
</ul>
<h2 id="the-lesson-3"><a class="header" href="#the-lesson-3">The Lesson</a></h2>
<p>In the previous lesson we were able to pass a value as an argument to a Leptos component's property. The Leptos component's signature specifies this property as a function argument. When the application starts, Leptos expands these <code>view!</code> macros and creates templates. This happens once on startup. Leptos then updates the web page's document object model (DOM) through the <code>mount_to_body</code> function call.</p>
<p>The properties passed to the Leptos component have the ability to impact how the component is rendered. In the following example, the variability is visible as text inside the Leptos component's template paragraph tags.</p>
<p>This is all well and good by you might notice something interesting when we look at the HTML.</p>
<p>Observe the following Rust code, creating and using our Leptos component.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
	        &lt;LuckyNumber the_lucky_number=12 /&gt;  
        }  
    })  
}  
  
#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number: i32) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
    }  
}</code></pre></pre>
<p>If we run <code>trunk serve</code> from our Rust project's directory, we'll get some prompts about our web server running. Opening the page up reveals the following HTML.</p>
<pre><code class="language-html">&lt;p&gt;Today's lucky number is &lt;!----&gt;12&lt;/p&gt;
</code></pre>
<p>Surprisingly, the <code>&lt;LuckyNumber the_lucky_number=12 / &gt;</code> has compeltely dissolved away. This might seem shocking, given that our main function says we're mounting the <code>LuckyNumber</code> Leptos component to the body with a call to the <code>mount_to_body</code> function. The reason for that is, a <code>view!</code> template <em>is not</em> HTML. </p>
<p>There are a few things we'll need to go over to give you a really solid explanation of how this works and how Leptos handles dynamic content.</p>
<h3 id="leptos-components-and-templates"><a class="header" href="#leptos-components-and-templates">Leptos components and templates</a></h3>
<p>Leptos components are really interesting. Their <code>view!</code> templates all distill down to HTML. We previously talked about HTML elements which come to life as an HTML tag, and when parsed in the document object model (DOM), become a DOM node. This is a fancy way of saying, when we write HTML, the browser reads it, tries to make sense of it, and creates a nested tree like structure that has hierarchy of the components.</p>
<p>Text, even though it's not an HTML element, but also be interpreted and added to the DOM. To do this, a browser creates a text node.</p>
<p>Leptos adds HTML comments to force the web browser to break what seems like contiguous text, into multipe text nodes. This is done by adding HTML comments which are encapsulated by  <code>&lt;!--</code> and <code>--&gt;</code>. </p>
<p>With this in mind, the HTML output that we saw before:</p>
<pre><code class="language-html">&lt;p&gt;Today's lucky number is &lt;!----&gt;12&lt;/p&gt;
</code></pre>
<p>Creates the following paragraph node with two child text nodes.</p>
<pre><code class="language-html">	&lt;p&gt;
		Today's lucky number is &lt;-- this is a text node
		12                      &lt;-- this is a text node
	&lt;/p&gt;
</code></pre>
<p>And we can see how it directly matches up with the <code>view!</code> template if we think about the static text string as being one text node, and the dyamic text which will come from <code>the_lucky_number</code>'s value, as another.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	&lt;p&gt;
		&quot;Today's lucky number is &quot; 
		{the_lucky_number}
	&lt;/p&gt; 
<span class="boring">}</span></code></pre></pre>
<p>Leptos' ability to retain congruency of structure between the <code>view!</code> template and the HTML it yields allows Leptos it to know exactly which text nodes or areas in the page will be dynamic, or are subject to change.</p>
<h3 id="aside-how-leptos-components-deviate-from-expected-web-behaviour-and-custom-elements"><a class="header" href="#aside-how-leptos-components-deviate-from-expected-web-behaviour-and-custom-elements">Aside: How Leptos components deviate from expected web behaviour and custom elements</a></h3>
<blockquote>
<p>Section pending ^.^</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loops-and-the-for--view-macro-tag"><a class="header" href="#loops-and-the-for--view-macro-tag">Loops and the <code>&lt;For /&gt;</code> <code>view!</code> macro tag</a></h1>
<blockquote>
<p>This article is in notes status and has not been reviewed or proofed.</p>
</blockquote>
<h2 id="what-we-know-6"><a class="header" href="#what-we-know-6">What we know</a></h2>
<ul>
<li>How to <a href="ui//getting_started/setup">setup a basic client side Leptos application</a> and run it with <code>trunk</code></li>
<li>Leptos component basics</li>
<li>Rust type system basics</li>
</ul>
<h2 id="what-well-learn-6"><a class="header" href="#what-well-learn-6">What we'll learn</a></h2>
<ul>
<li>How to store data in collections</li>
<li>Intro to the array data type</li>
<li>The difference between &amp;str and String</li>
<li>Intro to the vector data type</li>
<li>How to loop over a collection </li>
<li>How to loop over a collection with the <code>&lt;For /&gt;</code> <code>view!</code> macro tag</li>
</ul>
<h2 id="the-lesson-4"><a class="header" href="#the-lesson-4">The Lesson</a></h2>
<h3 id="setup-our-leptos-loops-application"><a class="header" href="#setup-our-leptos-loops-application">Setup our leptos-loops application</a></h3>
<p>Follow the <a href="ui/./quick_reference/client_side_app_setup.html">quick reference for setting up a client side leptos application</a>.</p>
<h3 id="adding-detail-to-our-example-with-data"><a class="header" href="#adding-detail-to-our-example-with-data">Adding detail to our example with data</a></h3>
<p>Let's make our example a bit more fun by listing off some great cat names.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| view! { cx,  
        &lt;h1&gt;&quot;Great cat names&quot;&lt;/h1&gt;  
        &lt;ul&gt;  
            &lt;li&gt;&quot;Beans&quot;&lt;/li&gt;  
            &lt;li&gt;&quot;Basil&quot;&lt;/li&gt;  
            &lt;li&gt;&quot;Oliver&quot;&lt;/li&gt;  
        &lt;/ul&gt;  
    })
}</code></pre></pre>
<h3 id="collections"><a class="header" href="#collections">Collections</a></h3>
<p>We previously listed off our cat names and hard coded them into a template.  It would be better to pull that data out into a <code>data structure</code> which we can then do work over (for each item in the stucture) to generate the list items. I say <code>better</code> because we're assuming that these items are going to change. In this lesson we're imagining that the list of great cat names will grow over time. It is completely reasonable to write out a list and be literal if you don't expect things to change.</p>
<h4 id="arrays"><a class="header" href="#arrays">Arrays</a></h4>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/primitive.array.html">Rust standard library documentation</a></p>
</blockquote>
<p>One of the most basic data structures that exists in Rust is an Array. It is a group of the same type of data, with a set quantity or storage/size. We can assign an array to a variable by wrapping a set of the same types of data in square brackets, separating each item with a comma.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cat_names = [&quot;Beans&quot;, &quot;Basil&quot;, &quot;Oliver&quot;];
<span class="boring">}</span></code></pre></pre>
<p>Rust will infer (figure out) that the data type of <code>cat_names</code> is <code>[&amp;str; 3]</code> (the items in the array are <code>&amp;str</code> and there are <code>3</code> of the). The type signature for arrays uses square brackets, encapsulating the the type of the items in teh array, followed by a semicolon, and the size of the array or quantity of items in the array.</p>
<p>We could have written the following as well:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cat_names: [&amp;str;3] = [&quot;Beans&quot;, &quot;Basil&quot;, &quot;Oliver&quot;];
<span class="boring">}</span></code></pre></pre>
<h5 id="fixed-length"><a class="header" href="#fixed-length">Fixed Length</a></h5>
<p>An important thing to note is that arrays are of immutable length. You can not add an item to an array because Rust has blocked off a space in memory for the array. There is no extra space to store another item. This is part of how Rust maintains memory safety. It won't allow you to just dump your data into the spot after an array to make a &quot;bigger array&quot;. </p>
<h5 id="forced-type"><a class="header" href="#forced-type">Forced Type</a></h5>
<p>The type of items needs to be the same for each item in an array. This is so that Rust knows how much memory to allocate to store the number of items.  You can not do the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cat_names: [&amp;str;4] = [&quot;Beans&quot;, &quot;Basil&quot;, &quot;Oliver&quot;];
<span class="boring">}</span></code></pre></pre>
<p>Rust's compiler will complain about the value you're assigning being <code>[&amp;str;3]</code>, because there are three items, but <code>let cat_names: [&amp;str;4] = </code> will try to allocate extra space. At that point Rust won't know what is actually in that fourth space. If it can't guarantee what's there, Rust's compiler won't let the application compile. As disciplined as we all think we are, it's easy to miss checking the data at that location in memory when we use it. You might think there's a <code>&amp;str</code> there but who knows! There are better ways to handle variable length sequential groups of same typed data. But, if you did want to use an Array, you could specify an option type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cat_names: [Option&lt;&amp;str&gt;;4] = [
	Some(&quot;Beans&quot;), 
	Some(&quot;Basil&quot;), 
	Some(&quot;Oliver&quot;),
	None
];
<span class="boring">}</span></code></pre></pre>
<p>It's important to note that there are still 4 items, and each item is of the same type.</p>
<h5 id="str"><a class="header" href="#str">&amp;str</a></h5>
<p>We wrote &quot;Beans&quot;, &quot;Basil&quot;, and &quot;Oliver.&quot; All three of these would often be referred to as &quot;string values&quot; in other programming languages. They're a series of &quot;characters.&quot; Oh! That sounds familiar. They're a series... they're a collection of the same type. It sounds a lot like an array doesn't it?! That's because they are! But they're not characters in a way that you might think.</p>
<p>Let's look at what these individual values actually are to get a complete understanding of what's going on here.</p>
<p>We know that at the end of the day, everything in a program has to be turned into a numerical value. If you think back to being a kid (or maybe you still are ^.^) you may have written coded messages, replacing letters with numbers, A becomes 1, B becomes 2, C becomes 3, and so on. Perhaps &quot;Beans&quot; is a series of characters that become a series of numerical values. There are 5 characters, so maybe &quot;Beans&quot; is actually an array of 5 x 8bit integers, with the type signature <code>[u8;5]</code>.</p>
<p>Well it turns out that there is an older system called the <a href="https://www.w3schools.com/charsets/ref_html_ascii.asp">ASCII character set</a> that works like this. If we were using ASCII we could represent Beans as an array of 7bit integers. The ASCII character set contains 128 characters. 7 binary bits allows us to create values of 0 ( 0000000 ) to 128 (1111111).</p>
<pre><code>B,  E,  A,  N,  S
66, 69, 65, 78, 83
</code></pre>
<p>ASCII is pretty limited though. What if I wanted to put an emoji of beans as the name! 🫘 How do I represent that in ASCII. I can't. This makes me sad. Thankfully, there's a system called Unicode that allows us to extend the available &quot;character set&quot;. </p>
<p>In Rust, all text is required to be valid Unicode or <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a>. Rust uses <code>str</code> as a data structure to hold these UTF-8 &quot;characters.&quot; I used quotes there because Unicode is more like a virtual structure of characters floating in space and characters are &quot;code points&quot; in thst cloud of expressive units. </p>
<p>You can think of <code>str</code> as <code>str</code>ing. The <code>str</code> hides the complexity of unicode so that you can just write your program, while still being able to use all 1,112,064 valid character points.</p>
<p>In summary <code>str</code> is a fixed length data strcture of code points. It is immutable. When we write <code>&amp;str</code> we're referring to a <code>string slice</code> in Rust, which is a reference to a set of &quot;characters,&quot; but again, the characters are code points. ^.^</p>
<h4 id="vectors"><a class="header" href="#vectors">Vectors</a></h4>
<blockquote>
<p><a href="https://doc.rust-lang.org/std/vec/index.html">Rust standard library documention</a></p>
</blockquote>
<p>Vectors are like arrays in that they are a sequential group of the same data type, but differ in that they are of variable length. You can create a new vector with the <code>Vec</code> struct's <code>new</code> static method.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cat_names = Vec::new();
<span class="boring">}</span></code></pre></pre>
<p>At this point there is no data type asigned to the Vector. We can specify the type in advance.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cat_names: Vec&lt;&amp;str&gt; = Vec::new();
<span class="boring">}</span></code></pre></pre>
<p>Rust will infer the type if we use the <code>from</code> static method using an array.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cat_names = Vec::from([&quot;Beans&quot;, &quot;Basil&quot;, &quot;Oliver&quot;]);
<span class="boring">}</span></code></pre></pre>
<p>Or we can let Rust infer the type. It will pick up the type of the first item stored in the vector and use that as the requirement for all future additions. If you want to edit a vector you'll need to make it mutable though.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut cat_names= Vec::new();  // no internal type
cat_names.push(&quot;Beans&quot;);        // now the internal type is &amp;str
cat_names.push(&quot;Basil&quot;);  
cat_names.push(&quot;Oliver&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Vectors can also be made using the handy <code>vec!</code> macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cat_names= vec![&quot;Beans&quot;,&quot;Basil&quot;, &quot;Oliver&quot;];
<span class="boring">}</span></code></pre></pre>
<h3 id="updating-our-html-to-use-collections"><a class="header" href="#updating-our-html-to-use-collections">Updating our HTML to use collections</a></h3>
<p>Let's update our example application to store our cat names in a <code>Vec</code> using the <code>vec!</code> macro.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    
    let cat_names = vec![&quot;Beans&quot;,&quot;Basil&quot;, &quot;Oliver&quot;];
    
    mount_to_body(|cx| view! { cx,  
        &lt;h1&gt;&quot;Great cat names&quot;&lt;/h1&gt;  
        &lt;ul&gt;  
            
        &lt;/ul&gt;  
    })
    
}</code></pre></pre>
<p>We need to fill in that gap in the unordered list tags <code>&lt;ul&gt;...&lt;/ul&gt;</code> with our list items.</p>
<p>Let's imagine that there's a function called <code>list_names</code> which will give us a Vector of Views. To make views, we need a context, and to list names we actually need the names. This tells us our two arguments to the function. We need to wrap this in curly braces so that it gets executed.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {  
  
    let cat_names= vec![  
        &quot;Beans&quot;,  
        &quot;Basil&quot;,  
        &quot;Oliver&quot;  
    ];  
  
    mount_to_body(|cx| view! { cx,  
        &lt;h1&gt;&quot;Great cat names&quot;&lt;/h1&gt;  
        &lt;ul&gt;  
            {list_names(cx,cat_names)}  
        &lt;/ul&gt;  
    })}</code></pre></pre>
<p>Now we need to write the function. I like to start with the signature. Let's make sure we know what it's accepting and what we want to get out of it. The body of the function is where we connect the dots.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn list_names(cx: Scope, cat_names: Vec&lt;&amp;str&gt;) -&gt; Vec&lt;View&gt; {
	// STUFF HERE
}
<span class="boring">}</span></code></pre></pre>
<p>If we want to do something to a Vector in Rust we'll need to turn it into an iterator. We can call the method <code>into_iter()</code> to turn our current evaluated value into that special iterator.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	cat_names
		.into_iter()
<span class="boring">}</span></code></pre></pre>
<p>Next we want to do something to each item. We want to change each <code>&amp;str</code> into a view. Map is a method that can be called on an interator that will apply to each item. It accepts a closure which operates on each item. Its a function in a mathematical sense!</p>
<p>Our first step is turning each one of these into a view.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cat_names  
    .into_iter()  
    .map(  
        move |name| view!{cx, &lt;li&gt;{name}&lt;/li&gt;}
	)
<span class="boring">}</span></code></pre></pre>
<p>Note that if we have a single line of code, we don't need to add curley braces to define the body of a closure. Move is necesary because <code>&amp;str</code> values don't support copy. If we're using name into the view! macro, it will love out of its iterator.</p>
<p>The second step is turning these into an actual <code>View</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cat_names  
    .into_iter()  
    .map(  
        move |name| view!{cx, &lt;li&gt;{name}&lt;/li&gt;}  
	)
	.map(  
	    move |li| li.into_view(cx)  
	)
<span class="boring">}</span></code></pre></pre>
<p>We now have an iterator with Views that we need to convert into a Vector of Views. We can call <code>collect</code> on the iterator to turn it back into a &quot;collection&quot; which is our Vector.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn list_names(cx: Scope, cat_names: Vec&lt;&amp;str&gt;) -&gt; Vec&lt;View&gt; {  
    cat_names  
        .into_iter()  
        .map(  
            move |name| view!{cx, &lt;li&gt;{name}&lt;/li&gt;}  
        )
		.map(  
            move |li| li.into_view(cx)  
        )        
        .collect()  
}
<span class="boring">}</span></code></pre></pre>
<p>We don't have a semicolon at the end of <code>collect()</code>. That makes the result of <code>collect()</code> the final statement/expression and the returned value of the function.</p>
<p>At this point we're going to get some issues with lifetimes. Rust will complain because we're passing a Vector of references into a function, and getting back a Vector of Views that used the reference. Rust can't guarantee that the references to those string slices will live as long as the Vector of Views that they generate through this function.</p>
<p>We can specify a static lifetime for the string slices which is the same lifetime as the Views, solving our problem.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn list_names(cx: Scope, cat_names: Vec&lt;&amp;'static str&gt;) -&gt; Vec&lt;View&gt; {  
    cat_names  
        .into_iter()  
        .map(  
            move |name| view!{cx, &lt;li&gt;{name.clone()}&lt;/li&gt;}  
        )        
        .map(  
            move|li| li.into_view(cx)  
        )        
        .collect()  
}
<span class="boring">}</span></code></pre></pre>
<p>Here's what our final application looks:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
  
    let cat_names= vec![  
        &quot;Beans&quot;,  
        &quot;Basil&quot;,  
        &quot;Oliver&quot;
    ];  
  
    mount_to_body(|cx| view! { cx,  
        &lt;h1&gt;&quot;Great cat names&quot;&lt;/h1&gt;  
        &lt;ul&gt;  
            {list_names(cx,cat_names)}  
        &lt;/ul&gt;  
    })}  
  
fn list_names(cx: Scope, cat_names: Vec&lt;&amp;'static str&gt;) -&gt; Vec&lt;View&gt; {  
    cat_names  
        .into_iter()  
        .map(  
            move |name| view!{cx, &lt;li&gt;{name.clone()}&lt;/li&gt;}  
        )        
        .map(  
            move|li| li.into_view(cx)  
        )       
         .collect()  
}</code></pre></pre>
<h4 id="what-if-static-lifetimes-arent-an-option"><a class="header" href="#what-if-static-lifetimes-arent-an-option">What if static lifetimes aren't an option?</a></h4>
<p>If you can't use static lifetimes, you can convert the <code>&amp;str</code> (string slices) into owned strings, of type <code>String</code>. </p>
<p>I used three different approaches to converting a string slice <code>&amp;str</code> into a <code>String</code>. You can call <code>to_string()</code> on the slice's value, you can call a method on the String struct, or you can call <code>into</code>. </p>
<p>Then we need to update the list_names parameter type from <code>Vec&lt;&amp;'static str&gt;</code>  to <code>Vec&lt;String&gt;</code></p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
  
    let cat_names = vec![  
        &quot;Beans&quot;.to_string(),  
        String::from(&quot;Basil&quot;),  
        &quot;Oliver&quot;.into()  
    ];  
  
    mount_to_body(|cx| view! { cx,  
        &lt;h1&gt;&quot;Great cat names&quot;&lt;/h1&gt;  
        &lt;ul&gt;  
            {list_names(cx,cat_names)}  
        &lt;/ul&gt;  
    })}  
  
fn list_names(cx: Scope, cat_names: Vec&lt;String&gt;) -&gt; Vec&lt;View&gt; {  
    cat_names  
        .into_iter()  
        .map(  
            move |name| view!{cx, &lt;li&gt;{name.clone()}&lt;/li&gt;}  
        )        
        .map(  
            move|li| li.into_view(cx)  
        )        
        .collect()  
}</code></pre></pre>
<h4 id="inline-closures"><a class="header" href="#inline-closures">Inline closures</a></h4>
<p>In the above example we used a function to generate the Vector of Views. Keep in mind that this is happening in a closure that is being passed to the <code>mount_to_body</code> function. The scope variable <code>cx</code> does not exist outside of this! As a result, we can not create closures outside of the mount_to_body closure. If we crested an app component we would be in a state where the scope exists. It would open up more clean syntax.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    let cat_names = vec![  
        &quot;Beans&quot;,  
        &quot;Basil&quot;,  
        &quot;Oliver&quot;  
    ];  
  
    mount_to_body(|cx| view! { cx,  
        &lt;ListNames cat_names/&gt;  
    })}  
  
#[component]  
fn ListNames(cx: Scope, cat_names: Vec&lt;&amp;'static str&gt;) -&gt; impl IntoView {  
  
    let list_items: Vec&lt;_&gt; = cat_names  
        .into_iter()  
        .map( move |name| view!{cx, &lt;li&gt;{name}&lt;/li&gt;} )  
        .collect();  
  
    view! {cx,  
        &lt;h1&gt;&quot;Great cat names&quot;&lt;/h1&gt;  
        &lt;ul&gt;  
            {list_items}  
        &lt;/ul&gt;  
    }
}</code></pre></pre>
<blockquote>
<p>Note, you can not inline the <code>cat_names.into_iter().etc</code> in place of <code>{list_items}</code> in the view macro because of how macros are processed. The variables need to be evaluated in advace in this case.</p>
</blockquote>
<p>A subtle but important difference in the above example is that we have a Vector of <code>Leptos::HtmlElement</code>s. We don't have to concretely specify their type, which allows us to set the type of list_items to <code>Vec&lt;_&gt;</code> meaning <code>Vector of...it doesn't matter because we never need to check the concrete type</code>. When we pass the <code>Vec&lt;HtmlElement&lt;?&gt;</code> into the <code>view!</code> macro via <code>{list_items}</code>, the macro checks against HtmlElements being valid values. We can skip declaration of th e concrete types in this situation.</p>
<p>By contrast we needed a concrete type for a function definitions return type, which is why we used <code>Vec&lt;View&gt;</code> earlier. It wouldn't be possible for us to say <code>&lt;Vec&lt;HtmlElement&lt;?&gt;&gt;</code>.</p>
<h4 id="tradeoffs-with-using-iterators-without-keys"><a class="header" href="#tradeoffs-with-using-iterators-without-keys">Tradeoffs with using iterators without keys</a></h4>
<p>This is a fine approach for simple applications, but it starts to break down when you're using signals and concerned about performance. If cat_names was a signal (a read signal which updates views when it is updated), we'd end up re-rendering the whole list of names. This isn't ideal.</p>
<h3 id="using-the-for--view-macro-tag"><a class="header" href="#using-the-for--view-macro-tag">Using the <code>&lt;For /&gt;</code> <code>view!</code> macro tag</a></h3>
<p>The <code>view!</code> macro has a helper called <code>&lt;For /&gt;</code> that will do a lot of this leg work for us. The benfits of using <code>&lt;For &gt;</code> is that Leptos will associate a key with each item output. The key allows Leptos to target granular updates to avoid rerendering the whole list.</p>
<p>There are three properties that we must assign for the <code>&lt;For /&gt;</code> tag.</p>
<ol>
<li>each: A closure that returns the collection. The collection must support the ability to be converted into an interable. Vectors and Arrays work perfectly fine here.</li>
<li>key: A closure that will return a value that can be used as an identifier for a given item</li>
<li>view: A closure that will return the view for a given item.</li>
</ol>
<p>Ownership can be tricky with <code>&lt;For /&gt;</code>. We'll need to clone the names for the iteration so that we can guarantee that the references don't go away. We need to do something similar for the key closure. We need to clone the returned value. If we didn't, the value would get dropped. </p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    let cat_names = vec![  
        &quot;Beans&quot;,  
        &quot;Basil&quot;,  
        &quot;Oliver&quot;  
    ];  
  
    mount_to_body(|cx| view! { cx,  
        &lt;ListNames cat_names/&gt;  
    })
}  
    
#[component]  
fn ListNames(cx: Scope, cat_names: Vec&lt;&amp;'static str&gt;) -&gt; impl IntoView {  
  
    view! {cx,  
        &lt;h1&gt;&quot;Great cat names&quot;&lt;/h1&gt;  
        &lt;For  
            each={ move || cat_names.clone()}  
            key={ |name| name.clone()}  
            view={ 
	            move |name| {  
	                view! {  
	                    cx,  
	                    &lt;li&gt;{name}&lt;/li&gt;  
	                }            
				}     
			}   
		/&gt;    
	}
}</code></pre></pre>
<h4 id="with-more-complex-data-stuctures"><a class="header" href="#with-more-complex-data-stuctures">With more complex data stuctures</a></h4>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
#[derive(Clone)]  
struct CatName {  
    name: String,  
    rating: u8,  
}  
  
fn main() {  
    let cat_names = vec![  
        CatName { name: &quot;Beans&quot;.to_string(), rating: 1 },  
        CatName { name: &quot;Basil&quot;.to_string(), rating: 2 },  
        CatName { name: &quot;Oliver&quot;.to_string(), rating: 3 },  
    ];  
  
    mount_to_body(|cx| view! { cx,  
        &lt;ListNames cat_names/&gt;  
    })
}  
  
#[component]  
fn ListNames(cx: Scope, cat_names: Vec&lt;CatName&gt;) -&gt; impl IntoView {  
    view! {cx,  
        &lt;h1&gt;&quot;Great cat names&quot;&lt;/h1&gt;  
        &lt;For  
            each={ move || cat_names.clone()}  
            key={ |cat_name| cat_name.rating}  
            view={  
               move |cat_name| {  
                   view! {  
                       cx,  
                       &lt;li id={cat_name.rating}&gt;
	                       {cat_name.name}
					   &lt;/li&gt;  
                   }    
			   }
			} 
		 /&gt;   
	 }
 }</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conditional-display-and-the-show-view-macro-tag"><a class="header" href="#conditional-display-and-the-show-view-macro-tag">Conditional display and the <code>&lt;Show&gt;</code> <code>view!</code> macro tag</a></h1>
<blockquote>
<p>This article is in notes status and has not been reviewed or proofed.</p>
</blockquote>
<h2 id="what-we-know-7"><a class="header" href="#what-we-know-7">What we know</a></h2>
<ul>
<li>How to <a href="ui//getting_started/setup">setup a basic client side Leptos application</a> and run it with <code>trunk</code></li>
<li>Leptos component basics</li>
</ul>
<h2 id="what-well-learn-7"><a class="header" href="#what-well-learn-7">What we'll learn</a></h2>
<ul>
<li>Techniques for conditionally displaying data</li>
<li>Using the <code>&lt;Show&gt;</code> <code>view!</code> macro tag </li>
</ul>
<h2 id="the-lesson-5"><a class="header" href="#the-lesson-5">The Lesson</a></h2>
<h3 id="setup-our-leptos-loops-application-1"><a class="header" href="#setup-our-leptos-loops-application-1">Setup our leptos-loops application</a></h3>
<p>Follow the <a href="ui/./quick_reference/client_side_app_setup.html">quick reference for setting up a client side leptos application</a>.</p>
<h3 id="the-idea-of-conditionals-and-control-flow"><a class="header" href="#the-idea-of-conditionals-and-control-flow">The idea of conditionals and control flow</a></h3>
<p>Programs take in data, process it or work over it, and yield a result. This result may be a change to the data which is returned, or some action impacting the world outside of the application like writing a file, sending an email, etc.</p>
<p>It's common to have branches in applications where the result of running the application may change depending on its input or the conditions in which it is run. </p>
<blockquote>
<p><strong>(Aside) Programs as Functions:</strong> I say application but this applies to funtions as well. Applications are untimately a large function with complex inputs and outputs. The idea of <code>fn main()</code> hints at the truth behind the fractal nature (repetition of a pattern at difference scales as you look into something) of programs as functions.</p>
</blockquote>
<p>To help solidify your understading, you can think of these two situtions in the context of these examples:</p>
<ol>
<li>Linear: Like a regular book or story based video game. You read it or play it once and the result is always the same. It is consistent.</li>
<li>Branching: Like a choose your own adventure book or role playing video game where the actions you take dictate the outcome.</li>
</ol>
<p>As you can imagine, having variability of output or result based on these conditions, with the ability to switch paths, can add complexity in your application. The term <a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">Cyclomatic complexity</a> refers specifically to that. We try to keep the number of branches as low as possible. We do this because functions with linear behaviours of input to output are easier to reason about, are more predictable, and as a result less prone to bugs.</p>
<p>In this lesson we will be specifically looking at how to create branches in our code, and as a result, in our UI. </p>
<h3 id="if-statements"><a class="header" href="#if-statements">If statements</a></h3>
<p>Rust provides a variety of control flow syntax to tell the compiler which parts of our code should be used, or which path to take through it as it runs. The most basic syntax for this uses the keyworld <code>if</code> followed by a statement that evaluates to a boolean value, which is true or false.</p>
<p>The syntax is very simple:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let loves_cats = true;  

if loves_cats {  
    leptos::log!(&quot;Hooray&quot;);
}
<span class="boring">}</span></code></pre></pre>
<p>The pattern is <code>if</code> followed by a condition which we call a predicate. In this example it is <code>loves_cats</code> and then a scope which will run &quot;predicated&quot; on (depending on) the condition being true.</p>
<h3 id="conditional-values-in-the-view-macro"><a class="header" href="#conditional-values-in-the-view-macro">Conditional values in the <code>view!</code> macro</a></h3>
<p>Let's see if we can use this in our <code>view!</code> macro to conditionally display some text. We want our message to print out if a condition is true. You can imagine that your applications conditions are more dynamic and interesting. We're hard coding the condition here so that the example is consistent and easy to follow.</p>
<p>We want to do something like this, but we only want the message &quot;Hooray. They love cats!&quot; to print if they actually do.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &quot;Hooray. They love cats!&quot;  
        }    
	})
}</code></pre></pre>
<p>We'll refactor this a bit, moving the string out of there into a variable.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        let message = &quot;Hooray. They love cats!&quot;;
        view! {  
            cx,  
            {message}  
        }    
	})
}</code></pre></pre>
<p>But we want that to be changed on a condition. We want the message to be empty, but if they love cats, then it should contain our &quot;Hooray. They love cats!&quot; text.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        
        let loves_cats = true;
        
        let message = &quot;&quot;;
        
        if loves_cats {
	        let message = &quot;Hooray. They love cats!&quot;;
        }
        
        view! {  
            cx,  
            {message}  
        }    
	})
}</code></pre></pre>
<p>This looks like it shoul work, but it doesn't. </p>
<p>Rust's compiler is smart. It's very smart. It wants to make sure that we don't leave memory allocated that isn't being used. To make sure that unused variables are freed up safely it follows a rule. </p>
<blockquote>
<p>Any variables used in a scope (encapsulasted with curly braces <code>{</code>...<code>}</code>) will have their memory freed (Rust's compiler calls this Dropping) at the end of the scope. Variables used in the scope are those moved into it or allocated/defined in it. The only values left are those written as the last statement in the scope, which is the evaluated value of the whole scope/code block.</p>
</blockquote>
<p>Here's what's happening in secret.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let message = &quot;&quot;;
        
if loves_cats {
	// Let's assign message to a value
	let message = &quot;Hooray. They love cats!&quot;;
	// We're at the end of the scope. 
	// Let's clean up `message`.
}
<span class="boring">}</span></code></pre></pre>
<p>We can solve this problem by making message mutable, adding the <code>mut</code> keyword after <code>let</code>.</p>
<p>We can then reassign message through the mutable reference that gets moved into the <code>if</code> statement's scope. Not that it's important that message be assigned an empty string value so that it is initialized.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// make message mutable
let mut message = &quot;&quot;;
        
if loves_cats {
	// A mutable reference is used behind the scenes
	// and `moved` into this scope. 
	message = &quot;Hooray. They love cats!&quot;;
	// We're at the end of the scope. 
	// The mutable reference is cleaned up
	// The owned value of message was never 
	// actually moved, and still exists outside 
	// of the `if`
}
<span class="boring">}</span></code></pre></pre>
<p>We now have a conditional that works, displaying a message if the predicate is true in our UI.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
  
        let loves_cats = true;  
        let mut message = &quot;&quot;;  
        if loves_cats {  
            message = &quot;Hooray. They love cats!&quot;;  
        }  
  
        view! {  
            cx,  
            {message}  
        }
	})
}</code></pre></pre>
<h3 id="if-in-the-view-macro"><a class="header" href="#if-in-the-view-macro">If in the <code>view!</code> macro</a></h3>
<p>What if we wanted to bring this inline, in our <code>view!</code> macro?</p>
<p>Here's where things get interesting.</p>
<p>There is an interesting little trick here with Rust's <code>if</code> statements. If we recall,  Rust is an expression language and expressions evaluate to the last statement. You can think of it as the &quot;final word.&quot;</p>
<p>In the example below, the block of code for the <code>if</code> statement evaluates to a <a href="https://doc.rust-lang.org/std/primitive.unit.html">unit type</a>. It's almost like Rust's take on null, written as <code>()</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let loves_cats = true;  

if loves_cats {  
    let message = &quot;Hooray. They love cats!&quot;; 
    //                                     ^
    // semicolon means this isn't 
    // the last thing left. It has ended
    // The final word here has nothing,
    // which represents as the () or unit type
}
<span class="boring">}</span></code></pre></pre>
<p>So really, the whole if statement ends up evaluating to a unit type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if loves_cats {  
    let message = &quot;Hooray. They love cats!&quot;; 
    // Invisible unit type gets added here 
    // ()
}
<span class="boring">}</span></code></pre></pre>
<p>If we drop the semicolon, it will evaluate to a <code>&amp;str</code>, the last expression in the scope!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if loves_cats {  
    &quot;Hooray. They love cats!&quot; 
}
<span class="boring">}</span></code></pre></pre>
<p>Let's replace our message variable with the inline <code>if</code> conditional statement</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
  
        view! {  
            cx,  
            {
				if loves_cats {  
                    &quot;Hooray. They love cats!&quot;  
                }  
            }
		} 
	})
}</code></pre></pre>
<p>Now this looks like it should work! But it doesn't, and there's good reason for it. The <code>if</code> statement evaluates to a <code>&amp;str</code> (string slice) value if it is <code>true</code>. But what about if it's <code>false</code>? In this case, it would be a unit type and that isn't valid input for the <code>view!</code> macro.</p>
<p>We can add a <code>else</code> block with an empty string slice to solve this problem.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
  
        view! {  
            cx,  
            {
				if loves_cats {  
                    &quot;Hooray. They love cats!&quot;  
                } else {
	                &quot;&quot;
                }
            }
		} 
	})
}</code></pre></pre>
<p>You can also replace this with a match statement for a bit more clarity.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
  
        let loves_cats = true;  
        view! {  
            cx,  
            {               
	             match loves_cats {  
                    true  =&gt; &quot;Hooray. They love cats!&quot;,  
                    false =&gt; &quot;&quot;  
                }  
            }   
		}    
	})
}</code></pre></pre>
<h3 id="the-show-tag-in-the-view-macro"><a class="header" href="#the-show-tag-in-the-view-macro">The <code>&lt;Show&gt;</code> tag in the <code>view!</code> macro</a></h3>
<p>Leptos provides a conditional tag to make this a bit more straight forward. The show tag also offers some optimizations. It will not processes branches that are already active if no changes have been made. Raw <code>if</code> statements will evaluate their their predicate and evaluate their success scopes each time. More details can be found in the <a href="https://docs.rs/leptos/latest/leptos/fn.Show.html">official documentation</a>.</p>
<p>The <code>&lt;Show&gt;</code> tag requires two properties, both of which are closures.</p>
<ul>
<li>when: A cosure for the predicate. It will be run to see if it is true or not. If true, the children of the <code>&lt;Show&gt;</code> tag will be printed.</li>
<li>fallback: A closure that returns what to display if the predicate is false. This is like the else branch.</li>
</ul>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
  
        let loves_cats = true;  
        view! {  
            cx,  
            &lt;Show  
                when=move || loves_cats  
                fallback=|_| &quot;Give it time&quot;  
            &gt;  
                &quot;Hooray. They love cats!&quot;  
            &lt;/Show&gt;  
        }    
	})
}</code></pre></pre>
<p>It's important to note that this can also be written with curley braces in the closures to make them more clear. Here's an example for the sake of familiarity.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;Show  
	when=move || { loves_cats }  
	fallback=|_| { &quot;Give it time&quot; }
&gt; 
	&quot;Hooray. They love cats!&quot;  
&lt;/Show&gt;  
<span class="boring">}</span></code></pre></pre>
<p>The fallback will send a context along with it, allowing you to return views.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
  
        let loves_cats = true;  
        view! {  
            cx,  
            &lt;Show  
                when=move || loves_cats  
                fallback=|cx| view!{cx,&quot;Give it time&quot;}  
            &gt;
				&quot;Hooray. They love cats!&quot;  
            &lt;/Show&gt;  
        }    
	})
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tables-and-data-sets"><a class="header" href="#tables-and-data-sets">Tables and data sets</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="witnessing-events"><a class="header" href="#witnessing-events">Witnessing events</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leptos-components-updating-from-events"><a class="header" href="#leptos-components-updating-from-events">Leptos components updating from events</a></h1>
<h2 id="what-we-know-8"><a class="header" href="#what-we-know-8">What we know</a></h2>
<ul>
<li>Leptos components are templates that can be added to a web page's document object model DOM as nodes, with separate text nodes for dynamic data used in text strings.</li>
<li>Leptos components can have fuctions run in response to events on a given component.</li>
<li><code>wasm-bindgen</code> and other supporting crates work as bridges between our Rust code and the browser's JavaScript runtime.</li>
</ul>
<h2 id="what-well-learn-8"><a class="header" href="#what-well-learn-8">What we'll learn</a></h2>
<ul>
<li>Updating the DOM in response to events.</li>
</ul>
<h2 id="the-lesson-6"><a class="header" href="#the-lesson-6">The Lesson</a></h2>
<p>In our previous example we created a silly Leptos component that displays some text and has a button that, when clicked, echoes a number to the console.</p>
<p>We'll take this example and and instead of echoing 42 the console, we'll replace the lucky number with it.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;LuckyNumberCounter the_lucky_number=12 /&gt;  
        }  
    })  
}

#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number: i32) -&gt; Element {
	let whisper_in_the_console = |_|{  
	    web_sys::console::log_1(&amp;42.into());
	};  
	view!{  
	    cx,  
	    &lt;div&gt;  
	        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
	        &lt;button on:click=whisper_in_the_console &gt;
		        &quot;Your Secret Lucky Number&quot;
			&lt;/button&gt;  
	    &lt;/div&gt;  
	}
}</code></pre></pre>
<p>First, let's adjust the names of some of the event callback and put a placeholder into the event handler (or callback) body.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number: i32) -&gt; Element {
	let update_the_number = |_|{  
	    // This functionality is unknown.
	};  
	view!{  
	    cx,  
	    &lt;div&gt;  
	        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
	        &lt;button on:click=update_the_number &gt;
		        &quot;I need a more lucky number&quot;
			&lt;/button&gt;  
	    &lt;/div&gt;  
	}
}
<span class="boring">}</span></code></pre></pre>
<p>We know from previous lessons that Leptos component templates are setup statically when Leptos starts up. Given that this is the case we may ask ourselves, how can we have dynamic content if the template is static? </p>
<p>The secret to solving this problem involves combining two features of Leptos, one which we've seen before and one which is new.</p>
<ol>
<li>How Leptos separates static and dynamic content</li>
<li>Signals which can be converted into data</li>
</ol>
<h3 id="1-separation-of-static-and-dynamic-template-components"><a class="header" href="#1-separation-of-static-and-dynamic-template-components">1) Separation of static and dynamic template components</a></h3>
<p>We saw from the previous example that Leptos differentiates parts of our template from components that are variable. By doing this, it can zip together data that changes with the static template that does not change.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;p&gt;
	&quot;Today's lucky number is &quot; {the_lucky_number}
&lt;/p&gt;  
<span class="boring">}</span></code></pre></pre>
<p>The above could be interpreted as follows:</p>
<pre><code>[STATIC DATA] {DYNAMIC DATA} [STATC DATA]
</code></pre>
<pre><code>[&lt;p&gt;&quot;Today's lucky number is &quot;]  {the_lucky_number} [&lt;/p&gt;]
</code></pre>
<p>By doing this Leptos can reuse the template while leaving a holes, like fields in a form, for variable data.</p>
<h3 id="2-signals"><a class="header" href="#2-signals">2) Signals</a></h3>
<p>The problem with our Leptos component is that <code>the_lucky_number</code> is a variable who's value is defined outside of its component template. It's value is provided when the whole system starts up and the component is mounted to the body as shown in the &quot;<code>fn main()</code>&quot; main function.</p>
<p>Unfortunately our variable <code>the_lucky_number</code> doesn't have an opportunity to be updated or changed. It's been used in our template and it has been consumed. Rust has some very intereting rules about data. </p>
<h4 id="the-idea-of-movement-and-scope"><a class="header" href="#the-idea-of-movement-and-scope">The idea of movement and scope</a></h4>
<p>In a lot of programming languages, you can pass data into a function and then also use it elsewhere. In Rust if you pass data into a function it's considered to have been moved into the function. It has left the scope, or the space, which you were operating.</p>
<p>For example, consider a time where I gave my friend a sandwich and asked them to paint a picture of it for me—it was a beautiful sandwich. If I gave the sandwich to my friend, I no longer have it. It's been <em>moved</em> into their hands. They may give it back to me, but until then, I won't have it. If you're working in Rust and see statements like, &quot;such and such has moved,&quot; this is what that means.</p>
<p>If Rust can make a copy of the data, it'll do so to get around the issue of moved values, but that only happens with simple data types like numbers. There are exceptions and a lot to explain with what is called the copy trait, but we won't get into that here. The idea of 'copy' is important to how Leptos allows dynamic content though.</p>
<h3 id="knowing-what-we-are-actually-moving"><a class="header" href="#knowing-what-we-are-actually-moving">Knowing what we are actually moving</a></h3>
<p>Let's go back to this sandwich example. Perhaps I don't want to relinquish my sandwich. I could provide a reference to it and my friend could look at it to make the painting. Though, they wouldn't be allowed to touch it. They are only allowed to look at it. In this case, I'm not losing my sandwich, but Rust will prevent me from changing it while someone is referencing it. Rust won't allow me to take a bit of my sandwich while I told my friend they could look at it to make the painting. Independent of how hungry I am. I could actually set up a plinth, place my sandwich on top, and allow a whole class of artisans to paint my sandwich. </p>
<p>Rust also allows me to loan out my sandwich by providing a mutable reference, but if I do that, I can't touch it, and no one else is allowed to reference it. It would be as if I told my friend, &quot;You can paint my sandwich and organize the lettuice and tomato so that it makes a nice composition.&quot; No one could safely paint that sandwich because my friend might still be moving parts of it around.</p>
<p>References in rust are achieved by adding an ampersand before a value. <code>42</code> is a number. <code>&amp;42</code> is a reference to that number. We can dereference or follow the reference to the original by placing an asterisk before a variable containing a reference. We'll expand on this later and explain how you references, and when to use them.</p>
<p>To summarize, the rules are:</p>
<ul>
<li>We can move an owned value (the sandwich)</li>
<li>We can create and move one or more references to the sandwich</li>
<li>We can create one single mutable reference, but we can not also have regular references if we do</li>
</ul>
<h3 id="the-borrow-checker"><a class="header" href="#the-borrow-checker">The borrow checker</a></h3>
<p>The above two concepts are key parts of what we call the Rust borrow checker. The purpose of the borrow checker is to make sure that our system (application) has predictable access to data. To do this, it tracks where we move things and how we reference them, to guarantee that we haven't inadvertantly written something stupid that will break our program or create secrity vulnerabilities. And trust me, we will write things like that. The borrow checker is your friend and asks you to do your best work. You will learn to appreciate how amazing it is in time.</p>
<p>Now that we know this, we can see how what felt like a simple problem to solve is actually pretty complicated. If we move a value into a component, it's gone. We can't update a value that doesn't exist as a result of some event. It might take some time to wrap your mind around this idea. It'll feel uncomfortable at first.</p>
<h3 id="leptos-solution"><a class="header" href="#leptos-solution">Leptos' solution</a></h3>
<p>What we really need is some sort of special variable. We need something that we can put in the template which can be notified when its value changes, and something that can transparently act as its value. </p>
<p>Imagine if we had a wearhouse of data who we could call and ask for data. &quot;Hey, I need the value of Aisle 2 bin 4.&quot; If we had the location of the data, we could always ask the wearhouse for whatever is stored there.</p>
<p>Or what if we could ask them to store something and they'd do so, responding with its location in the wearhouse. &quot;Can you store this gigantic novelty taco beanbag chair for me?&quot; we'd ask. &quot;Sure, and it's in aisle 2 bin 5,&quot; they'd respond. </p>
<p>This is what signals do. Signals are a formalized way of being able to communicate with the wearhouse (which in the context/scope in Leptos) to store data and retrieve data. When data changes, leptos can follow where it is being used, and update those usages accordingly. </p>
<p>I introduced the idea of copy earlier because the signals are actually indexes, storage positions in the context, which will be duplicated as you use them. This allows you to move a signal into a closure which will be handling an event while still using it in the view template. </p>
<h3 id="reactivity-in-action"><a class="header" href="#reactivity-in-action">Reactivity in action</a></h3>
<p>To create a signal, we need to call the function <code>create_signal()</code> and provide a scope (or context) as the first argument, and the default value as the second. It returns a tuple, a set of two values, which we can immediately give names to so that we can use them in the scope of our function.
The first part of the signal allows us to retrieve a copy of the value from the wearhouse. The second part of the signal allows us to set the value at the signal's location.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (value, set_value) = create_signal(cx, the_lucky_number);  
<span class="boring">}</span></code></pre></pre>
<p>The above is called destructuring. We could also have written in the long form way but it is actually harder to read and requires additional temporary assignments like <code>lucky_number_signal</code>. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let lucky_number_signal = create_signal(cx, the_lucky_number);  
let value = lucky_number_signal.0;
let set_value = lucky_number_signal.1;
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Note that <code>.0</code> and <code>.1</code> are properties on the <code>lucky_number_signal</code>. They're indexes for the first and second component in the tuple.</p>
</blockquote>
<p>Now that we have a signal we can update our callback and move the set_value signal into it. Not the addition of the move keyword before the closure's pipes which encapsulate it's properties, and the underscore which denotes that it will be provided a property when called, but we won't be using it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let update_the_lucky_number = move|_|{  
        set_value(42);  
    };  
<span class="boring">}</span></code></pre></pre>
<p>And in the view template we can update our previous value with our signal which can be used to derive the value.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;LuckyNumber the_lucky_number=12 /&gt;  
        }  
    })  
}  
  
#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number: i32) -&gt; Element {  
    let (value, set_value) = create_signal(cx, the_lucky_number);  
  
    let update_the_lucky_number = move|_|{  
        set_value(42);  
    };  
    view!{  
        cx,  
        &lt;div&gt;  
            &lt;p&gt;&quot;Today's lucky number is &quot; {value}&lt;/p&gt;  
            &lt;button on:click=update_the_lucky_number &gt;&quot;Pick a better number&quot;&lt;/button&gt;  
        &lt;/div&gt;  
    }  
}</code></pre></pre>
<p>The coolest part about this is that the signal is responsible for updating itself on the web page if it's value changes. LuckyNumber doesn't run again to create a new template. Leptos updates that special little text node, where <code>{value}</code> is used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-handlers-as-props"><a class="header" href="#event-handlers-as-props">Event Handlers as Props</a></h1>
<h2 id="what-we-know-9"><a class="header" href="#what-we-know-9">What we know</a></h2>
<ul>
<li>We sometimes want to handle events at higher levels in the Leptos component tree</li>
</ul>
<h2 id="what-well-learn-9"><a class="header" href="#what-well-learn-9">What we'll learn</a></h2>
<ul>
<li>How to pass event handlers down the component tree</li>
</ul>
<h2 id="the-lesson-7"><a class="header" href="#the-lesson-7">The Lesson</a></h2>
<p>We know that we can setup click handlers on buttons. Here's a quick example:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;RadApp /&gt;  
        }    
	})
}  
  
#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
    view! {  
        cx,  
        &lt;ChildComponent/&gt;  
    }
}  
  
#[component]  
fn ChildComponent(cx: Scope) -&gt; Element {  
    let click_handler = |_|{  
        leptos::log!(&quot;Child button clicked&quot;);  
    };  
    view! {  
        cx,  
        &lt;div&gt;  
           &lt;button on:click=click_handler&gt;  
                &quot;Click me&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }
}</code></pre></pre>
<p>We may want to delegate the responsibility of handing this event to a parent or ancestor of the initial event target. In this case, the originating DOM node, the event target, would be the button.</p>
<p>We previously solved this problem by having our event bubble up. Our <code>click</code> dispatched by the <code>ChildComponent</code> bubbles up to the parent <code>RadApp</code> which responds via <code>on:click</code> as seen here:</p>
<blockquote>
<p>Note that we needed to add <code>use web_sys::MouseEvent;</code></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
use web_sys::MouseEvent;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;RadApp /&gt;  
        }    })}  
  
#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
    let click_handler = |_|{  
        leptos::log!(&quot;Child button clicked&quot;);  
    };  
  
    view! {  
        cx,  
        &lt;ChildComponent on:click=click_handler/&gt;  
    }}  
  
#[component]  
fn ChildComponent(cx: Scope) -&gt; Element {  
    view! {  
        cx,  
        &lt;div&gt;  
           &lt;button&gt;  
                &quot;Click me&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }
}</code></pre></pre>
<p>The problem here is that we would need to introspect the event to differentiate which thing was clicked to make sure we're responding to the correct event.</p>
<p>We can solve this problem by dispatching a custom event, but we have extra complexity in adding custom events. It should also be noted that there is overhead (a computational cost that decreases performance) to adding additional event handlers.</p>
<h3 id="strategy-pattern-sort-of"><a class="header" href="#strategy-pattern-sort-of">Strategy pattern, sort of</a></h3>
<p>One solution to the aforementioned problem is to pass the handler down as a property. We can send what should happen down to where it happens so that it can be called. This is an inversion of having what happened bubbling up. We're sending what to do on down.</p>
<p>First, we need to send our click_handler as a property to the <code>ChildComponent</code>. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
  
    let click_handler = |_|{  
        leptos::log!(&quot;Child button clicked&quot;);  
    };  
  
    view! {  
        cx,  
        &lt;ChildComponent onclick=click_handler/&gt;  
    }
}  
<span class="boring">}</span></code></pre></pre>
<p>Next is the tricky part. We need to accept the value of the <code>click_handler</code> (a closure) into <code>ChildComponent</code>. We do this by declaring it as a function property of the component. We need to use a generic, herein referred to as <code>T</code>. When we add <code>on:click=onclick</code> to the <code>button</code> we're attaching the handler to the <code>click</code> event. This will trigger Rust to say, &quot;HEY, if you're using this value for <code>on:click</code>, it has to be a specific type of closure!&quot; We need to add some specificity to the closure.</p>
<p>We can do this by adding <code>where T: Fn(MouseEvent) -&gt; () + 'static </code> to the end of the function definition, but before the scope of the function's body opens. This tells Rust that the function parameter <code>onclick</code> can be <code>anything</code> provided that <code>anything</code> implements <code>Fn(MouseEvent) -&gt; ()</code>. This is a <code>function trait</code>. It is also required to be <code>'static</code> lifetime, so we'll add that as well with <code>+ 'static</code>. The static lifetime tells Rust that this data will live for the duration of the application's running.</p>
<p>By doing this we can safely pass a callback that matches the requirements of the <code>on:click</code> assignment, which is verified at the component property level!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn ChildComponent&lt;T&gt;(cx: Scope, onclick:T ) -&gt; Element  
    where T: Fn(MouseEvent) -&gt; () + 'static  
{  
    view! {  
        cx,  
        &lt;div&gt;  
           &lt;button on:click=onclick&gt;  
                &quot;Click me&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }
}

<span class="boring">}</span></code></pre></pre>
<p>I'll update some of the names to disambiguate between <code>on:click</code> and <code>onclick</code>. Here's the final code. </p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
use web_sys::MouseEvent;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;RadApp /&gt;  
        }    
	})
}  
  
#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
  
    let log_clicked_button = |_|{  
        leptos::log!(&quot;Child button clicked&quot;);  
    };  
  
    view! {  
        cx,  
        &lt;ChildComponent click_logger=log_clicked_button/&gt;  
    }
}  
  
#[component]  
fn ChildComponent&lt;T&gt;(cx: Scope, click_logger:T ) -&gt; Element  
    where T: Fn(MouseEvent) -&gt; () + 'static  
{  
    view! {  
        cx,  
        &lt;div&gt;  
           &lt;button on:click=click_logger&gt;  
                &quot;Click me&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-bubbling-and-signal-generics"><a class="header" href="#event-bubbling-and-signal-generics">Event Bubbling and Signal Generics</a></h1>
<h2 id="what-we-know-10"><a class="header" href="#what-we-know-10">What we know</a></h2>
<ul>
<li>We can monitor activity in the browser by responding to events</li>
<li>We can add functions that run when events happen to Leptos components. These functions are called event handlers. Event handlers added to Leptos components are also added to their DOM node counterparts and connected behind the scenes with Leptos' use of <code>wasm_bindgen</code> making their use transparent.</li>
<li>The syntax for an event handler is similar to adding a property to a component, but with a prefix of <code>on:</code> followed by the event name. e.g. <code>&lt;LeptosComponent on:click=my_event_handler /&gt;</code>.</li>
<li>Event handlers (event callbacks) are closures (a one time function that encapsulates the values used in it) that are assigned to a variable. e.g. <code>let my_event_handler = |event|{ ... }</code>.</li>
<li>the <code>move</code> keyword that can preceed a closure's parameters, indicating that variables used in the closure's function body will be moved into the closure itself and removed from the current scope as if they were passed into a function. Variables that are types that support the Copy trait will automatically be copied and will still be available in the current scope. </li>
<li>Signal read and write components support Copy.</li>
</ul>
<h2 id="what-well-learn-10"><a class="header" href="#what-well-learn-10">What we'll learn</a></h2>
<ul>
<li>How events can be captured in parent components</li>
<li>What generics are in Rust's type system at an introductory level</li>
</ul>
<h2 id="the-lesson-8"><a class="header" href="#the-lesson-8">The Lesson</a></h2>
<blockquote>
<p>Caveat: The following lesson is intended to show you an overview of a pattern to respond to events which are emmitted by a component's children. This is not a complete patter. A description of the tricky spots exists at the end of this lesson. </p>
</blockquote>
<p>We've established that the document object model (DOM) is a tree like representation of DOM nodes which is a browsers data structure containing information about what's on a web page. When events happen in a browser, the event will triggered at the lowest, most specific, DOM node. That event will bubble up until it's handled or prevented from continuing. Bubbling up means that the original event will be given the opportunity to handled by the originating element's parents, one at a time, until it reaches the top of the DOM tree.</p>
<p>If we take the following HTML:</p>
<pre><code class="language-html">&lt;html&gt;
	&lt;body&gt;
		&lt;div id=&quot;application&quot;&gt;
			&lt;div class=&quot;button-container&quot;&gt;
				&lt;button&gt;Click me&lt;/button&gt;
			&lt;/div&gt;
		&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Clicking on the click me button would create the intial event. <code>on:click</code> events handlers on this element will run first. Then, <code>on:click</code> handlers for the &quot;.button-container&quot; would run, and so forth.</p>
<p>This means that you can place handler logic on a parent component that has multiple children who emit events. For example, you could use this way of thinking to run a validation script on a form any time any input field is changed. Or, imagine if you wanted to capture any click as some form of analytics. You could setup a click handler in your main app which will capture all events that bubble up to it.</p>
<h3 id="using-bubbled-events-to-update-leptos-component-properties"><a class="header" href="#using-bubbled-events-to-update-leptos-component-properties">Using bubbled events to update Leptos component properties</a></h3>
<p>The following is an example of how we can move the lucky number value's handler out of the component and into a new Leptos component we're calling <code>RadApp</code>.</p>
<p>To start, we'll create a new component called <code>RadApp</code>, add it to the mount_to_body <code>view!</code>, and setup our <code>LuckyNumber</code> component as a child.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;RadApp /&gt;  
        }  
    })  
}  
  
#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;LuckyNumber the_lucky_number=12 /&gt;  
    }  
}  
  
#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number: i32) -&gt; Element {  
    view!{  
        cx,  
        &lt;div&gt;  
            &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
            &lt;button&gt;&quot;Pick a better number&quot;&lt;/button&gt;  
        &lt;/div&gt;  
    }  
}</code></pre></pre>
<p><code>LuckyNumber</code> has a button that we want to activate. That event will bubble up so we can put the on click handler on the Leptos component instead of on the button, like we did previously.</p>
<p>Let's add the <code>on:click</code> and we'll use the leptos log macro to write a message to the browser console.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
	let update_the_lucky_number = |_|{  
	  leptos::log!(&quot;We should be updating the lucky number&quot;);  
	};
	  
    view!{  
        cx,  
        &lt;LuckyNumber on:click=update_the_lucky_number the_lucky_number=12 /&gt;  
    }  
}  
<span class="boring">}</span></code></pre></pre>
<p>Rust's compiler may complain saying <code> cannot find type MouseEvent in this scope</code> followed by <code>consider importing this struct</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::web_sys::MouseEvent;
<span class="boring">}</span></code></pre></pre>
<p>You can literally copy and paste this into your main.rs file right after <code>use leptos::*</code>.</p>
<p>Now we need to create our signal so that we can read and update the data over time. We need to register it in our scope.
`</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
	let (value, set_value) = create_signal(cx, 12);
	let update_the_lucky_number = |_|{  
	  leptos::log!(&quot;We should be updating the lucky number&quot;);  
	};
	  
    view!{  
        cx,  
        &lt;LuckyNumber on:click=update_the_lucky_number the_lucky_number=12 /&gt;  
    }  
}  
<span class="boring">}</span></code></pre></pre>
<p>We might intuitively think, &quot;Hey, we can just put value where the number 12 previously was as a property of <code>LuckyNumber</code>,&quot; like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> &lt;LuckyNumber on:click=update_the_lucky_number the_lucky_number=value /&gt;  
<span class="boring">}</span></code></pre></pre>
<p>But this won't work. There's a problem. Value is a <code>ReadSignal</code>, and our property is supposed to be a 32 bit integer. We can see this in the function definition of the <code>LuckyNumber</code> component.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn LuckyNumber(cx: Scope, the_lucky_number: i32) -&gt; Element {
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><code>the_lucky_number</code> is supposed to be any 32 bit integer, denoted by <code>i32</code>.</p>
</blockquote>
<p>Rust's compiler will actually give you an error showcasing what was expected and what it received:</p>
<pre><code> note: expected type `i32`
       found struct `ReadSignal&lt;{integer}&gt;`

</code></pre>
<blockquote>
<p>All of these errors will appear in the terminal that you typed <code>trunk serve</code> in.</p>
</blockquote>
<p>The type ReadSignal&lt;{integer}&gt; probably looks a little bit weird to you. You might ask yourself, why is there a bunch of stuff after the type's name? What does <code>&lt;{integer}&gt;</code> mean?</p>
<p>Recall that functions have parameters which follow the function the function name and are encapsulated by parenthesis.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// this is pseudo code to show you the structure of the signature
fn function_name(parameter_name: SomeType)
<span class="boring">}</span></code></pre></pre>
<p>Types have parameters called generics which follow the type name and are encapsulated by angle brackets.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>SomeType&lt;SomeGenericType&gt;
<span class="boring">}</span></code></pre></pre>
<p>Generics allow us to configure a type with additional types. </p>
<p>For example, let's say that we have a bunch of containers and we're preparing our lunch for the day. We can store things in all of the containers and we can eat the contents from each container. All of the containers, though different sizes and colours, share the same type. They're containers. But some containers may contain liquids and others will contain solids.
If we were to eat or drink from one of the containers we could use the type system to guarantee that we wouldn't try to drink our sandwich or chew our milk by using parameter types like, <code>Container&lt;Solid&gt;</code> and <code>Container&lt;Liquid&gt;</code> respectively. </p>
<p>If we pop back over to Leptos, we can see how the context (scope) is similar. If we think about our wearhouse that we use to store and retrieve value from, we need some way to embed what type of values those are. </p>
<p>If we create_signal with an integer like an i32, we're saying that the ReadSignal is actually <code>ReadSignal&lt;i32&gt;</code>. This tells rust, &quot;Hey, this ReadSignal works like any other read signal, but when you get the contents out of it, it'll absolutely be a valid i32&quot;.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number: ReadSignal&lt;i32&gt;) -&gt; Element {  
    view!{  
        cx,  
        &lt;div&gt;  
            &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
            &lt;button&gt;&quot;Pick a better number&quot;&lt;/button&gt;  
        &lt;/div&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>We need to update our RadApp component to pass the signal to the component as well. Our whole working example looks like this.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
use web_sys::MouseEvent;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;RadApp /&gt;  
        }  
    })  
}  
  
#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
    let (value, set_value) = create_signal(cx, 12);  
    let update_the_lucky_number = move|_|{  
      set_value(42)  
    };  
    view!{  
        cx,  
        &lt;LuckyNumber on:click=update_the_lucky_number the_lucky_number=value /&gt;  
    }  
}  
  
#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number: ReadSignal&lt;i32&gt;) -&gt; Element {  
    view!{  
        cx,  
        &lt;div&gt;  
            &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
            &lt;button&gt;&quot;Pick a better number&quot;&lt;/button&gt;  
        &lt;/div&gt;  
    }  
}</code></pre></pre>
<h3 id="an-important-caveat-when-capturing-child-node-events"><a class="header" href="#an-important-caveat-when-capturing-child-node-events">An important caveat when capturing child node events</a></h3>
<p>One very important thing to note here is that ANY click events within the <code>&lt;LuckyNumber /&gt;</code> component will trigger the <code>on:click</code> event handler. </p>
<p>When we placed the event handler on the button itself, it was locked to that button. </p>
<p>When we place the hander on the parent, all clicks bubble up to it.</p>
<p>The distinction is important because while clicking on the button if there is one button yields the same behaviour, there are some subtle differences you shuold be aware of.</p>
<ol>
<li>Clicking anywhere will trigger the <code>on:click</code> handler</li>
<li>The event handler does not differentiate between buttons if one or more existed.</li>
</ol>
<p>The above example and lesson is not suitable in most cases but it a good simple example of capturing an event outside of its source. We will go into detail about how to filter the child events, prevent further bubbling, and so forth in later lessons.</p>
<h3 id="event-delegation-and-bubbling"><a class="header" href="#event-delegation-and-bubbling">Event delegation and bubbling</a></h3>
<p>Adding event listeners to DOM nodes has non trivial overhead. Leptos solves this problem with a clever optimization. It registers one top level handler for each event type and attaches this event handler to the Window DOM node. </p>
<p>Event handlers that we register in Leptos get added to a list of handlers for that event type. When an event fires in the browser, it bubbles up to the Window and is handled by the top level handler (created by Leptos as part of the aforementioned optimization). Events include a path component which Leptos can use to walk the DOM tree and fake bubble the event through its ancestors (the parts of its path). </p>
<p>Custom events created through web_sys do not bubble by default and will not be able to reach the Window from it's origin. For this reason, you need to ensure that custom events bubble so that they reach the Window and Leptos can handle them, delegating to the hander that you wrote.</p>
<blockquote>
<p><strong>From the author of Leptos:</strong> Leptos uses event delegation to make the creation of DOM nodes faster. This means that rather than attaching event listeners to individual HTML elements, the framework adds a single event listener to the page per event type (like <code>click</code> or <code>change</code>), and calls the handlers you define by looking them up manually. This adds a small increase in Wasm binary size in exchange for faster rendering times.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-events"><a class="header" href="#custom-events">Custom Events</a></h1>
<h2 id="what-we-know-11"><a class="header" href="#what-we-know-11">What we know</a></h2>
<ul>
<li>One of the key ways applications change data over time is in response to stimulus. We can witness these changes through a browser's runtime through the browser's event system.</li>
</ul>
<h2 id="what-well-learn-11"><a class="header" href="#what-well-learn-11">What we'll learn</a></h2>
<ul>
<li>Which events exist and/or are supported</li>
<li>Create custom events</li>
<li>Tips on how to read Rust documentation</li>
<li>The dangers of complexity and trying to think about simplicity</li>
<li>An introduction to structs, data, instance methods, and static methods</li>
<li>An introduction to match statements</li>
<li>An introduction to Result types</li>
<li>An introduction to Option types</li>
<li>Creating DOM node references for Leptos components</li>
</ul>
<h2 id="the-lesson-9"><a class="header" href="#the-lesson-9">The Lesson</a></h2>
<p>There are some common events that you can probably intuitively guess. Going from pure intuition is only going to get you so far. </p>
<p>We frame the way we solve problems through the lense of the tools we have at hand. For this reason, it's a good idea to familiarize yourself with the HTML tags that exist and the web events that exist. The web platform has a ton of features that a lot of people don't know about because they stopped learning HTML at <code>&lt;div&gt;</code> and <code>&lt;p&gt;</code> tags.</p>
<p>The mozilla foundation has a wonderful website called MDN which contains invaluable reference to help expand your knowledge.</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML">HTML elements and reference</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Events#event_listing">List of web events</a></li>
</ul>
<p>The List of web events will provide everything you need to know to respond to actions on elements which you can attach to your Leptos components.</p>
<h3 id="custom-events-1"><a class="header" href="#custom-events-1">Custom Events</a></h3>
<p>You may wish to create your own custom events. Custom events can be useful when you want to differentiate a generic behaviour in the web, from a specific behaviour or event in your application. </p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn MyLunchbox(cx: Scope) -&gt; Element {  
    let consume_sandwich = |_|{  
      // do something in response to  
      // the sandwich being eaten.
    };  
    view!{  
        cx,  
        &lt;Sandwich on:eat=consume_sandwich/&gt;  
    }  
}

#[component]  
fn Sandwich(cx: Scope) -&gt; Element {  
    let trigger_eating_event = |_|{  
      // Code that triggers the custom event
      // which will bubble up to from the 
      // botton to it's parent
    };  
    view!{  
        cx,  
        &lt;button on:click=trigger_eating_event/&gt;
	        I'm a snack
        &lt;/button&gt; 
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>If we were to write this with standard events, we would need some more introspection and features of the platform start to leak up into higher levels of our application. This issue can be simplified as saying, knowledge of the application needs to span across the boundary of multiple components. More things to keep in your head makes programs harder to reason about, more difficult to extend/modify, and less clear to newcomers wishing to contribute to the application. Or, maybe you just came back from a vacation and forgot all about how sometihng worked. Ideally you shouldn't need to know how (which is imperative), being able to focus on what (which is declarative).</p>
<p>Ultimately we probably don't care if a click event triggered the sandwich to be eaten, or if it was a key press that triggered it. Maybe the button was focused and they hit the enter key. </p>
<p>This is my opinion but I would say that In some sense the custom event simplifies our application because we're handling the <em>what</em> of the event insted of the <em>how</em> (click, key press, etc). </p>
<p>In the following standard event example, MyLunchbox needs to be aware of which events might exist to bubbling up to it as clicks. The event handler needs to filter out the appropriate event, introspect the event (look inside of it), and then take the appropriate action. Imagine that our sandwich in our system has a special identifier. </p>
<p>We could should out, &quot;Eat #2&quot; which happens to be the sandwich, emitting an eat event with a payload (data assocaited with the event) that is the food's identifier in your lunchbox.</p>
<p>The standard event equivalent would, &quot;I'm doing a thing with my lunchbox stuff,&quot; requiring someone to then ask, &quot;Ok, so um... what are you doing? Are you trying to eat something? What are you trying to eat? Does it have an identifier? Can I get that identifier?&quot;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn MyLunchbox(cx: Scope) -&gt; Element {  
    let maybe_consume_sandwich = |event|{  
      // Introspection may be required in more
      // complicated use cases to make sure the 
      // right event bubbled up to be handled
      // and that it has the correct data to be
      // able to follow through with the desired
      // application behaviour.
    };  
    view!{  
        cx,  
        &lt;Sandwich on:click=maybe_consume_sandwich/&gt;  
    }  
}

#[component]  
fn Sandwich(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;button on:click=trigger_eating_event/&gt;
	        I'm a snack
        &lt;/button&gt; 
    }  
}

<span class="boring">}</span></code></pre></pre>
<h4 id="caution-beware-complexity"><a class="header" href="#caution-beware-complexity">Caution: Beware complexity!</a></h4>
<p>It can be tempting to cut your application up into a ton of domain specific—specific to the problem you're solving with language appropriate to that problem—events, but that comes at a cost. You will lose some forms of flexibility as you add focus and specificity to your application. </p>
<p>In the standard event example, we do still have the ability to introspect the event when handling it in MyLunchbox. That might be really useful. If we needed some additional data with our custom event we'd need to go into the Sandwich component and include it.</p>
<p>And that's the thing with programming. It always depends.</p>
<p>I advocate for, favour simplicity and only cut things apart when they get too big to keep together. Some problems are inherently complicated because of the types of problems they are. Ideally you should be able to walk away from your program, come back, and understand what's happening. We can not rely on being in the flow state or &quot;zone&quot; as the required mode to understand what we wrote. I would say this is actually a liability. Besides, we should create applications that allow us to be interrupted by life without causing frustration. </p>
<h3 id="creating-a-custom-event"><a class="header" href="#creating-a-custom-event">Creating a custom event</a></h3>
<p>Creating a custom event normally happens in JavaScript, because it's part of the browser's runtime. The code looks like this:</p>
<pre><code class="language-javascript">
const event = new Event('build');

// Listen for the event.
elem.addEventListener('build', (e) =&gt; { /* … */ }, false);

// Dispatch the event.
elem.dispatchEvent(event);

</code></pre>
<blockquote>
<p>https://developer.mozilla.org/en-US/docs/Web/Events/Creating_and_triggering_events</p>
</blockquote>
<p>We need to do something similar in our Rust code. To do this we'll use the web_sys crate.</p>
<p>There is a struct in <code>web_sys</code> called <code>CustomEvent</code> <a href="https://docs.rs/web-sys/latest/web_sys/struct.CustomEvent.html#method.new">Docs</a></p>
<p>Let's go over some struct basics since we're going to e using them for this lesson and going forward.</p>
<h4 id="introduction-to-structs"><a class="header" href="#introduction-to-structs">Introduction to Structs</a></h4>
<p>A struct is like a class in a lot of object oriented languages. It is a category of <code>type</code> that has the ability to group data, functionality related to that data, and functionality related to its general idea, all around a single name. Recall that a <code>type</code> is the name that describes a set of possible values.</p>
<h5 id="struct-data"><a class="header" href="#struct-data">Struct data</a></h5>
<p>One of the key features of structs in Rust is that they specify a grouping of data types and values which we call properties. I suspect this is why they're called structs—structured data or data structure. If we had a Bacon Lettuce and Tomato sandwich struct it's definition would look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct BLTSandwich {
	bread: TypeOfBread,
	lettuce: TypeOfLettuce,
	tomato: TypeOfTomato,
	bacon: TypeOfBacon,
	mayo: bool
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>The above example expects that TypeOfBread, TypeOfLettuce, TypeOfTomato, and TypeOfBacon are all defined earlier. They are used here to illustrate that BLTSandwich has constrained which values it's specific proeprties can have. You can not have a BLTSandwich with rocks as a value for bacon, because rocks are not a type of bacon! This is why type systems are important. They help prevent us from eating rocks... or... making mistakes in our programs. :)</p>
</blockquote>
<p>If you have keen eyes you'll recognize something here. There's a pattern that we've seen a few times before.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// a function definition
fn function_name( parameter: type ) {}

// a struct definition
struct StructName{ property: type }
<span class="boring">}</span></code></pre></pre>
<p>This pattern can be abstracted to the following:</p>
<ul>
<li>Rust keyword to define context/subject (<code>fn</code>, <code>struct</code>)</li>
<li>A name to be able to use the noun(<code>function_name</code>, <code>StructName</code>)</li>
<li>Some form of encapsulation with configuration</li>
</ul>
<h5 id="make-a-new-thing-from-an-idea-a-concretion"><a class="header" href="#make-a-new-thing-from-an-idea-a-concretion">Make a new thing from an idea (a concretion)</a></h5>
<p>A struct or structure is like an idea. And ideas aren't real in a sense that we can't hold them. We have an idea of what a BLT Sandwich is, but we can't eat the idea. But we have written specification for what the BLT is in the definition of our struct.</p>
<p>If we were to take <strong>the idea of a  BLT sandwich</strong> and <em>make</em> <strong>A BLT sandwich</strong> we would say that we were making a concretion. A thing that is concrete or real. In object oriented programming (OOP) we would say that we are instantiating the idea (in oop ideas are classes). We are creating an instance of it. </p>
<p>The syntax to create a struct includes writing the stuct's name, followed by curly braces, and a list of the property names and their values. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Assuming that the values for these 
// properties were already defined in scope
// with statements like
// let canadian_rye = get_the_best_sandwich_bread();
BLTSandwich{  
	bread: canadian_rye,
	lettuce: romaine,
	tomato: black_krim,
	bacon: farm_smoked_apple_bacon,
}
<span class="boring">}</span></code></pre></pre>
<p>Most library (crate) authors write functions associated with a struct (with the idea of it) to make a concretion. It's convention for this function to be called 'new'. Calling the function follows this syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	let my_thing = SomeStruct::new();
<span class="boring">}</span></code></pre></pre>
<h5 id="functionality-associated-with-the-idea-static-methods"><a class="header" href="#functionality-associated-with-the-idea-static-methods">Functionality associated with the idea (static methods)</a></h5>
<p>Structs can have functionality associated with the name of the struct. Some would described as functions that are namespaced, meaning that they are prefixed to or expected to be understood in the context of the name (being the struct's name).</p>
<p>The following showcases a <code>new</code> function in the <code>BLTSandwich</code> namespace which returns a new <code>BLTSandwich</code> (a concretion).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl BLTSandwich {
	pub fn new() -&gt; BLTSandwich {
		BLTSandwich{  
			bread: canadian_rye,
			lettuce: romaine,
			tomato: black_krim,
			bacon: farm_smoked_apple_bacon
		}
	}
	pub fn name() -&gt; String {
		&quot;Bacon, Lettuce and Tomato Sandwich&quot;.to_string()
	}
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Normally there would be parameters in the new function to accept arguments to configure the new thing being created. I skipped on that for the sake of simplicity. </p>
</blockquote>
<p>We can see here that we also have a name function which returns a long form name of the sandwich as a string.</p>
<p>We could call this by writing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let the_sandwich_name : String = BLTSandwich::name();
<span class="boring">}</span></code></pre></pre>
<p>Again, we can see that these are functions associated with the idea and separated by two colons. </p>
<p>But again, look closely! A pattern emerges! We previously used a function called <code>leptos::log!</code>. But leptos isn't a struct, it's a crate! </p>
<p>Rust uses the same pattern of double colons to say, &quot;We're setting the context to qualify which thing we're talking about&quot;. When we say BLTSandwich::name, we're telling Rust &quot;Ok, think about BLTSandwich things... when I say name, you know what I'm talking about.&quot;</p>
<p>The Rust language designers have done a superb job at making these things easy to remember <em>if</em> you're aware that there is a pattern and design behind the decision. I can only assume that these design decisions were very deliberate.</p>
<h5 id="functionality-associated-with-the-a-concretion-methods"><a class="header" href="#functionality-associated-with-the-a-concretion-methods">Functionality associated with the a concretion (methods)</a></h5>
<p>We can associate functionality with a specific concretion (a struct made real) which we often call methods. </p>
<p>If we had a mthod called <code>calories</code> we could call with the following Rust code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sandwich = BLTSandwich::new();
let calories = sandwich.calories();
<span class="boring">}</span></code></pre></pre>
<p>Here we make a sandwich and call calories on it.</p>
<p>The context here is so tightly coupled that we use a single dot as a separator. I like to think of it as this.</p>
<ol>
<li>4 dots — A namespace is a grouping of many things, so we use many dots.</li>
<li>1 dot — A value is a single thing, so we use one dot.</li>
</ol>
<p>The neat thing about the above is that if you didn't need to use sandwich you can chain these all together:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let calories = BLTSandwich::new().total_calories();
			   ^----------------^
				This will evaluate into a 'sandwich'
				which we can call total_calories() on.
<span class="boring">}</span></code></pre></pre>
<p>Methods always have a special &amp;self parameter as the first argument to denote that they're able to make reference to itself. This is how a function has the ability to do anything with it's own data. Recall that we can not use a piece of data unless it is in scope.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>// Imagine that there is some function called calories, 
// which accepts things that can be turned into a calories
// value which is a 32 bit integer. Don't worry about how this
// would work. This is just a simple example.

impl BLTSandwich {
	// imagine the other static methods or namespace 
	// function from before were still here.

	pub fn total_calories(&amp;self) -&gt; i32 {
		calories(self.bread) + 
		calories(self.lettuce) + 
		calories(self.tomato) + 
		calories(self.bacon)
		// Recall that this function will evaluate to the 
		// last statement in its body. That's why there's no
		// semicolon at the end of this last item.
	}
	pub fn name() -&gt; String {
		&quot;Bacon, Lettuce and Tomato Sandwich&quot;.to_string()
	}
}
<span class="boring">}</span></code></pre></pre>
<p>Note that we're able to use the value of the struct's properties with <code>.bread</code>.
If we look at the function <code>total_calories</code> it starts to look really similar to <code>.bread</code>. with the exception of us adding parenthesis at the end to call the fucntion. Yet another pattern emerges, methods on a value are properties on the value that you can call!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sandwich = BLTSandwich::new();
sandwich.bread;
sandwich.total_calories; //&lt;- but then we add () to call it
<span class="boring">}</span></code></pre></pre>
<h4 id="using-web_syscustomevent"><a class="header" href="#using-web_syscustomevent">Using web_sys::CustomEvent</a></h4>
<p>We're well positioned to use the web_sys crate's CustomEvent struct.</p>
<p>If we zip over to the documentation we can see that there is a new method on the struct <a href="https://docs.rs/web-sys/latest/web_sys/struct.CustomEvent.html#">Docs</a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>web_sys::CustomEvent::new(&quot;my-custom-event&quot;);
<span class="boring">}</span></code></pre></pre>
<p>But there's a notice under the definition of the <code>new</code> method that states the following: </p>
<blockquote>
<p><em>This API requires the following crate features to be activated: <code>CustomEvent</code></em></p>
</blockquote>
<p>I did a quick search for &quot;web_sys enable feature&quot; which lead me to this support doc <a href="https://rustwasm.github.io/wasm-bindgen/web-sys/using-web-sys.html#enable-the-cargo-features-for-the-apis-youre-using">Enable the cargo features for the APIs you're using</a>.</p>
<p>Leptos includes these web_sys features for you as part of its library.</p>
<p>If we go back to the <code>new</code> method's definition in the web_sys::CustomEvent docs we'll see the following definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new(type_: &amp;str) -&gt; Result&lt;CustomEvent, JsValue&gt;
<span class="boring">}</span></code></pre></pre>
<p>Notice that it returns <code>after the -&gt;</code> a Result type, which has some type arguments (generics). The first one refers to what we get if new is run and the result is Ok, the second is the result that we get if new runs and the result is an Error. We can handle these with some in build pattern matching which we'll go into more later.</p>
<p>Our component code now looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn MyComponent(cx: Scope) -&gt; Element {  
    let trigger_sending_of_custom_event = |_|{  
        match web_sys::CustomEvent::new(&quot;my-custom-event&quot;) {  
            Ok(event) =&gt; {  
                // We have an event that we can send  
            },  
            Err(_) =&gt; {  
                // There as an error in creating the event  
                // We're not doing anything with this for now
				// so we'll use an '_' to destructure it's error
				// message            
			}  
        }  
    };  
    view!{  
        cx,  
        &lt;div&gt;  
            &lt;button on:click=trigger_sending_of_custom_event&gt;  
                &quot;Trigger custom event&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>match</code> keyword requires that we create branches/arms for each possible option. Recall that we talked about types as restrictions that describe possible values. A result is an enumeration (a list of possible values or strict set of options) which can be one of two values. It can be Ok or Err. The options are called variants. </p>
<p>In both of those cases there is a value that we can destructure out of the variants. Their types are listed as the the first and second type arguments in the returned type's signature. <code>Result&lt;CustomEvent, JsValue&gt;</code> means that we'll have an <code>Ok( CustomEvent )</code> or an <code>Err(JsValue)</code>.</p>
<p>I know from the JavaScript custom event documentation that it's not enough to create the event. We need to emit it. This is called <code>dispatching</code>. The javascript looks like this.</p>
<pre><code class="language-javascript">elem.dispatchEvent(event);
</code></pre>
<p>What we need is some way to refer to our <code>&lt;MyComponent /&gt;</code> so that we can dispatch the event on it. We need a reference to it.</p>
<h3 id="getting-a-reference-to-self-as-a-dom-node-with-noderef"><a class="header" href="#getting-a-reference-to-self-as-a-dom-node-with-noderef">Getting a reference to self as a DOM node with NodeRef</a></h3>
<p>Leptos provides us with the ability to get a reference to the DOM node created by its <code>view!</code> template. Think of it like a direct line to its DOM counterpoint.</p>
<p>The first step is to create the nodeRef, and add it as a special <code>_ref</code> property to the parent/root element in the <code>view!</code> template. Recall that the Leptos component is proxy for the <code>view!</code> template's root element. Putting the reference on this div is the same as putting the reference on <code>&lt;MyComponent /&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn MyComponent(cx: Scope) -&gt; Element {  
    let dom_node_ref = NodeRef::new(cx);
    // abbreviated/folded Rust code here for space saving
    view!{  
	    cx,  
	    &lt;div _ref=dom_node_ref&gt;  
	        &lt;button on:click=trigger_sending_of_custom_event&gt;  
	            &quot;Trigger custom event&quot;  
	        &lt;/button&gt;  
	    &lt;/div&gt;  
	}
}
<span class="boring">}</span></code></pre></pre>
<p>The dom_node_ref uses signals under the hood so we can move it into our handler closure without stressing about move semantics. We'll add the move keyword to the closure  and we'll add some more matching if we are able to make our custom event.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match dom_node_ref.get() {  
	None =&gt; {  
		// None will only happen if this component isn't  
		// mounted to the DOM, but it has to be in order                   
		// for the click event to fire, so we can ignore this                    
	}  
	Some(dom_element) =&gt; {  
		// Emit/dispatch our custom event  
	}  
}  
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>We call 'get' on the dom_node_ref to get the actual DOM element in Rust form. There are cases when the DOM element/node might not exist. Rust requires us to account for all possibilities, which is why the get method returns a option type. It's return type definition is <code>Option&lt;web_sys::Element&gt;</code>. Option is an enum which can be <code>None</code> or <code>Some</code> with the type argument provided in it's signature. In this case it's of the <code>web_sys::Element</code> type. We're destructing it and giving it the label <code>dom_element</code></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn MyComponent(cx: Scope) -&gt; Element {  
    let dom_node_ref = NodeRef::new(cx);  
  
    let trigger_sending_of_custom_event = move |_|{  
        match web_sys::CustomEvent::new(&quot;my-custom-event&quot;) {  
            Ok(event) =&gt; {  
                match dom_node_ref.get() {  
                    None =&gt; {  
                        // None will only happen if this component isn't  
		                // mounted to the DOM, but it has to be in order                   
			            // for the click event to fire, so we can ignore this                    
		            }  
                    Some(dom_element) =&gt; {  
                        // Emit/dispatch our custom event  
                    }  
                }  
            },  
            Err(_) =&gt; {}  
        }  
    };  
    view!{  
        cx,  
        &lt;div _ref=dom_node_ref&gt;  
            &lt;button on:click=trigger_sending_of_custom_event&gt;  
                &quot;Trigger custom event&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>Intuitively, we'll probably want to try something like this for the actual event sending. This is a focused view of the happy path match arm:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match dom_node_ref.get() {  
    None =&gt; {}  
    Some(dom_element) =&gt; {  
        dom_element.dispatch_event(event);  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>Unfortuantely this doesn't work. Rust tells us that dispatch_event is expecting a <code>&amp;event</code>, a reference to an event. Let's add an ampersand before event to send a reference.</p>
<p>Rust's compiler may complain about unhandled results from the event dispatch. We can add another match statement to handle those.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match dom_element.dispatch_event(&amp;event) {  
    Ok(_) =&gt; { 
	    leptos::log!(&quot;Custom event sent&quot;) 
	},  
    Err(_) =&gt; { 
	    leptos::log!(&quot;Failed to send&quot;) 
	}  
}
<span class="boring">}</span></code></pre></pre>
<p>We can now listen to our custom event from our Leptos component:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
    let log_response = |_| {  
        leptos::log!(&quot;Our custom event happened&quot;)  
    };  
    view! {  
        cx,  
        &lt;MyComponent on:myCustomEvent=log_response/&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Note that event names are camelCased</p>
</blockquote>
<p>We're still not totally there yet though. We need to actually tell this new custom event to bubble.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>//We need to create a config that is mutable (so we add 'mut' after let)
let mut event_config = web_sys::CustomEventInit::new();  

// We set the bubble property to true
event_config.bubbles(true);  

// We create a new event with the special config using a different constructor method

let event = web_sys::CustomEvent::new_with_event_init_dict(
	&quot;myCustomEvent&quot;, 
	&amp;event_config
);

// was previous
// let event = web_sys::CustomEvent::new(&quot;myCustomEvent&quot;); 
<span class="boring">}</span></code></pre></pre>
<p>And just like that we have custom events on components with references! </p>
<h4 id="the-complete-code"><a class="header" href="#the-complete-code">The Complete Code</a></h4>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;RadApp /&gt;  
        }  
    })  
}  
  
#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
    let log_response = |_| {  
        leptos::log!(&quot;Our custom event happened&quot;)  
    };  
    view! {  
        cx,  
        &lt;MyComponent on:myCustomEvent=log_response /&gt;  
    }  
}  
  
#[component]  
fn MyComponent(cx: Scope) -&gt; Element {  
    let dom_node_ref = NodeRef::new(cx);  
  
    let trigger_sending_of_custom_event = move |_| {  
  
        let mut event_config = web_sys::CustomEventInit::new();  
        event_config.bubbles(true);  
        let event = web_sys::CustomEvent::new_with_event_init_dict(&quot;myCustomEvent&quot;, &amp;event_config);  
  
        match event {  
             Ok(event) =&gt; {  
                 match dom_node_ref.get() {  
                    None =&gt; {}  
                    Some(dom_element) =&gt; {  
                        match dom_element.dispatch_event(&amp;event) {  
                            Ok(_) =&gt; { leptos::log!(&quot;Custom event sent&quot;) },  
                            Err(_) =&gt; { leptos::log!(&quot;Failed to send&quot;) }  
                        }  
                    }  
                }  
            }  
            Err(_) =&gt; {}  
        }  
    };  
    view! {  
        cx,  
        &lt;div _ref=dom_node_ref&gt;  
            &lt;button on:click=trigger_sending_of_custom_event&gt;  
                &quot;Trigger custom event&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }  
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-event-data"><a class="header" href="#custom-event-data">Custom Event Data</a></h1>
<h2 id="what-we-know-12"><a class="header" href="#what-we-know-12">What we know</a></h2>
<ul>
<li>Custom events can be dispatched and bubbled up to handle events at different levels of your applications.</li>
<li>Custom events allow us to convert imperative events based on DOM interaction into domain specific events that are more declarative.</li>
</ul>
<h2 id="what-well-learn-12"><a class="header" href="#what-well-learn-12">What we'll learn</a></h2>
<ul>
<li>A deeper look in to declarative or domain specific code</li>
<li>Why and how to add data with custom events</li>
</ul>
<h2 id="caveat"><a class="header" href="#caveat">Caveat</a></h2>
<ul>
<li>Custom events with data isn't the most efficient way to send data around Leptos. There is a performance toll to be paid any time data crosses the WASM boundary. This lesson is really about showing you how to do JavaScript like things in Leptos/Rust. With that said, there are more efficient ways to send data around Leptos, but at the cost of JavaScript interoperatibilty, which we'll investigate in later lessons.</li>
</ul>
<h2 id="the-lesson-10"><a class="header" href="#the-lesson-10">The Lesson</a></h2>
<p>We introduced custom events in a previous lesson, with the following code:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;RadApp /&gt;  
        }  
    })  
}  
  
#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
    let log_response = |_| {  
        leptos::log!(&quot;Our custom event happened&quot;)  
    };  
    view! {  
        cx,  
        &lt;MyComponent on:myCustomEvent=log_response /&gt;  
    }  
}  
  
#[component]  
fn MyComponent(cx: Scope) -&gt; Element {  
    let dom_node_ref = NodeRef::new(cx);  
  
    let trigger_sending_of_custom_event = move |_| {  
  
        let mut event_config = web_sys::CustomEventInit::new();  
        event_config.bubbles(true);  
        let event = web_sys::CustomEvent::new_with_event_init_dict(
	        &quot;myCustomEvent&quot;, 
	        &amp;event_config
	    );  
  
        match event {  
             Ok(event) =&gt; {  
                 match dom_node_ref.get() {  
                    None =&gt; {}  
                    Some(dom_element) =&gt; {  
                        match dom_element.dispatch_event(&amp;event) {  
                            Ok(_) =&gt; { leptos::log!(&quot;Custom event sent&quot;) },  
                            Err(_) =&gt; { leptos::log!(&quot;Failed to send&quot;) }  
                        }  
                    }  
                }  
            }  
            Err(_) =&gt; {}  
        }  
    };  
    view! {  
        cx,  
        &lt;div _ref=dom_node_ref&gt;  
            &lt;button on:click=trigger_sending_of_custom_event&gt;  
                &quot;Trigger custom event&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }  
}</code></pre></pre>
<p>In this code we have a Leptos component which contains a <code>view!</code> tempate with a div and a button. This button has a handler which is a closure passed to a <code>click</code> event via the <code>on:click</code> property (prop). </p>
<p>Leptos has a special private property for elements in <code>view!</code> templates. It's called <code>_ref</code> and it's used to allow Leptos to refer to HTML elements (by refering to them) in the client side runtime (in the browser). We create a reference in a given scope/context, and apply it as the value of the property <code>_ref</code>. </p>
<p>Recall that the root element of a <code>view!</code> template is interchangable with it's component tag. By placing a reference on the root <code>&lt;div&gt;</code> we're actually creating a reference to <code>&lt;MyComponent&gt;</code>.</p>
<p>The reference is used in the event handler so that our custom event appears to be dispatched from our Leptos component, allowing us to add a handler with <code>&lt;MyComponent on:myCustomEvent=... /&gt;</code>.</p>
<h3 id="platform-specific-to-domain-specific"><a class="header" href="#platform-specific-to-domain-specific">Platform specific to domain specific</a></h3>
<p>Systems and applications are full of complex mechanism. They contain behaviours that are described in code that reveal how the platform was designed and implemented. </p>
<p>Systems and applications are also full of domain specific complexity. They contain behaviours relating to the &quot;business logic&quot; or description of how the application solves a problem. How these problems are solved often describe activities relating to the problem, and not specifically relating to the technology that it runs on.</p>
<p>Or example, let's think about building a sandwich shop ecommerce application. And let's say we're clicking on a &quot;buy sandwich button&quot;. That button would have an on click event to add a sandwich to your cart. The idea of clicking and dispatching an event when something is clicked doesn't actually have anything to do with buying sandwiches. It actually has to do with the platform. </p>
<p>In our minds we may look at the button, the intention behind it, the text node as its label, and infering that clicking on the button should order a sandwich. This is implied and requires us to think about the intention of the application through its interaction with the platform.</p>
<p>If that event became an &quot;order sandwich&quot; event then we'd be in domain territory. It is specific to the language that describes activites and actions in the head space or domain of our problem—our sandwich shop.</p>
<p>Separating required knowledge of the platform from knowledge and interactions between business processes will allow you to focus on each area separately. This will allow you to change which things could trigger a sandwich order instead of introspecting and evaluating generic events.</p>
<p>This can make applications more flexible, robust, simple, and easier to understand. </p>
<h3 id="the-case-for-associated-event-data"><a class="header" href="#the-case-for-associated-event-data">The case for associated event data</a></h3>
<p>We've outlined that it's useful to separate platform events from application events, but we have't discussed the importance of associated data with those events yet. </p>
<p>Let's go back to our online sandwich shop as an example case. If have one sandwich, we're good. We can dispatch a custom event called &quot;orderSandwich&quot; and let that be that. But what do we do if we have more than one sandwich type? We'll need some way to know which sandwich we're ordering.</p>
<p>One solution could be to create one event per sandwich type. Perhaps we have orderRubinSandwich or orderBLTSandwich. This could be a completely valid solution if we only had a few sandwiches. Where things get tricky is when we start to think about configurations of sandwiches. We'll end with a combinatorial explosion of event types to match each sandwich configuration.</p>
<p>Our  Bacon Lettuce and Tomato sandwich, with the ability to select different breads, leafy greens, or tomato types, then we'd quickly end up with too many variants of event to manage.</p>
<p>This is a situation where we'd like our system to dispatch an event called orderSandwich, with data associated to configures what the sandwich is. It would be idea if we could send an orderBLTSandwich event where we specify which bread, leafy greens, or type of tomato are requeted by the customer.</p>
<blockquote>
<p>Beware, you may feel the urge to continue abstracting. It's not uncommon to think, &quot;Well, what if we want to sell different things at our sandwich shop? Why don't we just have orderItem as an event type and the configure of that item can include the item type, being a sandwich. If we ordered a drink, then drink would be the item type, and so forth.&quot; One could say that this is a premature generalization. The more general a system becomes the less its components express the function of the application. Moving from specific to generic actually adds some complexity in that you need to apply a case to think about the generalization. Try to start with the concrete, known, specific, and within the domain. Then refactor and generalize as needed as the application grows. There are no hard an fast rules for when to do this, just be aware that you do not need to hyper generalize your solutions at the start. Write what you mean, be clear, and you'll thank yourself later when you have to go in and edit things a month or year from now. :)</p>
</blockquote>
<h3 id="getting-the-configuration"><a class="header" href="#getting-the-configuration">Getting the configuration</a></h3>
<p>For the most simple example we can actually hard code the configuration into the event sender. We don't need to pull it out any HTML data attributes or input fields.</p>
<p>Our template could look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> view! {  
    cx,  
    &lt;div _ref=dom_node_ref&gt;  
     &lt;h3&gt;&quot;BLT Sandwich&quot;&lt;/h3&gt;  
        &lt;button  
         on:click=trigger_order_sandwich_event  
         &gt;  
            &quot;Order Sandwich&quot;  
        &lt;/button&gt;  
    &lt;/div&gt;  
}
<span class="boring">}</span></code></pre></pre>
<p>We need to update the event handler so that our new custom event is sent with this extra data. Web events have a property on their JavaScript object called <code>detail</code>, which we can use to story and carry arbitrary data. </p>
<p>After we initialize the <code>event_config</code>, we modify it so that it bubbles up (so that ancestors can respond to the event), and then we'll do another modification to add the detail data. Recall that if we're changing a piece of data we need to write <code>mut</code> before the name of it to specify that it can be changed, that it can be MUTated.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	let mut event_config = web_sys::CustomEventInit::new();  
    event_config.bubbles(true);  
    event_config.detail(&amp;data);
<span class="boring">}</span></code></pre></pre>
<p>But now you're probably wondering, what is <code>&amp;data</code>. We're providing the detail method on <code>event_config</code> with a reference (denoted with the <code>&amp;</code> ) to <code>data</code>. The detail method accepts any JsValue. In our simple example, we're only going to specify bread type. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bread_type = JsValue::from(&quot;Canadian Rye&quot;);  
event_config.detail( &amp;bread_type );
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>We are calling the from static method on the JsValue struct to create a new JsValue from our string slice &quot;Canadian Rye&quot;. We're then using the bread_type as an argument for the detail method, but we're passing the data as a reference, denoted with the <code>&amp;</code>; If you forget the ampersand the Rust compiler will actually make the recommendation for you to include it so that your usage matches the <code>detail()</code>  method's definition.</p>
</blockquote>
<p>To use JsValue we need to bring it into scope. At the top of your main.rs file, add </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::wasm_bindgen::JsValue;
<span class="boring">}</span></code></pre></pre>
<p>Our whole BLT component looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn BltSandwich(cx: Scope) -&gt; Element {  
    let dom_node_ref = NodeRef::new(cx);  
  
    let trigger_order_sandwich_event = move |event| {  
  
        let mut event_config = web_sys::CustomEventInit::new();  
        event_config.bubbles(true);  
        let bread_type = JsValue::from(&quot;Canadian Rye&quot;);  
        event_config.detail( &amp;bread_type );  
        let event = web_sys::CustomEvent::new_with_event_init_dict(  
            &quot;orderSandwich&quot;,  
            &amp;event_config  
        );  
  
        match event {  
            Ok(event) =&gt; {  
                match dom_node_ref.get() {  
                    None =&gt; {}  
                    Some(dom_element) =&gt; {  
                        match dom_element.dispatch_event(&amp;event) {  
                            Ok(_) =&gt; { leptos::log!(&quot;Custom event sent&quot;) },  
                            Err(_) =&gt; { leptos::log!(&quot;Failed to send&quot;) }  
                        }  
                    }  
                }  
            }  
            Err(_) =&gt; {}  
        }  
    };  
    view! {  
        cx,  
        &lt;div _ref=dom_node_ref&gt;  
           &lt;h3&gt;&quot;BLT Sandwich&quot;&lt;/h3&gt;  
            &lt;button on:click=trigger_order_sandwich_event&gt;  
                &quot;Order Sandwich&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>Now let's look at the top part of our app with our mount_to_body and top level app component:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;SandwichShopApp /&gt;  
        }  
    })  
}  
  
#[component]  
fn SandwichShopApp(cx: Scope) -&gt; Element {  
    let log_order = |_| {  
        leptos::log!(&quot;Our custom event happened&quot;);  
    };  
    view! {  
        cx,  
        &lt;BltSandwich on:orderSandwich=log_order /&gt;  
    }  
}</code></pre></pre>
<p>Let's focus in on the orderSandwich event handler:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let log_order = |_| {  
	leptos::log!(&quot;Our custom event happened&quot;);  
};  
<span class="boring">}</span></code></pre></pre>
<p>Note that before we had a underscore for the event parameter of the handler. We had no need of the event in the context of our closure's body (in-between the curley braces) so we wrote an underscore to tell Rust that we're not using. This is a Rust convention.</p>
<p>Now we need the event but we don't know what type it is. We can let Rust do the work for us. Put any type in there and run <code>trunk serve</code> if you're not already.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let log_order = |event: i32| {  
	leptos::log!(&quot;Our custom event happened&quot;);  
};  
<span class="boring">}</span></code></pre></pre>
<p>The compiler will check for you and tell you about the mismatch.</p>
<pre><code>expected closure signature `fn(Event) -&gt; _`
   found closure signature `fn(i32) -&gt; _`
</code></pre>
<p>This tells us that it should be an Event type, not i32. :D The compiler is so helpful.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let log_order = |event: Event| {  
	leptos::log!(&quot;Our custom event happened&quot;);  
};  
<span class="boring">}</span></code></pre></pre>
<p>If we just write the above the compiler will also tell us that &quot;Event&quot; doesn't exist in our scope. It's telling us we need to be more specific about what we mean. Then it outlines ways that we can bring the definition of events into our scope.</p>
<pre><code>help: consider importing one of these items
   |
1  | use crate::web_sys::Event;
   |
1  | use web_sys::Event;
   |

</code></pre>
<p>Use <code>web_sys::Event</code> would force all <code>Event</code> types to be <code>web_sys::Event</code> types. Think of it like we're importing the type. We can also just manually write the type with the namespace in our closure. I prefer to include the crate or module as context for clarity. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let log_order = |event : web_sys::Event| {
<span class="boring">}</span></code></pre></pre>
<p>...feels more clear than...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let log_order = |event : Event| {
<span class="boring">}</span></code></pre></pre>
<p>Shorter code isn't always better code. Aim to be clear and to avoid ambiguity.</p>
<p>Now, unfortunately there is no <code>detail()</code> method on a <code>web_sys::Event</code>. But a <code>web_sys::Event</code> is a JsValue and we can turn it into a custom event:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let custom_event = event.unchecked_into::&lt;web_sys::CustomEvent&gt;();
<span class="boring">}</span></code></pre></pre>
<p>Here we're calling the <code>unchecked_into</code> method on the event and using the turbo fish <code>::&lt;&gt;</code> syntax to provide the destination type argument, which is a <code>web_sys::CustomEvent</code>.</p>
<p>It should be noted that this is a unique behaviour to working with things that are <code>JsValue</code> types at their core. Rust doesn't normally work this way and you can not just smash one type into another type with this ease. JavaScript is not a typed language. When we work with JsValues we're often taking the raw data from JavaScript and pushing it into a Rust context where we enforce type safety from there forward. This is how we can call <code>unchecked_into</code> to convert the regular event to the custom event, granting us access to the <code>.detail()</code> method.</p>
<p>Our app event handler now looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let log_order = |event : web_sys::Event| {  
    let custom_event = event.unchecked_into::&lt;web_sys::CustomEvent&gt;();  
    let sandwich_type = custom_event.detail();  
    leptos::log!(&quot;Our custom event happened&quot;);  
    leptos::log!(&quot;{:?}&quot;, sandwich_type );  
};
<span class="boring">}</span></code></pre></pre>
<p>You'll note that when we log the value of <code>sandwich_type</code>, the console in your browser will say <code>JsValue(&quot;Canadian Rye&quot;)</code>.  The value we pulled out of detail() is a JsValue and needs to be converted into a rust type to be used elsewhere in your system.</p>
<p>We can use a special method on <code>JsValue</code> values called <code>as_string()</code>, but it returns an Option type which we can handle with our match statements.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let log_order = |event : web_sys::Event| {  
  
	leptos::log!(&quot;Our custom event happened&quot;);  
    
    let custom_event = event.unchecked_into::&lt;web_sys::CustomEvent&gt;();  
  
    let bread_type_js = custom_event.detail();  
    let opt_bread_type_rs = bread_type_js.as_string();  
    
    match opt_bread_type_rs {  
        Some(bread_type) =&gt; { leptos::log!(&quot;{:?}&quot;, bread_type ) },  
        None =&gt; {}  
    }  
};
<span class="boring">}</span></code></pre></pre>
<p>We can reduce assignments here by chaining all of these together.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let log_order = |event : web_sys::Event| {  
    leptos::log!(&quot;Our custom event happened&quot;);  
    let bread_type = event  
        .unchecked_into::&lt;web_sys::CustomEvent&gt;()  
        .detail()  
        .as_string()  
        .unwrap_or(String::new());  
  
    leptos::log!(&quot;{:?}&quot;, bread_type );  
};
<span class="boring">}</span></code></pre></pre>
<p>The new method here is <code>unwrap_or</code>, which takes the Some value or uses a default value (provided as an argument) if none.</p>
<p>The whole thing together looks like this:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
use crate::wasm_bindgen::JsValue;  
  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;SandwichShopApp /&gt;  
        }  
    })  
}  
  
#[component]  
fn SandwichShopApp(cx: Scope) -&gt; Element {  
    let log_order = |event : web_sys::Event| {  
        leptos::log!(&quot;Our custom event happened&quot;);  
  
        let bread_type = event  
            .unchecked_into::&lt;web_sys::CustomEvent&gt;()  
            .detail()  
            .as_string()  
            .unwrap_or(String::new());  
  
        leptos::log!(&quot;{:?}&quot;, bread_type );  
    };  
    view! {  
        cx,  
        &lt;BltSandwich on:orderSandwich=log_order /&gt;  
    }  
}  
  
#[component]  
fn BltSandwich(cx: Scope) -&gt; Element {  
    let dom_node_ref = NodeRef::new(cx);  
  
    let trigger_order_sandwich_event = move |event| {  
  
        let mut event_config = web_sys::CustomEventInit::new();  
        event_config.bubbles(true);  
        let bread_type = JsValue::from(&quot;Canadian Rye&quot;);  
        event_config.detail( &amp;bread_type );  
        let event = web_sys::CustomEvent::new_with_event_init_dict(  
            &quot;orderSandwich&quot;,  
            &amp;event_config  
        );  
  
        match event {  
            Ok(event) =&gt; {  
                match dom_node_ref.get() {  
                    None =&gt; {}  
                    Some(dom_element) =&gt; {  
                        match dom_element.dispatch_event(&amp;event) {  
                            Ok(_) =&gt; { leptos::log!(&quot;Custom event sent&quot;) },  
                            Err(_) =&gt; { leptos::log!(&quot;Failed to send&quot;) }  
                        }  
                    }  
                }  
            }  
            Err(_) =&gt; {}  
        }  
    };  
    view! {  
        cx,  
        &lt;div _ref=dom_node_ref&gt;  
           &lt;h3&gt;&quot;BLT Sandwich&quot;&lt;/h3&gt;  
            &lt;button on:click=trigger_order_sandwich_event&gt;  
                &quot;Order Sandwich&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }  
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-event-module"><a class="header" href="#custom-event-module">Custom Event Module</a></h1>
<h2 id="what-we-know-13"><a class="header" href="#what-we-know-13">What we know</a></h2>
<ul>
<li>Data can be assocaited with custom events</li>
<li>There's a lot of boiler plate in with custom events</li>
</ul>
<h2 id="what-well-learn-13"><a class="header" href="#what-well-learn-13">What we'll learn</a></h2>
<ul>
<li>How to turn our code into a module that we can reuse</li>
</ul>
<h2 id="the-lesson-11"><a class="header" href="#the-lesson-11">The lesson</a></h2>
<h3 id="module-basics"><a class="header" href="#module-basics">Module basics</a></h3>
<p>Rust has the ability to create modules to encapsulate code. It allows you to expose parts of the code to the outside world, while keeping other parts of the code private to the module. </p>
<p>A module is defined by using the key word <code>mod</code> followed by the name of the module and curley braces which encapsulate the code in a module.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod my_module {  
	pub fn hello_world() {
		println!(&quot;Hi&quot;);
	}
	fn you_cant_call_me() {
		println!(&quot;Seeecrets&quot;);
	}
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>We've seen this pattern of <code>set the context</code> then <code>noun</code> the <code>content/definition</code> all over the place. These patterns repeat all over the place.</p>
</blockquote>
<p>The module can be used in the scope in which it is defined without any extra work. We must prefix functions with 'pub' in a module to specify that they are public. Functions in a module have access to private functions that are within the module because they're all in the same module scope. Calling a function inside a module requires you to specify the module's namespace followed by two colons and the function name. </p>
<pre><pre class="playground"><code class="language-rust">mod my_module {  
	pub fn hello_world() {
		println!(&quot;Hi&quot;);
	}
	fn you_cant_call_me() {
		println!(&quot;Seeecrets&quot;);
	}
}

fn main() {  
    // ✅ We can call this public function
    my_module::hello_world();
    
    // ❌ We can't call this private function
    my_module::you_cant_call_me();
}</code></pre></pre>
<h4 id="module-files"><a class="header" href="#module-files">Module files</a></h4>
<p>Modules can be moved to their own files as well. </p>
<ol>
<li>Create a my_module.rs file in the ./src folder fo your application</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn hello_world() {
	println!(&quot;Hi&quot;);
}
fn you_cant_call_me() {
	println!(&quot;Seeecrets&quot;);
}
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li>Bring it into scope in your ./src/main.rs file with <code>mod my_module</code> which will automatically hook up the file my_module.rs</li>
</ol>
<pre><pre class="playground"><code class="language-rust">mod my_module;

fn main() {  
    my_module::hello_world();
}</code></pre></pre>
<p>Now, while you can do this, it's not ideal. </p>
<h3 id="librs"><a class="header" href="#librs">lib.rs</a></h3>
<p>The preferred orgnization is to create a lib.rs file, which is the entry point to your crate's functionality. It is called lib because it is a library of functionality and isn't intended to be directly executed. We'll deal with the details of this later. For this lesson we're going to create the module in the same main.rs file as your example application.</p>
<h2 id="the-refactor"><a class="header" href="#the-refactor">The refactor</a></h2>
<p>We started off with the following from a previous lesson:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
use crate::wasm_bindgen::JsValue;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;SandwichShopApp /&gt;  
        }  
    })  
}  
  
#[component]  
fn SandwichShopApp(cx: Scope) -&gt; Element {  
    let log_order = |event : web_sys::Event| {  
        leptos::log!(&quot;Our custom event happened&quot;);  
  
        let bread_type = event  
            .unchecked_into::&lt;web_sys::CustomEvent&gt;()  
            .detail()  
            .as_string()  
            .unwrap_or(String::new());  
  
        leptos::log!(&quot;{:?}&quot;, bread_type );  
    };  
    view! {  
        cx,  
        &lt;BltSandwich on:orderSandwich=log_order /&gt;  
    }  
}  
  
#[component]  
fn BltSandwich(cx: Scope) -&gt; Element {  
    let dom_node_ref = NodeRef::new(cx);  
  
    let trigger_order_sandwich_event = move |event| {  
  
        let mut event_config = web_sys::CustomEventInit::new();  
        event_config.bubbles(true);  
        let bread_type = JsValue::from(&quot;Canadian Rye&quot;);  
        event_config.detail( &amp;bread_type );  
        
        let event = web_sys::CustomEvent::new_with_event_init_dict(  
            &quot;orderSandwich&quot;,  
            &amp;event_config  
        );  
  
        match event {  
            Ok(event) =&gt; {  
                match dom_node_ref.get() {  
                    None =&gt; {}  
                    Some(dom_element) =&gt; {  
                        match dom_element.dispatch_event(&amp;event) {  
                            Ok(_) =&gt; { leptos::log!(&quot;Custom event sent&quot;) },  
                            Err(_) =&gt; { leptos::log!(&quot;Failed to send&quot;) }  
                        }  
                    }  
                }  
            }  
            Err(_) =&gt; {}  
        }  
        
    };  
    view! {  
        cx,  
        &lt;div _ref=dom_node_ref&gt;  
           &lt;h3&gt;&quot;BLT Sandwich&quot;&lt;/h3&gt;  
            &lt;button on:click=trigger_order_sandwich_event&gt;  
                &quot;Order Sandwich&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }  
}</code></pre></pre>
<p>We'll start by making a module.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod component_custom_event {
	
}
<span class="boring">}</span></code></pre></pre>
<p>For the time being we'll remove the complexity of dealing with the event data, omitting the following lines:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bread_type = JsValue::from(&quot;Canadian Rye&quot;);  
event_config.detail( &amp;bread_type );  
<span class="boring">}</span></code></pre></pre>
<p>How it's time to start moving things into the module and generalizing them or making them configurable. </p>
<p>I could see myself annotating the following code with a comment like <code>//first create a custom event</code>. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	let mut event_config = web_sys::CustomEventInit::new();  
	event_config.bubbles(true);  
	
	let event = web_sys::CustomEvent::new_with_event_init_dict(  
		&quot;orderSandwich&quot;,  
		&amp;event_config  
	);  
  
<span class="boring">}</span></code></pre></pre>
<p>This immediately tells me that there's a name I can give to these lines that summarizes them. We're creating a new custom event. We do need to give this new event a name, which instantly makes me think, &quot;Name is a parameter!&quot; We also know that <code>new_with_event_init_dict()</code> returns a Result type, which we handled before with our match statement. </p>
<p>Let's start by stubbing out the definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod component_custom_event {
	fn new(name: &amp;str) -&gt; Result&lt;web_sys::CustomEvent, JsValue&gt; {  
		// do stuff
	}
<span class="boring">}</span></code></pre></pre>
<p>If this worked we could use <code>component_custom_event::new(&quot;orderSandwich&quot;)</code> and we should get what we expect to continue in our event handler.</p>
<p>A module is a separate scope. It acts in a similar way to main.rs, which has it's own scope. Rust is very good at being congruent like that.  web_sys and JsValue aren't defined in the module. To fix this we'll add some use statements.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use leptos::*;  //web_sys is imported as part of leptos's prelude
use leptos::wasm_bindgen::JsValue;
<span class="boring">}</span></code></pre></pre>
<p>Let's copy the code block in as the body:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod component_custom_event {
	use leptos::*;  
	use leptos::wasm_bindgen::JsValue;

	fn new(name: &amp;str) -&gt; Result&lt;web_sys::CustomEvent, JsValue&gt; {  
	    let mut event_config = web_sys::CustomEventInit::new();  
	    event_config.bubbles(true);  
	    let event = web_sys::CustomEvent::new_with_event_init_dict(  
			&quot;orderSandwich&quot;,  
			&amp;event_config  
		);  
	}
}
<span class="boring">}</span></code></pre></pre>
<p>And, we need to hook up our property so that it's arguments are used in the events configuration. To do this we need to replace the literal &quot;orderSandwich&quot; with name. Now the value of the <code>name</code> function parameter will be used as the event's <code>name</code>, passed as the first argument to <code>new_with_event_init_dict()</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod component_custom_event {
	
	fn new(name: &amp;str) -&gt; Result&lt;web_sys::CustomEvent, JsValue&gt; {  
	    let mut event_config = web_sys::CustomEventInit::new();  
	    event_config.bubbles(true);  
	    let event = web_sys::CustomEvent::new_with_event_init_dict(  
			name, 
			&amp;event_config  
		);  
	}
}
<span class="boring">}</span></code></pre></pre>
<p>But we're not quite done here. We have an assignment for the last expression with <code>let event =</code>. And the last expression has a semicolon <code>;</code> at the end. This would result in the new function returning a unit type, written as <code>()</code>. If we want to return the event we could write <code>event</code> at the end, without a semicolon, so that it would be the &quot;last word&quot; in the function. Recall that Rust is expression based and the last open expression is used as the return of functions and scope blocks (unless you write <code>return</code> and provide it something to explicitly return). Let's remove the assignment and semicolon, and we're done with this one.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod component_custom_event {
	
	fn new(name: &amp;str) -&gt; Result&lt;web_sys::CustomEvent, JsValue&gt; {  
		// configuration
	    let mut event_config = web_sys::CustomEventInit::new();  
	    event_config.bubbles(true);  
		// generation
	    web_sys::CustomEvent::new_with_event_init_dict(  
			name, 
			&amp;event_config  
		)
	}
}
<span class="boring">}</span></code></pre></pre>
<p>You might be tempted to try to do some form of chaining or nesting to make this even smaller. But <code>CustomEventInit::new()</code> returns a value that we need to mutate. It's the most clear to separate out the configuration stage from the custom event generation stage.</p>
<p>So now, my custom event dispatcher/handler looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let trigger_order_sandwich_event = move |event| {  
		
		component_custom_event::new(&quot;orderSandwich&quot;);
  
        match event {  
            Ok(event) =&gt; {  
                match dom_node_ref.get() {  
                    None =&gt; {}  
                    Some(dom_element) =&gt; {  
                        match dom_element.dispatch_event(&amp;event) {  
                            Ok(_) =&gt; { leptos::log!(&quot;Custom event sent&quot;) },  
                            Err(_) =&gt; { leptos::log!(&quot;Failed to send&quot;) }  
                        }  
                    }  
                }  
            }  
            Err(_) =&gt; {}  
        }  
        
    };  
<span class="boring">}</span></code></pre></pre>
<p>I'm looking at this and that whole <code>match event</code> block really looks like it summarizes as &quot;send event&quot;. In fact, it feels like that's what I'm doing with this whole thing. I'm just dispatching a custom event on a specific node, through it's reference.</p>
<p>Maybe what I'm looking for is something like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let trigger_order_sandwich_event = move |event| {  
	component_custom_event::dispatch(&quot;orderSandwich&quot;, dom_node_ref);
}
<span class="boring">}</span></code></pre></pre>
<p>Yeah, that's starting to look good! That says what I want to happen.</p>
<p>Now let's write the how. We'l start with defining a new function in the module. The name is going to pass right through, and we'll accept a NodeRef as a parameter. We know this because <code>NodeRef::new(cx)</code> returns a NodeRef type. If you got this wrong, Rust will actually inform you, &quot;Oh, you tried to use a NodeRef where your dispatch method was expecting a (whatever type you used).&quot; Our return type will be the same return type as <code>EventTarget.dispatch_event()</code>. We'll try to not deviate from the interface used in the standard methods. This will help us use these interchangably in the future.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in mod component_custom_event {
pub fn dispatch( name: &amp;str, target_ref : NodeRef) -&gt; Result&lt;bool, JsValue&gt;{

}
<span class="boring">}</span></code></pre></pre>
<p>Now we need to create our new event from the name, and we need to send the event with our node ref. Our node ref needs to be converted into a target because we can only call dispatch_event methods on <code>EventTarget</code> type values.</p>
<p>And so we create a new event:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let event = new(name);  
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>We can just write <code>new</code> because <code>new</code> is defined in the local module scope! This is a great example of why modules are so convenient. They're like structs that have no data and only have class methods.</p>
</blockquote>
<p>And we create our target from the reference:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let target = target_ref.get();  
<span class="boring">}</span></code></pre></pre>
<p>Now, here's a really cool part. <code>event</code> is a <code>Result</code> and <code>target</code> is an <code>Option</code>. We know this because we defined the return type for the <code>new()</code> function. We can look up the return type of NodeRef.get(). We only want to dispatch the event if our event is valid and we have a target to send it on. Rust allows you to create tuples (groups of values where their type is known at specific locations) which we can use in matchs statements. They're like super powered pattern matching if statements.</p>
<p>We can create a <code>match</code> for a tuple with <code>event</code> and <code>target</code> to do something if both are Ok() and Some() respectively!</p>
<p>Take a look at this.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match (event, target) {  
	// We are matching on the Result and Option enums
	// and we're destructuring, all in one step!
	( Ok(event), Some(target) ) =&gt; target.dispatch_event(&amp;event),  
	// The underscore indicates any other option that didn't match.
	// You can think of it as any other possible value that is a 
	// valid value within the type (recall that types jsut define 
	// the bounds of valid values)
	(_,_) =&gt; Err(JsValue::null())  
}  
<span class="boring">}</span></code></pre></pre>
<p>Out whole method is finished!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn dispatch( name: &amp;str, target_ref : NodeRef) -&gt; Result&lt;bool, JsValue&gt;{  
  
    let event = new(name);  
    let target = target_ref.get();  
  
    match (event, target) {  
        ( Ok(event), Some(target) ) =&gt; target.dispatch_event(&amp;event),
        (_,_) =&gt; Err(JsValue::null())  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>A new things to note here is that match is the last statement in the dispatch method. The result of will be used as the return value. In our match arms, we don't include semiconons because we want those match arms to become the evaluated value of the match statement, which becomes the evaluated value of the dispatch method. It sounds complicated at first, but if you take your time to read it carefully it'll click and the beauty of this will shine through.</p>
<p>There are also a few interesting Rust syntax things here that might have you scratching your head.</p>
<ol>
<li>We use <code>event</code> in <code>match (event,target)</code> but then we also use <code>event</code> in the match arm's destructuring statement <code>( Ok(event), Some(target) )</code> and we use <code>&amp;event</code> in the match arm's body. We can do this because we're actually reassigning <code>event</code> to a different value as we go along. This is called <code>variable shadowing</code>. We can use <code>event</code> to evaluate the match arms. When evaluating the body of the match arm, Rust will destructure and assign the values stored in the <code>Ok()</code> and <code>Some()</code> enums to their <code>event</code> and <code>target</code> names respectively.</li>
<li>We've removed the curley brances from the branch arms. Rust allows us to drop curley brances for match arms if the contents of an arm's body is a single statement. It just helps keep visual clutter down.</li>
</ol>
<p>And like that, we're done.</p>
<p>If we look at our whole component, it's very easy to see the behaviour. We're able to focus on what is happening and not how it's happening. This is the power of declarative code. It allows our mind to think at one level of detail.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
mod component_custom_event {  
    use leptos::web_sys;  
    use leptos::wasm_bindgen::JsValue;  
  
    fn new(name: &amp;str) -&gt; Result&lt;web_sys::CustomEvent, JsValue&gt; {  
        // configuration  
        let mut event_config = web_sys::CustomEventInit::new();  
        event_config.bubbles(true);  
        // generation  
        web_sys::CustomEvent::new_with_event_init_dict(  
            name,  
            &amp;event_config,  
        )  
    }  
  
    pub fn dispatch( name: &amp;str, target_ref : NodeRef) -&gt; Result&lt;bool, JsValue&gt;{  
  
        let event = new(name);  
        let target = target_ref.get();  
  
        match (event, target) {  
            (Ok(event), Some(target)) =&gt; {  
                target.dispatch_event(&amp;event)  
            },  
            (_,_) =&gt; Err(JsValue::null())  
        }  
    }  
}  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;SandwichShopApp /&gt;  
        }  
    })  
}  
  
#[component]  
fn SandwichShopApp(cx: Scope) -&gt; Element {  
    let log_order = |event: web_sys::Event| {  
        leptos::log!(&quot;Our custom event happened&quot;);  
    };  
    view! {  
        cx,  
        &lt;BltSandwich on:orderSandwich=log_order /&gt;  
    }  
}  
  
#[component]  
fn BltSandwich(cx: Scope) -&gt; Element {  
    let dom_node_ref = NodeRef::new(cx);  
  
    let trigger_order_sandwich_event = move |event| {  
        component_custom_event::dispatch(&quot;orderSandwich&quot;, dom_node_ref);  
    };  
    view! {  
        cx,  
        &lt;div _ref=dom_node_ref&gt;  
           &lt;h3&gt;&quot;BLT Sandwich&quot;&lt;/h3&gt;  
            &lt;button on:click=trigger_order_sandwich_event&gt;  
                &quot;Order Sandwich&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }  
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-event-module-with-data"><a class="header" href="#custom-event-module-with-data">Custom event module with data</a></h1>
<h2 id="what-we-know-14"><a class="header" href="#what-we-know-14">What we know</a></h2>
<ul>
<li>Data can be assocaited with custom events</li>
<li>We can hide the complexity of creating custom events behind an easy to use function inside a module.</li>
</ul>
<h2 id="what-well-learn-14"><a class="header" href="#what-well-learn-14">What we'll learn</a></h2>
<ul>
<li>How to add data to our module.</li>
</ul>
<h2 id="the-lesson-12"><a class="header" href="#the-lesson-12">The lesson</a></h2>
<p>In a previous lesson we created a module that made dispatching a custom event super easy. We discussed adding data to events before and how useful it is, but we can't add data to be disptched with the events in our custom event module. We should fix that!</p>
<p>Our simple module looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod component_custom_event {  
    use leptos::web_sys;  
    use leptos::wasm_bindgen::JsValue;  
  
    fn new(name: &amp;str) -&gt; Result&lt;web_sys::CustomEvent, JsValue&gt; {  
        // configuration  
        let mut event_config = web_sys::CustomEventInit::new();  
        event_config.bubbles(true);  
        // generation  
        web_sys::CustomEvent::new_with_event_init_dict(  
            name,  
            &amp;event_config,  
        )  
    }  
  
    pub fn dispatch( name: &amp;str, target_ref : NodeRef) 
    -&gt; Result&lt;bool, JsValue&gt;{  
  
        let event = new(name);  
        let target = target_ref.get();  
  
        match (event, target) {  
            (Ok(event), Some(target)) =&gt; {  
                target.dispatch_event(&amp;event)  
            },  
            (_,_) =&gt; Err(JsValue::null())  
        }  
    }  
}  
<span class="boring">}</span></code></pre></pre>
<h3 id="adding-jsvalue-data-to-the-event"><a class="header" href="#adding-jsvalue-data-to-the-event">Adding JsValue data to the event</a></h3>
<p>I have an example from a previous lesson where I added a payload to an event through the details method on the event configuration. Let's add that back in. </p>
<p>The first step is adding a new parameter to the <code>new</code> function which allows us to get a JsValue in there.</p>
<p>We'll add an Option, because sometimes we might not have a payload. Alternately we could create a function called 'new_with_payload' but this is fine.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn new(name: &amp;str, payload: Option&lt;JsValue&gt;) -&gt; Result&lt;web_sys::CustomEvent, JsValue&gt; 
<span class="boring">}</span></code></pre></pre>
<p>Then we'll conditionally add it to the event_config if we're given Some(data) for the payload.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(data) = payload {  
	event_config.detail(&amp;data);  
}  
<span class="boring">}</span></code></pre></pre>
<p>All finished, we have this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn new(name: &amp;str, payload: Option&lt;JsValue&gt;) -&gt; Result&lt;web_sys::CustomEvent, JsValue&gt; {  
    let mut event_config = web_sys::CustomEventInit::new();  
    event_config.bubbles(true);  
    if let Some(data) = payload {  
        event_config.detail(&amp;data);  
    }  
    web_sys::CustomEvent::new_with_event_init_dict(name, &amp;event_config)  
}
<span class="boring">}</span></code></pre></pre>
<h3 id="simplified-sending-methods-api"><a class="header" href="#simplified-sending-methods-api">Simplified sending methods (API)</a></h3>
<p>There is no way to specify a default parameter value in Rust. We want our api to be simple and declarative. We don't want to force people to always provide &quot;None&quot; if they're not including a payload. To fix this we can make a private method called real_dispatch and then a public method to dispatch and event without and with a payload respectively, called <code>dispatch</code> and <code>dispatch_with_data</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn real_dispatch( 
	name: &amp;str, 
	target_ref : NodeRef, 
	payload: Option&lt;JsValue&gt;
	) -&gt; Result&lt;bool, JsValue&gt;{  
  
    let event = new(name, payload);  
    let target = target_ref.get();  
  
    match (event, target) {  
        (Ok(event), Some(target)) =&gt; {  
            target.dispatch_event(&amp;event)  
        },        (_,_) =&gt; Err(JsValue::null())  
    }
}

pub fn dispatch( 
	name: &amp;str, 
	target_ref : NodeRef
	) -&gt; Result&lt;bool, JsValue&gt;{  
    real_dispatch( name, target_ref, None)  
}

pub fn dispatch_with_data( 
	name: &amp;str, 
	target_ref : NodeRef, 
	data: JsValue
	) -&gt; Result&lt;bool, JsValue&gt;{  
    real_dispatch( name, target_ref, Some(data))  
}
    
<span class="boring">}</span></code></pre></pre>
<p>While we're at it, let's add a function to grab the value a bit more easily too:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn extract_data( event: web_sys::Event) -&gt; JsValue {  
    event
	    .unchecked_into::&lt;web_sys::CustomEvent&gt;()
	    .detail()  
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>We've seen this in a prior lesson. Were just packaging it as part of the module here.</p>
</blockquote>
<h3 id="structured-data"><a class="header" href="#structured-data">Structured Data</a></h3>
<p>Here's where things get interestng. We probably don't to just send a single value. We might want to send a few values. If we went back to our BLT example, maybe we want to send a struct of the whole BLT Sandwich config.</p>
<p>JavaScript requires everything to be sent as text. We need a way to convert structured data into a sequence of characters that can faithfully represent it. The process of producing this is called serialization. Converting data from a serialized representation to it's typed and structured form is called deserialization. </p>
<p>Currently what we have will allow us to send stuctured data but it's on the application developer to serialize data and convert it into a JsValue for use with <code>dispatch_with_data()</code>. I think it would be convenient to do this for them so that they don't have to think about serialization. </p>
<p>Let's start by adding a new function. I don't know what the type of data will be so I'm writing UNKNOWN for the sake of this example. This is not a Rust thing. It's just for you, the reader, to help you follow my thought process.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn dispatch_with_data_serialized(  
    name: &amp;str,  
    target_ref : NodeRef,  
    data: UNKNOWN
    ) -&gt; Result&lt;bool, JsValue&gt;{  
	// ..
}
<span class="boring">}</span></code></pre></pre>
<p>I did some searching and found a great crate called &quot;serde&quot; which received it's name from ser-ialize de-serialize. It turns out that there is a version of serde specifically designed to work with wasm, which is supposidly more efficient than converting structured data into JSON (JavaScript Object Notation) and it gives us a JsValue! How great is that!</p>
<p>I've added the dependency to cargo.toml as such:</p>
<pre><code class="language-toml">serde-wasm-bindgen = &quot;0.4&quot;
</code></pre>
<p>And now I can author the body of the function which is actually realtively simple:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match serde_wasm_bindgen::to_value(data) {  
	Ok(data) =&gt; dispatch_with_data( name, target_ref, data),
	Err(_) =&gt; Err( JsValue::null() )  
}
<span class="boring">}</span></code></pre></pre>
<p>We're matching on the result of converting a reference of our data to the JsValue, if it's ok, we destructure it and return the result of dispatch_with_data, otherwise we'll return a null JsValue as an error. </p>
<p>Again, recall that we're keeping the return types the same as <code>EventTarget.dispatch()</code>.</p>
<p>We're not quite done though. We don't know what type to put for the data. Rust requires that we specific the type so that it can verify that we're calling the appropriate methods on it, and correctly managing memory for it.</p>
<p>To do this we'll revisit type generics, which are those type arguments that I talked about before. They're like parameters/variables but for types. People often use 'T' as a character for a generic 'Type' but you can actually use anything you want that isn't a reserved word. I'm going to use <code>Data</code>. Note that <code>data</code> is the parameter name and <code>Data</code> is the generic type name. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn dispatch_with_data_serialized&lt;Data&gt;(  
    name: &amp;str,  
    target_ref : NodeRef,  
    data: &amp;Data
    ) -&gt; Result&lt;bool, JsValue&gt;{  
    //....
}
<span class="boring">}</span></code></pre></pre>
<p>Here we're saying, a generic will be used called <code>Data</code> and the property <code>data</code> will be whatever type <code>Data</code> is, as a referenced value. We're telling Rust, this type can change.</p>
<p>As is, Rust will complain because we're using the value of <code>data</code> as an argument for  <code>serde_wasm_bindgen::to_value()</code>. Rust wants to confirm that whatever is being stored in <code>data</code>, accepted through the function call, can be safely passed to that <code>serde_wasm_bindgen::to_value()</code> function, meeting its type requirements.</p>
<p>Let's look at the definition of <code>serde_wasm_bindgen::to_value()</code> for a clue. It reads as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn to_value&lt;T: serde::ser::Serialize + ?Sized&gt;(value: &amp;T) -&gt; Result&lt;JsValue&gt; {
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Translation: &quot;Whatever you pass as the value of <code>value</code>  must be a reference to T. T is any value whoes type implements the the serde::ser::Serialize trait and is<code>Sized</code>.</p>
</blockquote>
<p>That's it. Our <code>Data</code> needs to fulfill the same type requirements as  <code>serde::ser::Serialize + ?Sized</code> The colon after 'T' indicates qualifiers for 'T'. These qualifiers are Traits. A Trait is a name that refers to a specification of behaviour/capabilities. If you've ever written object oriented code, these would be similar to interfaces. </p>
<h3 id="how-do-we-serialize-data"><a class="header" href="#how-do-we-serialize-data">How do we serialize data?</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn dispatch_with_data_serialized&lt;Data: Serialize + ?Sized&gt;(  
    name: &amp;str,  
    target_ref : NodeRef,  
    data: &amp;Data
    ) -&gt; Result&lt;bool, JsValue&gt;{  

	match serde_wasm_bindgen::to_value(data) {  
        Ok(data) =&gt; dispatch_with_data( name, target_ref, data),
        Err(_) =&gt; Err( JsValue::null() )  
	}
}
<span class="boring">}</span></code></pre></pre>
<p>Serde is included in Leptos and adds support for a bunch of types out of the box. We can also add serialization support for our own types with a macro.  Writing <code>#[derive(Serialize, Deserialize)]</code>
above a struct will tell Rust to write out the functionality to enable these fetures for you. You do, howver, need to import the traits <code>Serialize</code> and <code>Deserialize</code> with the following use statement:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Serialize, Deserialize};
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>We are destructuring here in the use statement so that Serialize and Deserialize are being brought into scope from the serde crate (external module).</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug)]  
struct BLTSandwich {  
    bread: String,  
    lettuce: String,  
    tomato: String,  
    bacon: String,  
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>We're also adding Debug so that we can print this struct later in the lesson with the log macro.</p>
</blockquote>
<p>Now let's take a look at our BLT Sandwich component:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn BltSandwich(cx: Scope) -&gt; Element {  
    let dom_node_ref = NodeRef::new(cx);  
  
    let trigger_order_sandwich_event = move |event| {  
        component_custom_event::dispatch_with_data_serialized(  
            &quot;orderSandwich&quot;,  
            dom_node_ref,  
            &amp;BLTSandwich {  
                bread: &quot;canadian_rye&quot;.to_string(),  
                lettuce: &quot;romaine&quot;.to_string(),  
                tomato: &quot;black_krim&quot;.to_string(),  
                bacon: &quot;farm_smoked_apple_bacon&quot;.to_string(),  
            }        
        );  
    };  
    view! {  
        cx,  
        &lt;div _ref=dom_node_ref&gt;  
           &lt;h3&gt;&quot;BLT Sandwich&quot;&lt;/h3&gt;  
            &lt;button on:click=trigger_order_sandwich_event&gt;  
                &quot;Order Sandwich&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }
}
<span class="boring">}</span></code></pre></pre>
<p>It looks like there's one last missing piece of the pizzle. We need a function that will extract our serialized data back into our struct. We'll use as similar tactic to find the type requirements. The generic <code>Data</code> will end up in the return type as a type argument for Option. This means that the function may return Some of <code>Data</code>, which must implement the traits <code>serde::de::DeserializeOwned + ?Sized</code> or None.</p>
<p>Then we call <code>from_value()</code>, match it to handle a potential error and return our option types as the result of the match arm expressions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn extract_serialized_data&lt;Data: serde::de::DeserializeOwned + ?Sized&gt;(event: web_sys::Event) -&gt; Option&lt;Data&gt; {  
    match serde_wasm_bindgen::from_value(extract_data(event)) {  
        Ok(data) =&gt; Some(data),  
        Err(_) =&gt; None  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>When using this function we need to provide it the type for <code>Data</code> which we can do with our type argument syntax, for example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>component_custom_event::extract_serialized_data::&lt;BLTSandwich&gt;(event)
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>The ::&lt;&gt; is a turbofish and used to inject a concrete type as an argument for a generic.</p>
</blockquote>
<h3 id="wrapping-it-up"><a class="header" href="#wrapping-it-up">Wrapping it up</a></h3>
<p>Here we have a working example of the whole thing!</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
use serde::{Serialize, Deserialize};  
  
mod component_custom_event {  
    use leptos::*;  
    use crate::wasm_bindgen::JsValue;  
  
    fn new(name: &amp;str, payload: Option&lt;JsValue&gt;) -&gt; Result&lt;web_sys::CustomEvent, JsValue&gt; {  
        let mut event_config = web_sys::CustomEventInit::new();  
        event_config.bubbles(true);  
        if let Some(data) = payload {  
            event_config.detail(&amp;data);  
        }  
        web_sys::CustomEvent::new_with_event_init_dict(name, &amp;event_config)  
    }  
    fn real_dispatch(name: &amp;str, target_ref: NodeRef, payload: Option&lt;JsValue&gt;) -&gt; Result&lt;bool, JsValue&gt; {  
        let event = new(name, payload);  
        let target = target_ref.get();  
  
        match (event, target) {  
            (Ok(event), Some(target)) =&gt; target.dispatch_event(&amp;event),  
            (_, _) =&gt; Err(JsValue::null())  
        }    }  
    pub fn dispatch(name: &amp;str, target_ref: NodeRef) -&gt; Result&lt;bool, JsValue&gt; {  
        real_dispatch(name, target_ref, None)  
    }  
    pub fn dispatch_with_data(name: &amp;str, target_ref: NodeRef, data: JsValue) -&gt; Result&lt;bool, JsValue&gt; {  
        real_dispatch(name, target_ref, Some(data))  
    }  
    pub fn dispatch_with_data_serialized&lt;T: serde::ser::Serialize + ?Sized&gt;(  
        name: &amp;str,  
        target_ref: NodeRef,  
        data: &amp;T) -&gt; Result&lt;bool, JsValue&gt; {  
        match serde_wasm_bindgen::to_value(data) {  
            Ok(data) =&gt; dispatch_with_data(name, target_ref, data),  
            Err(_) =&gt; Err(JsValue::null())  
        }    }  
    pub fn extract_data(event: web_sys::Event) -&gt; JsValue {  
        let custom_event = event.unchecked_into::&lt;web_sys::CustomEvent&gt;();  
        custom_event.detail()  
    }  
    pub fn extract_serialized_data&lt;Data: serde::de::DeserializeOwned + ?Sized&gt;(event: web_sys::Event) -&gt; Option&lt;Data&gt; {  
        match serde_wasm_bindgen::from_value(extract_data(event)) {  
            Ok(data) =&gt; Some(data),  
            Err(_) =&gt; None  
        }  
    }}  
  
#[derive(Serialize, Deserialize, Debug)]  
struct BLTSandwich {  
    bread: String,  
    lettuce: String,  
    tomato: String,  
    bacon: String,  
}  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;SandwichShopApp /&gt;  
        }    })}  
  
#[component]  
fn SandwichShopApp(cx: Scope) -&gt; Element {  
    let log_order = |event: web_sys::Event| {  
        leptos::log!(&quot;Our custom event happened&quot;);  
        leptos::log!( &quot;{:?}&quot;, component_custom_event::extract_serialized_data::&lt;BLTSandwich&gt;(event));  
    };  
    view! {  
        cx,  
        &lt;BltSandwich on:orderSandwich=log_order /&gt;  
    }}  
  
#[component]  
fn BltSandwich(cx: Scope) -&gt; Element {  
    let dom_node_ref = NodeRef::new(cx);  
  
    let trigger_order_sandwich_event = move |event| {  
        component_custom_event::dispatch_with_data_serialized(  
            &quot;orderSandwich&quot;,  
            dom_node_ref,  
            &amp;BLTSandwich {  
                bread: &quot;canadian_rye&quot;.to_string(),  
                lettuce: &quot;romaine&quot;.to_string(),  
                tomato: &quot;black_krim&quot;.to_string(),  
                bacon: &quot;farm_smoked_apple_bacon&quot;.to_string(),  
            },        );  
    };  
    view! {  
        cx,  
        &lt;div _ref=dom_node_ref&gt;  
           &lt;h3&gt;&quot;BLT Sandwich&quot;&lt;/h3&gt;  
            &lt;button on:click=trigger_order_sandwich_event&gt;  
                &quot;Order Sandwich&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-event-data-with-signals"><a class="header" href="#custom-event-data-with-signals">Custom Event Data with Signals</a></h1>
<h2 id="what-we-know-15"><a class="header" href="#what-we-know-15">What we know</a></h2>
<ul>
<li>Events allow us to signal changes on the client side (in browser)</li>
<li>Attaching handlers (listeners) to events in the DOM has non trivial performance cost</li>
<li>Custom events have the ability to add data to them in the form of <em>details</em>.</li>
<li>Serializing and deserializing data to transport it between JavaScript and WASM has a non trivial performance cost </li>
<li>Events can bubble up from the target (the dispatcher) node to be handled by parent/ancestral DOM node's handlers.</li>
<li>Event handlers can be passed down as properties to Leptos components</li>
</ul>
<h2 id="what-well-learn-15"><a class="header" href="#what-well-learn-15">What we'll learn</a></h2>
<ul>
<li>How we can listen to signal value changes and respond with actions using <em>effects</em></li>
</ul>
<h2 id="the-lesson-13"><a class="header" href="#the-lesson-13">The lesson</a></h2>
<h3 id="why-bother"><a class="header" href="#why-bother">Why bother?</a></h3>
<p>It's possible to use events that exist inside your Rust application instead of relying heavily on the browser's event system. There are some major benefits that you receive by doing this. </p>
<p>First, you can use data in your events that isn't serializable. Recalll that JavaScript events have details, but the data assigned to it has to be able to be turned into a string. It has to be serializable. Functions and few other data types can not be serialized. Handling events in rust solves this problem.</p>
<p>Secondly, serializing and deserializing data is costly. If we're handling an event in rust, serializing the details (data/payload) and then dispatching it to handle it in rust a few ms later, we're better off to just keep it all in Rust.</p>
<p>Thirdly, passing data across the WASM boundary isn't very efficient in browsers yet.</p>
<p>Fourthly, I'm sure there are other reasons.</p>
<h3 id="our-objectives"><a class="header" href="#our-objectives">Our objectives</a></h3>
<p>We'll use a sandwich shop as our example for this lesson. We'll aim to create a simple application that accepts an order which the system/application can choose to react to. Think of it like a server taking the order and relaying it to the kitchen.</p>
<h3 id="boilerplate"><a class="header" href="#boilerplate">Boilerplate</a></h3>
<p>Let's start off with some basic components for our sandwich shop.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;SandwichShop /&gt;  
        }    
	})
}  
  
#[component]  
fn SandwichShop(cx: Scope) -&gt; Element {  
  
    view! {  
        cx,  
        &lt;div&gt;  
            &lt;Sandwich/&gt;  
        &lt;/div&gt;  
    }
}  
  
#[component]  
fn Sandwich(cx: Scope) -&gt; Element{  
    view! {  
        cx,  
        &lt;div&gt;  
           &lt;button&gt;  
                &quot;Order Sandwich&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }
}</code></pre></pre>
<p>We'll need something to capture the initial client side event. To do this we can add an event handler for the <code>click</code> event.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn Sandwich(cx: Scope) -&gt; Element{  
    let place_order = |_|{  
        leptos::log!(&quot;Place order&quot;);  
    };  
    view! {  
        cx,  
        &lt;div&gt;  
           &lt;button on:click=place_order&gt;  
                &quot;Order Sandwich&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We're just echoing out &quot;Place order&quot; to the browser console on click to make sure the event is dispatching correctly</p>
<h3 id="shared-data"><a class="header" href="#shared-data">Shared data</a></h3>
<p>Here's where things get interesting. We need some sort of shared space where we can write down that an order came in. We'll then make sure that a bell gets run to say, &quot;order up&quot; for the kitchen staff to check the order. </p>
<p>We'll use Leptos' reactive system to create that shared bit of data. Using signals we can read and write to the space with orders as the buttons are clicked. </p>
<p>We're going to simplify and ignore some edge cases and assume that an order can be fulfilled the second it comes in. This lesson is more about message orchestration than anything else. </p>
<p>With that in mind, if we create a signal, the setter could be called &quot;new order&quot; because it's adding the order to the shared/observed space. We can call the getter &quot;last order&quot; because the value of the shared space will always be the most recent just fulfilled order.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (  
    last_order,  
    new_order  
) = create_signal(cx, None);
<span class="boring">}</span></code></pre></pre>
<p>You'll note that I wrote None here because we're going to use an Option type for what the order is. In fact, it'll be <code>Option&lt;Sandwiches&gt;</code>;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Sandwich{  
    BLT
}
<span class="boring">}</span></code></pre></pre>
<p>If we tried to compile our application Rust would complain. Currently rust doesn't know how much memory to allocate for create_signal because it's Some type isn't specified. We can add this to the None with our handy trubofish syntax.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (  
    last_order,  
    new_order  
) = create_signal(cx, None::&lt;Sandwich&gt;);
<span class="boring">}</span></code></pre></pre>
<p>Now we want to pass the <code>new_order</code> write signal to our Sandwich Leptos component. It's going to use this to place orders when the respective button is clicked.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn SandwichShop(cx: Scope) -&gt; Element {  
  
    let (  
        last_order,  
        new_order  
    ) = create_signal(cx, None::&lt;Sandwich&gt;);  
  
    view! {  
        cx,  
        &lt;div&gt;  
            &lt;Sandwich new_order=new_order /&gt;  
        &lt;/div&gt;  
    }}
<span class="boring">}</span></code></pre></pre>
<p>And we'll add the property to the Sandwich component's function definition so that it can accept the write signal.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn Sandwich(
	cx: Scope, 
	new_order: WriteSignal&lt;Option&lt;Sandwich&gt;&gt; 
) -&gt; Element{
	// ... 
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Note that new_order is of type <code>WriteSignal</code> which has a type argument of <code>Option&lt;Sandwich&gt;</code></p>
</blockquote>
<p>This looks a bit odd because the value and property are the same name on the Sandwich object. Leptos allows you to just write the property/name once if they're both the same. We can write </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;Sandwich new_order /&gt; 
<span class="boring">}</span></code></pre></pre>
<p>Now we need to put that WriteSignal to use. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn Sandwich(
	cx: Scope, 
	new_order: WriteSignal&lt;Option&lt;Sandwich&gt;&gt; 
) -&gt; Element{  

	let place_order = move |_| {  
	    leptos::log!(&quot;Place order&quot;);  
	    new_order.set( Some(Sandwich::BLT) );  
	};
    
    view! {  
        cx,  
        &lt;div&gt;  
           &lt;button on:click=place_order&gt;  
                &quot;Order Sandwich&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The new_order write signal enters the Sandwich component function and is moved into the place_order closure. This closure is run every time the <code>click</code> event is dispatched on the button. By doing so, it updates that shared order space with a sandwich!</p>
<h3 id="effects"><a class="header" href="#effects">Effects</a></h3>
<p>Leptos has all sorts of tricks up its sleeve. One of them is <code>create_effect</code>. You can think of <code>create_effect</code> as an on-change event handler for Leptos's reactive system. It accepts a context and closure (callback) function as its two property arguments. Use of signals within the closure will flag the closre to run if their values change. The closure will observe the signals used in it.</p>
<p>We can create an effect to observe the last and new order signals as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn SandwichShop(cx: Scope) -&gt; Element {  
  
    let (  
        last_order,  
        new_order  
    ) = create_signal(cx, None::&lt;Sandwich&gt;);
	
	create_effect(cx, move |_| {  
	    if let Some(sandwich) = last_order.get() {  
	        leptos::log!(&quot;A sandwich was ordered&quot;);  
	    }  
	});
	
	//...
}
<span class="boring">}</span></code></pre></pre>
<p>The rust compiler will complain here because the enum doesn't support clone. The statement <code>if let Some(sandwich) = last_order.get()</code> is using the signal's get() method to return a value of <code>Option&lt;Sandwich&gt;</code>. It needs to clone the data to give you a copy of it.</p>
<p>To solve this problem we can allow rust to derive the clone trait for the Sandwich enum with :</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone)]
enum Sandwich{  
    BLT
}
<span class="boring">}</span></code></pre></pre>
<p>We also want to be able to print this with debug formatting so we'll derive the debug trait too.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug)]
enum Sandwich{  
    BLT
}
<span class="boring">}</span></code></pre></pre>
<p>And just like that, we've got a working system:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
#[derive(Clone, Debug)]  
enum Sandwich{  
    BLT  
}  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;SandwichShop /&gt;  
        }
	})
}  
  
#[component]  
fn SandwichShop(cx: Scope) -&gt; Element {  
  
    let (  
        last_order,  
        new_order  
    ) = create_signal(cx, None::&lt;Sandwich&gt;);  
  
    create_effect(cx, move |_| {  
        match last_order.get() {  
            Some(sandwich) =&gt; leptos::log!(
	            &quot;A sandwich was ordered: {:?}&quot;, 
	            sandwich),  
            None =&gt; {}  
        }    
	});  
  
    view! {  
        cx,  
        &lt;div&gt;  
            &lt;Sandwich new_order /&gt;  
        &lt;/div&gt;  
    }}  
  
#[component]  
fn Sandwich(
	cx: Scope, 
	new_order: WriteSignal&lt;Option&lt;Sandwich&gt;&gt; 
) -&gt; Element{  
    let place_order = move |_|{  
        leptos::log!(&quot;Place order&quot;);  
        new_order.set( Some(Sandwich::BLT) );  
    };  
    view! {  
        cx,  
        &lt;div&gt;  
           &lt;button on:click=place_order&gt;  
                &quot;Order Sandwich&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }
}</code></pre></pre>
<h3 id="adding-other-sandwiches"><a class="header" href="#adding-other-sandwiches">Adding other sandwiches</a></h3>
<p>If we want to add additional sandwiches, we can create additional enum variants.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug)]  
enum Sandwich{  
    BLT,  
    Rubin,  
    PBandJ  
}
<span class="boring">}</span></code></pre></pre>
<p>We'll add some additional sandwiches to our order menu:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>view! {  
    cx,  
    &lt;div&gt;  
        &lt;Sandwich new_order sandwich=Sandwich::BLT/&gt;  
        &lt;Sandwich new_order sandwich=Sandwich::Rubin/&gt;  
        &lt;Sandwich new_order sandwich=Sandwich::PBandJ/&gt;  
    &lt;/div&gt;  
}
<span class="boring">}</span></code></pre></pre>
<p>And we'll add that new property 'sandwich' that we're using to configure the component.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[component]  
fn Sandwich(
	cx: Scope, 
	new_order: WriteSignal&lt;Option&lt;Sandwich&gt;&gt;, 
	sandwich: Sandwich 
) -&gt; Element{
	// ...
}
<span class="boring">}</span></code></pre></pre>
<p>And, we'll use the new argument in our on click handler.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let place_order = move |_|{  
    leptos::log!(&quot;Place order&quot;);
    new_order.set( Some(sandwich) );  
};
<span class="boring">}</span></code></pre></pre>
<p>The above won't work just yet though. When we move the sandwich argument into this closure, the rust compiler will complain. This closure is actually like a struct behind the scenes, with properties for the values moved into it. We need to clone sandwich into this struct so that the closure can guarantee that it doesn't have any ties to the outside scope. We solve this problem by calling <code>clone</code> on the sandwich. This will evaluate the value of Some() to a clone of the sandwich because the statement inside the parenthesis are evaluated first.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let place_order = move |_|{  
    leptos::log!(&quot;Place order&quot;);
    new_order.set( Some(sandwich.clone()) );  
};
<span class="boring">}</span></code></pre></pre>
<h3 id="adding-labels"><a class="header" href="#adding-labels">Adding labels</a></h3>
<p>Let's add some new properties for sandwiches for the labels.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>view! {  
    cx,  
    &lt;div&gt;  
        &lt;Sandwich new_order sandwich=Sandwich::BLT label=&quot;Bacon, Lettuce, and Tomato&quot;/&gt;  
        &lt;Sandwich new_order sandwich=Sandwich::Rubin label=&quot;Rubin&quot;/&gt;  
        &lt;Sandwich new_order sandwich=Sandwich::PBandJ label=&quot;Peanutbutter and Jelly&quot;/&gt;  
    &lt;/div&gt;  
}
<span class="boring">}</span></code></pre></pre>
<p>And then we'll add the label too the function properties and in the <code>view!</code> template:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn Sandwich(
	cx: Scope, 
	new_order: WriteSignal&lt;Option&lt;Sandwich&gt;&gt;, 
	sandwich: Sandwich, 
	label: &amp;'static str 
) -&gt; Element{  

	let place_order = move |_|{  
        leptos::log!(&quot;Place order&quot;);  
        new_order.set( Some(sandwich.clone()) );  
    };  
    
    view! {  
        cx,  
        &lt;div&gt;  
           &lt;button on:click=place_order&gt;  
                &quot;Order &quot; {label}  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }
    
}
<span class="boring">}</span></code></pre></pre>
<p>It's worth noting that I added the static lifetime to the label so that rust knows the string won't be changing as the application runs. This is important because these component functions are more like setup functions and template builders. They are not render functions.</p>
<p>And like that, we have a pretty cool system that allows us to transmit a messsage up the chain! Pretty neat!</p>
<p>In the next lesson we'll buid on this with a more robust pattern.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-event-data-with-signals-and-effects---part-2"><a class="header" href="#custom-event-data-with-signals-and-effects---part-2">Custom Event Data with Signals and Effects - Part 2</a></h1>
<h2 id="what-we-know-16"><a class="header" href="#what-we-know-16">What we know</a></h2>
<ul>
<li>We can use signals as message busses and effects as message bus watchers to react to changes in our application</li>
</ul>
<h2 id="what-well-learn-16"><a class="header" href="#what-well-learn-16">What we'll learn</a></h2>
<ul>
<li>How to create a state struct to hold application state and accept events to update the data in an application.</li>
</ul>
<h2 id="the-lesson-14"><a class="header" href="#the-lesson-14">The lesson</a></h2>
<p>In our previous lesson, our code looked like this:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
#[derive(Clone, Debug)]  
enum Sandwich{  
    BLT,  
    Rubin,  
    PBandJ  
}  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;SandwichShop /&gt;  
        }    })}  
  
#[component]  
fn SandwichShop(cx: Scope) -&gt; Element {  
  
    let (  
        last_order,  
        new_order  
    ) = create_signal(cx, None::&lt;Sandwich&gt;);  
  
    create_effect(cx, move |_| {  
        match last_order.get() {  
            Some(sandwich) =&gt; {  
                leptos::log!(&quot;A sandwich was ordered: {:?}&quot;, sandwich);  
            },  
            None =&gt; {}  
        }    });  
  
    view! {  
        cx,  
        &lt;div&gt;  
            &lt;Sandwich new_order sandwich=Sandwich::BLT label=&quot;Bacon, Lettuce. Tomato&quot;/&gt;  
            &lt;Sandwich new_order sandwich=Sandwich::Rubin label=&quot;Rubin&quot;/&gt;  
            &lt;Sandwich new_order sandwich=Sandwich::PBandJ label=&quot;Peanutbutter and Jelly&quot;/&gt;  
        &lt;/div&gt;  
    }}  
  
#[component]  
fn Sandwich(
	cx: Scope, 
	new_order: WriteSignal&lt;Option&lt;Sandwich&gt;&gt;, 
	sandwich: Sandwich, label: &amp;'static str 
) -&gt; Element{  

	let place_order = move |_|{  
        leptos::log!(&quot;Place order&quot;);  
        new_order.set( Some(sandwich.clone()) );  
    };  

	view! {  
        cx,  
        &lt;div&gt;  
           &lt;button on:click=place_order&gt;  
                &quot;Order &quot; {label}  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }
}</code></pre></pre>
<p>There are some problems  with this approach. The application component has a lot of functionality rolled into it. It would be preferrable if we could split this stuff out so that it's a bit easier to see the application logic from it's user iterface. </p>
<p>First things first, let's split our application state out from the application Leptos component. The state of our application is a snapshot of the application's data.</p>
<p>We'll also make a piece of data in the state to hold the last_event. We'll also go so far as to make an enum that stores the possible events as well.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>// Things that can happen in a sandwich shop
#[derive(Debug, Clone, Copy)]
enum Event {
	OrderSandwich(Sandwich),
	None
}

#[derive(Debug, Clone, Copy)] 
struct State { 
	last_event: Event
}
<span class="boring">}</span></code></pre></pre>
<p>We'll need an easy way to setup a default state. We can implement the default trait for the <code>State</code> struct. Recall that traits are a specification of behaviours/capabilities of a type. Traits are also types. We can use traits as bounds for argument types by writing their names as the required types for parameters.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example_trait_requirement( my_parameter: SomeTrait) { 
	//...
}
<span class="boring">}</span></code></pre></pre>
<p>Implementing the default trait on a type requires the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Default for State {  
    fn default() -&gt; Self {  
        Self {  
            last_event: Event::None  
        }  
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We now have the ability to call <code>State::default()</code> and we'll receive a <code>State</code> struct value with <code>last_event</code> set to the <code>Event</code> enum variant of <code>None</code>. This is a bit more streamlined than dealing with the option type in our previous example.</p>
<p>We also want to be able to update our state. We are going to force the updating of state through a <code>State</code> <code>update</code> method, requiring an event. This pattern of adding constraint like, &quot;You MUST have THIS to do THAT&quot; is how we make stable applications. You'll see this enforced all over the place in Rust.</p>
<p>To add functions associated with the <code>State</code> struct, we can write <code>impl</code> (for implement) <code>State</code> (the name of the struct), and define a scope with curley braces to contain the implementations of our methods. We are not writing the implementation of a Trait, so we don't need to write <code>impl TraitName for StructName</code>, like we did with the <code>Default</code> trait. It's the same idea though.</p>
<p>Our update method will take a mutable reference to itself so that it can update its own data, and it takes an event which dictates how it's own data will be updated. We then match on the events and handle the updates accordingly. At the end, we'll update the last_event with the event used for the update so that we know what happened.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl State {  
    fn update(&amp;mut self, event: Event) {  
        match event {  
            Event::OrderSandwich(sandwich) =&gt; {  
                leptos::log!(&quot;A sandwich was ordered: {:?}&quot;, sandwich);  
            },  
            Event::None =&gt; {}  
        }        
        self.last_event = event;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>As cool as all of this is, we're no further ahead. As developers we have to be careful of things that look like cool patterns but don't add any extra functionality. It's easy to get caught up in what feels satisfying to write because it's clever. Often things that are mentally taxing to write or figure out are the most stimulating. Try to avoid this siren song. Err on the side of simplicity.</p>
<p>We're now going to hook this into our reactive system so that it makes a meaningful change and we'll review the complexity to see if we've simplified our system or made it more complex.</p>
<p>Let's dig in...</p>
<p>We know when we start our app up, we're going to need to initialize a state. We want the state to handle its own updates though and we do not want the state to be rewritten. For this reason, we'll crate a signal to store a reactive value of type <code>State</code>, but we're only going to grab the read signal. </p>
<p>We need a context/scope to create the signal, and our default values.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn SandwichShop(cx: Scope) -&gt; Element {  
    let (state, _) = create_signal(cx, State::default() );
<span class="boring">}</span></code></pre></pre>
<p>This feels overly complicated. There's a lot happening here when I really want to just write, &quot;Give me a <code>State</code> struct.&quot; </p>
<p>Let's change this to something like...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let state = State::new(cx);
<span class="boring">}</span></code></pre></pre>
<p>Notice how we're distilling down a previously complicated statement into one that expresses exactly what we want. </p>
<p>Now we need to refactor our state struct to represent this. The first step is, let's just delete the whole <code>impl Default for State</code> block. We're not allowing people to create a default state anymore.</p>
<p>We do need to update our <code>State</code> implementations to include the addition of a <code>new</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl State {  
  
    pub fn new(cx: Scope) -&gt; ReadSignal&lt;State&gt; {  
        let init_state = Self {  
            cx,  
            last_event: Event::Init  
        };  
        let (state, _) = create_signal( cx, init_state );  
        state  
    }
	// ...
}
<span class="boring">}</span></code></pre></pre>
<p>You can see where we took some of the complexity of things that happened in our application and pushed it into this method. It makes our SandwichShop Leptos component 
much more simple and clear.</p>
<p>We also need to update our struct's properties so that we can store a <code>Scope</code> within the state as well.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy)]  
struct State {  
    cx: Scope,  
    last_event: Event  
}
<span class="boring">}</span></code></pre></pre>
<p>Let's turn our eyes to this <code>last_event</code> property. It also needs to be made into a signal so that we can update it and respond reactively. We'll update the struct literal syntax with a create signal call for <code>last_event</code>'s value.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new(cx: Scope) -&gt; ReadSignal&lt;State&gt; {  
    let init_state = Self {  
        cx,  
        last_event: create_signal( cx, Event::Init)  
    };  
    let (state, _) = create_signal( cx, init_state );  
    state  
}
<span class="boring">}</span></code></pre></pre>
<p>We also need to update our struct to match this new value type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy)]  
struct State {  
    cx: Scope,  
    last_event: last_event: (ReadSignal&lt;Event&gt;, WriteSignal&lt;Event&gt;)
}
<span class="boring">}</span></code></pre></pre>
<p>The last piece of this refactor is in the State <code>update</code> method. We were storing the event we were responding as the value of <code>last_event</code>. The type of this property on the <code>State</code> struct has changed. It's not an <code>Event</code> anymore. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update(&amp;mut self, event: Event) {  
        match event {  
            Event::OrderSandwich(sandwich) =&gt; leptos::log!(&quot;A sandwich was ordered: {:?}&quot;, sandwich),  
            _ =&gt; {}  
        }        
        self.last_event = event;  
    }  
<span class="boring">}</span></code></pre></pre>
<p>We need to change:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.last_event = event;  
<span class="boring">}</span></code></pre></pre>
<p>To the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.last_event.1.set( event );
<span class="boring">}</span></code></pre></pre>
<p><code>last_event</code> is a tuple with two values as index 0 and 1. Index 1 contains the write signal, which has a set method. We're using that value's set method to update the reactive value of the signal.</p>
<p>This feels unclear to me so i'll rewrite it as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	self.update_last_event( event );
<span class="boring">}</span></code></pre></pre>
<p>And create a private method on self that hides the read/write implementation feature.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_last_event( &amp;mut self, event: Event ) {  
    self.last_event.1.set(event );  
}
<span class="boring">}</span></code></pre></pre>
<p>You may notice that the previous methods had the <code>pub</code> keyword before the <code>fn</code> keyword. Excusion of the <code>pub</code> keyword for <code>update_last_event</code> prevents the method from being called by external callers. Only methods on the <code>State</code> struct can call <code>update_last_event</code>.</p>
<h3 id="updating-the-effect"><a class="header" href="#updating-the-effect">Updating the effect</a></h3>
<p>Our previous example had an effect that would respond to changes to our application's last order.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>create_effect(cx, move |_| {  
    match last_order.get() {  
        Some(sandwich) =&gt; leptos::log!(
	        &quot;A sandwich was ordered: {:?}&quot;, 
	        sandwich
			),  
        None =&gt; {}  
    }
});
<span class="boring">}</span></code></pre></pre>
<p>We actually don't need to use this anymore because we've got a state value that we can directly update and react to, all in one contained struct.</p>
<h3 id="updating-the-sandwich-components"><a class="header" href="#updating-the-sandwich-components">Updating the sandwich components</a></h3>
<p>We no longer need to pass more complicated handlers on down. We can just pass <code>state</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn SandwichShop(cx: Scope) -&gt; Element {  
    let state = State::new(cx);  
    view! {  
        cx,  
        &lt;div&gt;  
            &lt;Sandwich state sandwich=Sandwich::BLT label=&quot;Bacon, Lettuce. Tomato&quot;/&gt;  
            &lt;Sandwich state sandwich=Sandwich::Rubin label=&quot;Rubin&quot;/&gt;  
            &lt;Sandwich state sandwich=Sandwich::PBandJ label=&quot;Peanutbutter and Jelly&quot;/&gt;  
        &lt;/div&gt;  
    }}
<span class="boring">}</span></code></pre></pre>
<p>Recall that our <code>State::new()</code> gives us a read signal so that we can easily pass it around our system. We need to update our Sandwich components to match with a new property type for <code>state</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	state: ReadSignal&lt;State&gt;
<span class="boring">}</span></code></pre></pre>
<p>And we'll update the place_order closure so that it calles an update method on the actual state object.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn Sandwich(
	cx: Scope, 
	state: ReadSignal&lt;State&gt;, // &lt;- here
	sandwich: Sandwich, 
	label: &amp;'static str 
) -&gt; Element{

	let place_order = move |_|{  
	    state.get().update(Event::OrderSandwich(sandwich))  
	};
	//...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="what-remains"><a class="header" href="#what-remains">What remains</a></h3>
<p>When I had set out to do this refactor I was thinking that we'd need the <code>last_event</code> as a signal to respond to, so that we could build reactvity off of it with <code>create_effect()</code>. The reality is that in this example, we don't even actually need that. :)</p>
<p>My hope is that this lesson gives you some insight into the thought process of refactoring and adding constraint to changes.</p>
<p>Here's what the finished code looks like:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
#[derive(Debug, Clone, Copy)]  
enum Sandwich{  
    BLT,  
    Rubin,  
    PBandJ  
}  
  
#[derive(Debug, Clone, Copy)]  
enum Event {  
    OrderSandwich(Sandwich),  
    Init  
}  
  
#[derive(Debug, Clone, Copy)]  
struct State {  
    cx: Scope,  
    last_event: (ReadSignal&lt;Event&gt;, WriteSignal&lt;Event&gt;)  
}  
  
impl State {  
  
    pub fn new(cx: Scope) -&gt; ReadSignal&lt;State&gt; {  
        let init_state = Self {  
            cx,  
            last_event: create_signal( cx, Event::Init)  
        };  
        let (state, _) = create_signal( cx, init_state );  
        state  
    }  
  
    pub fn update(&amp;mut self, event: Event) {  
        match event {  
            Event::OrderSandwich(sandwich) =&gt; leptos::log!(&quot;Yay! A sandwich was ordered: {:?}&quot;, sandwich),  
            _ =&gt; {}  
        }        
        self.update_last_event(event );  
    }  
  
    fn update_last_event( &amp;mut self, event: Event ) {  
        self.last_event.1.set(event );  
    }  
  
}  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;SandwichShop /&gt;  
        }
	})
}  
  
#[component]  
fn SandwichShop(cx: Scope) -&gt; Element {  
    let state = State::new(cx);  
    view! {  
        cx,  
        &lt;div&gt;  
            &lt;Sandwich state sandwich=Sandwich::BLT label=&quot;Bacon, Lettuce. Tomato&quot;/&gt;  
            &lt;Sandwich state sandwich=Sandwich::Rubin label=&quot;Rubin&quot;/&gt;  
            &lt;Sandwich state sandwich=Sandwich::PBandJ label=&quot;Peanutbutter and Jelly&quot;/&gt;  
        &lt;/div&gt;  
    }}  
  
#[component]  
fn Sandwich(
	cx: Scope, 
	state: ReadSignal&lt;State&gt;, 
	sandwich: Sandwich, 
	label: &amp;'static str 
) -&gt; Element{  

	let place_order = move |_|{  
        state.get().update(Event::OrderSandwich(sandwich))  
    };  
    
    view! {  
        cx,  
        &lt;div&gt;  
           &lt;button on:click=place_order&gt;  
                &quot;Order &quot; {label}  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }
    
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forms"><a class="header" href="#forms">Forms</a></h1>
<h2 id="what-we-know-17"><a class="header" href="#what-we-know-17">What we know</a></h2>
<ul>
<li>We can capture events and respond to them</li>
<li>Signals allow us to persist data across events</li>
</ul>
<h2 id="what-well-learn-17"><a class="header" href="#what-well-learn-17">What we'll learn</a></h2>
<ul>
<li>How to respond to multipart form data</li>
</ul>
<h2 id="the-lesson-15"><a class="header" href="#the-lesson-15">The Lesson</a></h2>
<p>Back in the day we used to interact with websites by submitted form data to a server with a requested resource (like a specific page). The page would render, often using or processing the form data that was sent with it, would generate HTML, and then provide us a response. This is how the majority of the web still works to this day!</p>
<p>We're going to replicate a similar data flow so that you can collect sets of data using forms, but process them all on the client (in the browser).</p>
<p>We'll start with a Rad app component and some boiler plate, mounting it to the body:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;RadApp /&gt;  
        }  
    })  
}  
  
#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
    view! {  
        cx,  
        &lt;form&gt;  
        &lt;/form&gt;  
    }  
}</code></pre></pre>
<p>Our form has no submit button, so we'll add that in:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
    view! {  
        cx,  
        &lt;form&gt;  
	        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;/&gt;
        &lt;/form&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>We now have a basic form that we can submit. If we click submit, the form takes it data (of which there is none) and posts it to the form's action destination, which if non will default to the current page. This effectively looks like the page has reloaded even though it's actually being re-requesed with the updated form data.</p>
<p>Let's add a text field so that we can submit some data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;form&gt;  
	&lt;input type=&quot;text&quot;  
	    name=&quot;fav_thing_to_paint&quot;  
	    placeholder=&quot;Your fav thing to paint...&quot;  
	    value=&quot;&quot;  
	/&gt;
	&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;/&gt;
&lt;/form&gt;  
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>I broke the lines up here purely for formatting. HTML elements don't care about line breaks inbetween attributes.</p>
</blockquote>
<p>If we type in something into the text field and hit submit, you'll see the page load, and the field gets reset. What is happening here is that the form is taking its form data and submitting it to the form's action url as part of a new request. The action property is a property on the form element telling the form where to send its data. It defaults to the current page that it's on if the action is not set.</p>
<p>If we had <code>&lt;form action=&quot;https://www.rust-lang.org&quot;&gt;</code> and we clicked submit, the form would send our data to rust-lang.org! And isntead of looking like a page reload, we'd see the rust-lang.org home page.</p>
<p>We always have to remember that here we're just making a more complicated request with some configuration (the form data) and our brower is rendering the response.</p>
<p>In old school website, a server would render a template and process form submissions for that template at the same time. If a request came in without form data, the fields would be blank. If a request came in that had posted data (submitted via the form submission), whoever coded the form template which is processed on the server could pluck out that posted data, and enter in the submitted values as the values of the input fields in the form. This way form submission data doesn't get erased if, for example, some form validation failed. The data just gets passed back and forth. It is not persisting anywhere.</p>
<blockquote>
<p>Fun Fact! Forms default to 'post' as their method of sending data. You can change this method to 'get' and your data will become query string variables.</p>
</blockquote>
<h3 id="responding-to-the-event"><a class="header" href="#responding-to-the-event">Responding to the event</a></h3>
<p>Let's add a from handler for the <code>submit</code> event. But this point, things should look pretty familiar.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
	
	// We create a form handler
    let form_handler = |_|{  
        leptos::log!(&quot;The form was submitted&quot;);  
    };  

	// And we added it with `on:submit` to the form element
    view! {  
        cx,  
        &lt;form on:submit=form_handler&gt;  
            &lt;input type=&quot;text&quot;  
                name=&quot;fav_thing_to_paint&quot;  
                placeholder=&quot;Your fav thing to paint...&quot;  
                value=&quot;&quot;  
            /&gt;  
            &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;  
        &lt;/form&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<h3 id="preventing-the-form-from-sending"><a class="header" href="#preventing-the-form-from-sending">Preventing the form from sending</a></h3>
<p>When we click submit, the form submits so quickly that we can't even see the <code>form_handler</code>'s message. Also, we're working on a client side application in this context, so we don't want this page to reload and rerender. We want to <em>prevent the default behaviour</em>.</p>
<p>To do this we need to actually do something with the event in our event handler that we've been ignoring this whole time. Let's change it from an underscore to something easy to understand, like <code>submission_event</code>. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	let form_handler = |submission_event|{  
        submission_event.prevent_default();
    };  
<span class="boring">}</span></code></pre></pre>
<p>The above won't work though, because the closure doesn't know where it will be used. Rust doesn't know that this closure will be called from the event system and that the first argument will be an event. To fix this problem we'll give it a type <code>web_sys::SubmitEvent</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	let form_handler = |submission_event: web_sys::SubmitEvent|{  
        submission_event.prevent_default();
    };  
<span class="boring">}</span></code></pre></pre>
<p>Calling prevent_default() on the submit event will prevent the form from actually being submitted. We've short circuited the default behaviour!</p>
<blockquote>
<p>Sometimes I find that I don't know exactly what to write for the type so I'll put in some form of type, try to compile the application, and then let Rust's compiler tell me what was supposed to be there. It's right most of the time.</p>
</blockquote>
<h3 id="capturing-form-data"><a class="header" href="#capturing-form-data">Capturing form data</a></h3>
<p>Events have the source stored at a proeprty called <code>target</code>. We can grab the element that emitted the event by calling it. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let form_handler = |submission_event: web_sys::SubmitEvent|{  
	submission_event.prevent_default();
	let form = submission_event.target();
};  
<span class="boring">}</span></code></pre></pre>
<p>We don't know for sure if the target will actually be a proper element. The return type of the <code>target</code> method is <code>Option&lt;EventTarget&gt;</code>. As we learned in the previous lessons, we can match on the form's value to account for Some(form) or None.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let form_handler = |submission_event: web_sys::SubmitEvent|{  
    submission_event.prevent_default();  
    match submission_event.target() {  
        None =&gt; {},  
        Some(form_event_target) =&gt; {  
            // we need to do things here
		}  
    }  
};
<span class="boring">}</span></code></pre></pre>
<p>form_event_target doesn't have a specific type yet, so we need to explicitly tell Rust, &quot;Hey, this is a HtmlFormElement&quot; which we need to derive a form data object. </p>
<blockquote>
<p>It should be noted that it took research to sort through this which is why I'm presenting it to you. This way you have one place to look it all up. :)</p>
</blockquote>
<p>We're going to add the following line once we've destructured our <code>form_event_target</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let form_element = form_event_target.unchecked_ref::&lt;web_sys::HtmlFormElement&gt;();  
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Here we take our target, which is untyped and called <code>unchecked_ref()</code> to type it. We add a turbofish <code>::&lt;SomeType&gt;</code> between the name of the method and the parenthesis to specify the generic type. In this case, it's the type that it will become when we call unchecked_ref on it.</p>
</blockquote>
<p>This will fail to work, and Rust's compiler wil complain. If we look at the definition of web_sys::HtmlFormElement we'll see that it needs to be set as a feature dependency in cargo.toml.</p>
<p>We'll add the following to our cargo.toml to ensure that websys uses the two features we'll need:</p>
<pre><code class="language-toml">[dependencies.web-sys]  
features = [ &quot;FormData&quot;, &quot;HtmlFormElement&quot;]
</code></pre>
<p>Next we'll setup form data which will use data from the form element. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let form_data = web_sys::FormData::new_with_form(&amp;form_element);
<span class="boring">}</span></code></pre></pre>
<p>This returns a result type, with its return type being <code>Result&lt;FormData, JsValue&gt;</code>. As we've sen before, we'll need to destructure it to pull out the value that is of type <code>FormData</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let form_data = web_sys::FormData::new_with_form(&amp;form_element);  
match form_data{  
    Err(_) =&gt; {},  
    Ok(data) =&gt;{  
        // the data here is a FormData thing.
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>FormData has some useful methods, one of which we can use to extract values from fields by name.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fav_thing = data.get(&quot;fav_thing_to_paint&quot;).as_string();
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Here we ask the form data to give us its value for &quot;fav_thing_to_paint&quot; as a string value. This is still an option, so we'll have to deal with <code>Some(the_value)</code> or <code>None</code>.</p>
</blockquote>
<p>I'm specifically showing you pattern matchin as the simplest way to deal with these result and option types. There are many shorter ways of doing that which you will learn later.</p>
<p>It is also possible to inline the match statement and avoid assigning the temporary variable. We could write the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fav_thing = data.get(&quot;fav_thing_to_paint&quot;).as_string();  
match fav_thing {  
    Some(actual_fav_thing_value) =&gt; {},  
    None =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>or</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match data.get(&quot;fav_thing_to_paint&quot;).as_string() {  
    Some(fav_thing) =&gt; {},  
    None =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>The whole thing all together looks like this:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;RadApp /&gt;  
        }  
    })  
}  
  
#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
    let form_handler = |submission_event: web_sys::SubmitEvent|{  
        submission_event.prevent_default();  
        match submission_event.target() {  
            None =&gt; {},  
            Some(form_event_target) =&gt; {  
                let form_element = form_event_target.unchecked_ref::&lt;web_sys::HtmlFormElement&gt;();  
                let form_data = web_sys::FormData::new_with_form(&amp;form_element);  
                match form_data{  
                    Err(_) =&gt; {},  
                    Ok(data) =&gt;{  
                        match data.get(&quot;fav_thing_to_paint&quot;).as_string() {  
                            Some(fav_thing) =&gt; {  
                                leptos::log!(&quot;{:?}&quot;, fav_thing);  
                            },  
                            None =&gt; {}  
                        }  
                    }  
                }  
            }  
        }  
    };  
    view! {  
        cx,  
        &lt;form on:submit=form_handler&gt;  
            &lt;input type=&quot;text&quot;  
                name=&quot;fav_thing_to_paint&quot;  
                placeholder=&quot;Your fav thing to paint...&quot;  
                value=&quot;&quot;  
            /&gt;  
            &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;  
        &lt;/form&gt;  
    }  
}</code></pre></pre>
<h3 id="adding-signals"><a class="header" href="#adding-signals">Adding signals</a></h3>
<p>We can now create a signal and use it to store the posted/submitted data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (last_fav_thing, set_last_fav_thing) = create_signal(cx, String::new());
<span class="boring">}</span></code></pre></pre>
<p>We will add <code>move</code> to the handler, so that we can move the signal into it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let form_handler = move|submission_event: web_sys::SubmitEvent|{
<span class="boring">}</span></code></pre></pre>
<p>And we'll store the value using the signal:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>set_last_fav_thing(fav_thing);
<span class="boring">}</span></code></pre></pre>
<p>The last piece is displaying the last submission in our <code>view!</code> template:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;p&gt;&quot;Your last fav thing was: &quot; {last_fav_thing}&lt;/p&gt;
<span class="boring">}</span></code></pre></pre>
<p>All togehter we have a nice example of how to collect form data so that we can work with it!</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;RadApp /&gt;  
        }  
    })  
}  
  
#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
  
    let (last_fav_thing, set_last_fav_thing) = create_signal(cx, String::new());  
  
    let form_handler = move|submission_event: web_sys::SubmitEvent|{  
        submission_event.prevent_default();  
        match submission_event.target() {  
            None =&gt; {},  
            Some(form_event_target) =&gt; {  
                let form_element = form_event_target.unchecked_ref::&lt;web_sys::HtmlFormElement&gt;();  
                let form_data = web_sys::FormData::new_with_form(&amp;form_element);  
                match form_data{  
                    Err(_) =&gt; {},  
                    Ok(data) =&gt;{  
                        match data.get(&quot;fav_thing_to_paint&quot;).as_string() {  
                            Some(fav_thing) =&gt; {  
                                set_last_fav_thing(fav_thing);  
                            },  
                            None =&gt; {}  
                        }  
                    }  
                }  
            }  
        }  
    };  
    view! {  
        cx,  
        &lt;form on:submit=form_handler&gt;  
            &lt;p&gt;&quot;Your last fav thing was: &quot; {last_fav_thing}&lt;/p&gt;  
            &lt;input type=&quot;text&quot;  
                name=&quot;fav_thing_to_paint&quot;  
                placeholder=&quot;Your fav thing to paint...&quot;  
                value=&quot;&quot;  
            /&gt;  
            &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;  
        &lt;/form&gt;  
    }  
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storing-data-on-the-client"><a class="header" href="#storing-data-on-the-client">Storing data on the client</a></h1>
<p>Web applications have the ability to save data to/in the browser. </p>
<h2 id="available-tools"><a class="header" href="#available-tools">Available tools</a></h2>
<ul>
<li><a href="client/store_data//client/store_data/web_storage.html">Web storage: Session Storage</a></li>
<li><a href="client/store_data//client/store_data/web_storage.html">Web storage: Local Storage</a></li>
<li><a href="client/store_data//client/store_data/cookies.html">Cookies</a></li>
<li><a href="client/store_data/client/store_data/indexeddb.html">IndexedDB</a></li>
</ul>
<h2 id="example-usage"><a class="header" href="#example-usage">Example usage</a></h2>
<ul>
<li>Web Storage
<ul>
<li>Non-sensitive information</li>
<li>Application settings </li>
<li>Application state changes for offline usage</li>
</ul>
</li>
<li>Cookies
<ul>
<li>Session or user information that may change the server's respose</li>
</ul>
</li>
<li>IndexedDB
<ul>
<li>Store large amounts of data in object storage stores that can be queried with optimiztions for reading/writing</li>
</ul>
</li>
</ul>
<h2 id="comparison"><a class="header" href="#comparison">Comparison</a></h2>
<div class="table-wrapper"><table><thead><tr><th></th><th>Session Storage</th><th>Local Storage</th><th>Cookies</th></tr></thead><tbody>
<tr><td>Deleted when browser data is cleared</td><td>✅</td><td>✅</td><td>✅</td></tr>
<tr><td>Can be modified outside of your application</td><td>✅</td><td>✅</td><td>✅</td></tr>
<tr><td>Deleted when browser is closed</td><td>✅</td><td></td><td></td></tr>
<tr><td>Sent with every web request</td><td></td><td></td><td>✅</td></tr>
</tbody></table>
</div>
<h2 id="caveats"><a class="header" href="#caveats">Caveats</a></h2>
<p><strong>Persistance:</strong> We can not always guarantee that data stored on the client (in the browser) will persist. Users are in control of clearing browser caches and data stores.</p>
<p><strong>Security:</strong> Local storage and cookie data can be easily read by anyone using a web brower's development tools. There are no restrictions preventing third part scripts from accessing local storage or cookies as well. </p>
<p><strong>Guarantees:</strong> The lack of persistance and security means that we should not assume integrity of data stored in the client. </p>
<h2 id="additional-resources"><a class="header" href="#additional-resources">Additional resources</a></h2>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API">Web Storage API</a> </li>
<li><a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/cookies">Cookies Api</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API">IndexedDB Api</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="web-storage--local-storage"><a class="header" href="#web-storage--local-storage">Web Storage / Local Storage</a></h1>
<blockquote>
<p>For more information visit the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API">MDN Web Storage API documentation</a></p>
</blockquote>
<h2 id="what-we-know-18"><a class="header" href="#what-we-know-18">What we know</a></h2>
<ul>
<li>How to setup basic event handlers in Leptos</li>
</ul>
<h2 id="what-well-learn-18"><a class="header" href="#what-well-learn-18">What we'll learn</a></h2>
<ul>
<li>How to store and retrieve data from a domain's local storage in the client</li>
</ul>
<h2 id="whats-missing"><a class="header" href="#whats-missing">What's missing</a></h2>
<ul>
<li>Type safety guarantees for non-string types</li>
<li>Session storage and local persistant storage</li>
</ul>
<h2 id="caveats-1"><a class="header" href="#caveats-1">Caveats</a></h2>
<ul>
<li>Local storage can be modified by users and other applications running on the same domain. As with pretty much everything happening on the client, you can't trust it.</li>
</ul>
<h2 id="the-lesson-16"><a class="header" href="#the-lesson-16">The lesson</a></h2>
<p>Web storage allows us to store data in the browser that will live for the duration that the browser is open (session storage) or will persist until the browser's data is cleared (local storage). </p>
<p>How these differ from cookies:</p>
<ul>
<li>Larger amounts of data can be stored</li>
<li>The api to interact with them is easier to use. The web storage api is much newer than cookies.</li>
<li>They're not sent to the server when making new requests.</li>
</ul>
<p>In this lesson we're going to initialize a local storage value, apply some modifications to it, and read the value. Our example will be a counter.</p>
<p>Let's start with a basic client side leptos app that has a button to initialize our local storage value. Currently we just have a log message that will print a message to the browser's console when the button is clicked. This way we can confirm the handler is working.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;App /&gt;  
        }
	})
}  
  
#[component]  
fn App(cx: Scope) -&gt; Element {  
    let initialize_value = |_|{  
      leptos::log!(&quot;Initialize a value in local storage&quot;);  
    };  
    view! {  
        cx,  
        &lt;div&gt;  
            &lt;button on:click=initialize_value&gt;
	            &quot;Initialize value&quot;
			&lt;/button&gt;  
        &lt;/div&gt;  
    }
}</code></pre></pre>
<h3 id="accessing-the-web-storage-api"><a class="header" href="#accessing-the-web-storage-api">Accessing the Web Storage API</a></h3>
<p>We will need to find a way to call out to the Web Storage API through web_sys. The first step is finding out where web storage exists in JavaScript in the browser. The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API">MDN Web Storage API documentation</a> state, &quot;These mechanisms are available via the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage"><code>Window.sessionStorage</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage"><code>Window.localStorage</code></a> properties.&quot;</p>
<p>Leptos provides us with a <code>window()</code> function which will efficiently return a <code>web_sys::Window</code>, allowing us to communicate to the browser's <code>window</code>. </p>
<p>If we look at the <code>web_sys::Window</code> <a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Window.html#method.local_storage">documentation</a>, we'll see that there is a <code>local_storage</code> method!</p>
<p>Calling <code>local_storage</code> returns a <code>Result&lt;Option&lt;web_sys::Storage&gt;, web_sys::JsValue&gt;</code>.  We'll need to get the <code>Ok(Some(storage))</code> from it (<code>Ok</code> because of the result which contains <code>Some</code> because of the option). Once we do, we'll get that <code>web_sys::Storage</code>, which we can work with. The <a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Storage.html"><code>web_sys::Storage</code> struct's documentation</a> enumerates all of the methods we can call, including <code>get()</code> and  <code>set()</code>!</p>
<h4 id="chaining-unwraps"><a class="header" href="#chaining-unwraps">Chaining Unwraps</a></h4>
<p>You can use unwarps to extract the <code>Ok</code> and <code>Some</code> like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let storage = window().local_storage().unwrap().unwrap();
<span class="boring">}</span></code></pre></pre>
<p>The problem is that <code>upwrap()</code> will throw a panic if it's the <code>Err</code> or <code>None</code> variants of <code>Result</code> and <code>Option</code> respectively. We don't want our application to panic! </p>
<h4 id="nested-matches"><a class="header" href="#nested-matches">Nested Matches</a></h4>
<p>We can use pattern matching as a potential solution:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match window().local_storage() {
	Ok( maybe_some_storage ) =&gt; match maybe_some_storage {
		Some( storage ) =&gt; {
			// Do your stuff wth storage
		},
		None =&gt; {}
	},
	Err() =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>This solution doesn't panic, which is great. But it does put our code in deeply nested scopes which makes it hard to read.</p>
<h4 id="assigning-the-value-of-a-match"><a class="header" href="#assigning-the-value-of-a-match">Assigning the value of a match</a></h4>
<p>What we're looking to do is assign the value to <code>storage</code> if it can be retrieved from the nested Result/Option, otherwise we'll do nothing. Do keep in mind that most applications will want to do something in the event that expected behaviour can't be followed. </p>
<p>A match statemetn will evaluate to the value of its matched expression. We can assign that value to a variable!</p>
<p>Currently that value is wrapped in an Option, which is then wrapped in a Result. We are able to use the same nesting of our return types to create a patterns to extract the value we're looking for. By combining these we can say, &quot;If local_storage() returns an <code>Ok</code> that has <code>Some</code> <code>storage</code>, let the value of the match statement be <code>storage</code>.&quot; The other pattern marked with an underscore (<code>_</code>)  indicates a catch-all. Anything that doesn't match what we want will return, breaking out of our closure!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let storage : web_sys::Storage = match window().local_storage() {  
    Ok(Some(storage)) =&gt; storage,  
    _ =&gt; return   
};
// We will only run code here if storage was able to be unwrapped by the match
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>I added the <code>web_sys::Storage</code> type to make this more clear, but Rust will infer the type. You do not need to write it.</p>
</blockquote>
<h3 id="working-with-the-web-storage-api"><a class="header" href="#working-with-the-web-storage-api">Working with the web storage API</a></h3>
<h4 id="setting-a-value"><a class="header" href="#setting-a-value">Setting a value</a></h4>
<p>We can now call the <code>Storage</code> api through our <code>storage</code> variable (note the lowercase 's'. <code>Storage</code> is the struct/type, <code>storage</code> is our value). </p>
<p>Here we are assigning (setting) the key &quot;my-counter&quot; with a value of <code>0</code>. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>storage.set(&quot;my-counter&quot;, &amp;0.to_string());
<span class="boring">}</span></code></pre></pre>
<p>It's important to note that the web storage api stores strings. We can represent numbers and complex data in string form, being as the numerical character or as serialized data respectively. Rust requires that we convert our integer <code>0</code> to a string with the <code>to_string()</code> method. This provides us with an owned string. As per the documentation set is looking for a reference to a string, a string slice (<code>&amp;str)</code>. We can meet these requirements by prefixing the whole thing with an ampersand <code>&amp;</code>.</p>
<h3 id="retrieving-a-value"><a class="header" href="#retrieving-a-value">Retrieving a value</a></h3>
<p>We can use the get method to retrieve a value from a given key.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_counter_value = storage.get(&quot;my-counter&quot;);
<span class="boring">}</span></code></pre></pre>
<p>The return type of <code>get</code> is <code>Result&lt;Option&lt;String&gt;,JsValue&gt;</code>. We can use unwrap_or_default to safely unwarp or fail. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_counter_value : String = storage  
    .get(&quot;my-counter&quot;)   // at this point we have a Result&lt;Option&lt;String&gt;,JsValue&gt;
    .unwrap_or_default() // Gives us Option&lt;string&gt; or the default value
    .unwrap_or_default(); // Gives us string or the default value, an empty string
<span class="boring">}</span></code></pre></pre>
<p>In our case, we're using a number, so we'll need to parse it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_counter_value = storage  
    .get(&quot;my-counter&quot;)  
    .unwrap_or_default()  
    .unwrap_or_default()  
    .parse::&lt;i8&gt;()  // attempt to parse the string as an 8 bit integer
    .unwrap_or_default(); 
    // ^ Return the Ok result, which is an 8 bit integer 
	//   or if there was a parse error, return the default value for an 8 bit integer
<span class="boring">}</span></code></pre></pre>
<p>We can also write this as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_counter_value : i8 = storage  
    .get(&quot;my-counter&quot;)  
    .unwrap_or_default()  
    .unwrap_or_default()  
    .parse()  
    .unwrap_or_default();
<span class="boring">}</span></code></pre></pre>
<p>We could rewrite this as a a match statement. Here's an example with a little twist. We're specifying what the fallback value should be in a more visible way:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_counter_value: i8 = match storage.get(&quot;my-counter&quot;) {  
    Ok(Some(value)) =&gt; value.parse().unwrap_or(0),  
    _ =&gt; 0  
};
<span class="boring">}</span></code></pre></pre>
<h3 id="making-a-module"><a class="header" href="#making-a-module">Making a module</a></h3>
<p>We can wrap these two bits of functionality into a nice little module for reuse:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod local_storage {  
  
    use leptos::*;  
  
    pub fn set(key : &amp;str , val : &amp;str ) {  
        let storage = match window().local_storage() {  
            Ok(Some(storage)) =&gt; storage,  
            _ =&gt; return  
        };  
        storage.set(key, val);  
    }  
  
    pub fn get(key : &amp;str ) -&gt; String {  
        let storage = match window().local_storage() {  
            Ok(Some(storage)) =&gt; storage,  
            _ =&gt; return &quot;&quot;.to_string()  
        };  
  
        match storage.get(key) {  
            Ok(Some(val)) =&gt; val,  
            _ =&gt; &quot;&quot;.to_string()  
        }
	}
	
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Again it is important to note that we are not handling any errors here. </p>
</blockquote>
<p>Calls to our local storage module are all nicely cleaned up:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// set a value
local_storage::set( &quot;my-counter&quot;, &amp;22.to_string() );  

// get a value
let v: i8 = local_storage::get(&quot;my-counter&quot;).parse().unwrap_or_default();
<span class="boring">}</span></code></pre></pre>
<p>It would be great to avoid this whole parse and unwrap business as well. Let's see if we can't clean that up even more.</p>
<p>We'll need a generic type here. I'm going to use <code>Val</code> because it'll connect with <code>val</code> (the actual value). Many people use <code>T</code>. The letter doesn't matter. We'll provide it as a type argument by adding <code>&lt;Val&gt;</code> after <code>get</code> and before the parameter lsit. Then we'll set the return type to be of type <code>Val</code> as well, with <code>-&gt; Val</code> after the parameter list. I'd like to be able to explicitly set the default value, so I'll add that as a parameter called <code>default</code> of type <code>Val</code>. The only thing left to do is add the <code>default</code> in where we had empty strings before. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get&lt;Val&gt;(key : &amp;str, default: Val ) -&gt; Val {  
    let storage: web_sys::Storage = match window().local_storage() {  
        Ok(Some(storage)) =&gt; storage,  
        _ =&gt; return default  
    };  
  
    match storage.get(key) {  
        Ok(Some(val)) =&gt; val.parse().unwrap_or( default ),  
        _ =&gt; default  
    }  
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>You might think that we'd need to provide <code>Val</code> in a turbofish for <code>val.parse::&lt;Val&gt;()</code> but we don't. Rust's compiler is smart enough (so darn smart). It knows that the final match statement doesn't end in a semicolon, so it must be the final expression. The result of the match will be our return value. This must be a <code>Val</code> type. It knows that if it's going to parse it <em>has</em> to parse to a <code>Val</code> value type!</p>
</blockquote>
<p>This isn't quite there yet though. We need to add some type bounds for Val. We can't just accept anything. We want to only acccept thing that are of type <code>Val</code> if they can actually be parsed from a string. We can do this by adding the trait bound to the generic <code>&lt;Val: std::str::FromStr&gt;</code>. This means that whatever type <code>Val</code> is, it must implement the <code>std::str::FromStr</code> trait.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get&lt;Val: std::str::FromStr&gt;(key : &amp;str, default: Val ) -&gt; Val {  
    let storage: web_sys::Storage = match window().local_storage() {  
        Ok(Some(storage)) =&gt; storage,  
        _ =&gt; return default  
    };  
  
    match storage.get(key) {  
        Ok(Some(val)) =&gt; val.parse::&lt;Val&gt;().unwrap_or( default ),  
        _ =&gt; default  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>Actually, while we're in here, let's make the local storage setter more flexible too. By adding a generic <code>Val</code> type we can call to_string() and turn it into a reference within this function. We do need to add constraints to the function. <code>Val: std::fmt::Display</code> guarantees that we can call to_string() on whatever type <code>Val</code> is.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The function definition's type constraint can also be written with a 
// where keyword after the parameter list as follows.
// pub fn set&lt;Val&gt;(key : &amp;str , val : Val ) where Val: std::fmt::Display {  
pub fn set&lt;Val: std::fmt::Display&gt;(key : &amp;str , val : Val ) {  
    let storage: web_sys::Storage = match window().local_storage() {  
        Ok(Some(storage)) =&gt; storage,  
        _ =&gt; return  
    };  
    storage.set(key, &amp;val.to_string());  
}
<span class="boring">}</span></code></pre></pre>
<p>Now, as you look at this, you should be thinking, &quot;But wouldn't I want to know if I failed to read a value? Won't this module make it look like local storage is working correctly even if it's not?!&quot; Use the knowledge you've gained in this lesson to refactor the module so that your code expresses the behaviour of your application. Think critically about where failures are important to note and handle, and where they're not.</p>
<h2 id="the-final-code"><a class="header" href="#the-final-code">The final code</a></h2>
<p>Here's the code all wrapped up and rolled together.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;App /&gt;  
        }
	})
}  
  
  
mod local_storage {  
    use leptos::*;  
  
    pub fn set&lt;Val: std::fmt::Display&gt;(key: &amp;str, val: Val) {  
        let storage: web_sys::Storage = match window().local_storage() {  
            Ok(Some(storage)) =&gt; storage,  
            _ =&gt; return  
        };  
        storage.set(key, &amp;val.to_string());  
    }  
  
    pub fn get&lt;Val: std::str::FromStr&gt;(key: &amp;str, default: Val) -&gt; Val {  
        let storage: web_sys::Storage = match window().local_storage() {  
            Ok(Some(storage)) =&gt; storage,  
            _ =&gt; return default  
        };  
  
        match storage.get(key) {  
            Ok(Some(val)) =&gt; val.parse().unwrap_or(default),  
            _ =&gt; default  
        }  
    }}  
  
#[component]  
fn App(cx: Scope) -&gt; Element {  
    let initialize_value = |_| {  
        local_storage::set(&quot;my-counter&quot;, 0);  
        leptos::log!(&quot;Init counter to {}&quot;, local_storage::get(&quot;my-counter&quot;, 0));  
    };  
  
    let increment_value = |_| {  
        let value: i32 = local_storage::get(&quot;my-counter&quot;, 0);  
        local_storage::set(&quot;my-counter&quot;, value.saturating_add(1));  
        leptos::log!(&quot;Increment counter to {}&quot;, local_storage::get(&quot;my-counter&quot;, 0));  
    };  
  
    let decrement_value = |_| {  
        let value: i32 = local_storage::get(&quot;my-counter&quot;, 0);  
        local_storage::set(&quot;my-counter&quot;, value.saturating_sub(1));  
        leptos::log!(&quot;Decrement counter to {}&quot;, local_storage::get(&quot;my-counter&quot;, 0));  
    };  
  
    view! {  
        cx,  
        &lt;div&gt;  
            &lt;button on:click=initialize_value&gt;&quot;Initialize value&quot;&lt;/button&gt;  
            &lt;button on:click=increment_value&gt;&quot;+&quot;&lt;/button&gt;  
            &lt;button on:click=decrement_value&gt;&quot;-&quot;&lt;/button&gt;  
        &lt;/div&gt;  
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cookies"><a class="header" href="#cookies">Cookies</a></h1>
<h2 id="what-well-learn-19"><a class="header" href="#what-well-learn-19">What we'll learn</a></h2>
<ul>
<li>What cookies are</li>
<li>How we can set them</li>
<li>How we can detect cookie changes</li>
</ul>
<h2 id="whats-missing-1"><a class="header" href="#whats-missing-1">What's missing</a></h2>
<ul>
<li>Cookie paths, lifetimes, and advanced configuration</li>
<li>Type safety guarantees for non-string types</li>
<li>Session and persistant cookie types</li>
</ul>
<h2 id="caveat-1"><a class="header" href="#caveat-1">Caveat</a></h2>
<p>There are many additional options available when setting cookies. This lesson is intended to give you a cursory understanding of how they're written and stored but it is not exhaustive. </p>
<h2 id="the-lesson-17"><a class="header" href="#the-lesson-17">The lesson</a></h2>
<p>Cookies are a client storage tool. We can create a cookie with a specific name and assign it a string value. Recall that many numeric (int, float, bool) or complex (structs) can be represented as strings through the user of the characters that make up their numbers, or through serialization.</p>
<blockquote>
<p>One important thing to remember is that cookies are sent as part of each web request for your application's domain.</p>
</blockquote>
<h3 id="writing-to-a-cookie"><a class="header" href="#writing-to-a-cookie">Writing to a cookie</a></h3>
<p>To exemplify how we can write to cookies we'll build a little text to cookie value input box. Typing in it will update a corresponding cookie.</p>
<h4 id="capturing-input"><a class="header" href="#capturing-input">Capturing Input</a></h4>
<p>We'll start with a simple Leptos application component called &quot;App&quot; which contains a text field.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;App /&gt;  
        }    
	})
}  

#[component]  
fn App(cx: Scope) -&gt; Element {  
    view! {  
        cx,  
        &lt;div&gt;  
            &lt;input  
				name=&quot;my_input&quot;  
	            type=&quot;text&quot;  
	         /&gt;  
        &lt;/div&gt;  
    }
}</code></pre></pre>
<p>Now let's udpate it with that on key up event handler.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
use web_sys::KeyboardEvent;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;App /&gt;  
        }    
	})
}  

#[component]  
fn App(cx: Scope) -&gt; Element {  
    let write_value_to_cookie = |e:KeyboardEvent|{  
        leptos::log!(&quot;You pressed a key!&quot;);  
    };  
    view! {  
        cx,  
        &lt;div&gt;  
            &lt;input  
	            name=&quot;cookie_input&quot;  
		        type=&quot;text&quot;  
	            placeholder=&quot;Type text and I'll update a cookie!&quot;  
	            on:keyup=write_value_to_cookie  
	         /&gt;  
        &lt;/div&gt;  
    }}</code></pre></pre>
<p>I used the <code>keyup</code> event becuase <code>change</code> events only fire when focus is taken away from the input area (you click elsewhere, press tab, or esc), and <code>keydown</code> will only fire when a key is pressed but that happens before the value of the input field is updated. If we did that we'd always be one key stoke behind.</p>
<p>Note that we imported the KeyboardEvent from web_sys with:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use web_sys::KeyboardEvent;
<span class="boring">}</span></code></pre></pre>
<p>And we added that type to the event handler closure.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let write_value_to_cookie = |e: KeyboardEvent| {  
	// ...
};
<span class="boring">}</span></code></pre></pre>
<p>Now we'll pull the value out of the keyboard event and log it to the console.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let write_value_to_cookie = |e: KeyboardEvent| {  
    let input: HtmlInputElement = e.target()
	    .unwrap()
	    .unchecked_into();  
    leptos::log!(&quot;{:?}&quot;, input.value());  
};
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><code>e.target()</code>, returns a result type that we know will have a <code>TargetElement</code>. We call unwrap to get the value out of the <code>Result</code>. Then we call <code>unchecked_into()</code> on the <code>TargetElement</code> type. Rust will see that we specified the destination type for <code>input</code> as <code>HtmlInputElement</code>.  It will use this as the type parameter for <code>unchecked_into()</code>, casting the <code>TargetElemenet</code> as a <code>HtmlInputElement</code>. This is identical to not providing a type for <code>input</code> and writing, <code>unchecked_into::&lt;HtmlInputElement&gt;()</code>, using the turbofish syntax (<code>::&lt;&gt;</code>).</p>
</blockquote>
<p>For the above to work, we need to bring the <code>HtmlInputElement</code> struct into scope as well with an updated use statement. We can use the destructuring syntax to update our previous statement.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use web_sys::{KeyboardEvent, HtmlInputElement};
<span class="boring">}</span></code></pre></pre>
<h4 id="writing-to-cookies"><a class="header" href="#writing-to-cookies">Writing to cookies</a></h4>
<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie">browser's cookie api</a> is a property of the document object. If we want to call things on document, we'll need to use web_sys to get a reference to it. Thankfully Leptos provides a function which allows us to grab the document. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let document = document();
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>It's recommended to use this Leptos function over web_sys because Leptos will store the reference in WASM to improve performance.</p>
</blockquote>
<p>We'll need to give Rust a bit of help here to identify the type. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let doc: HtmlDocument = document().unchecked_into();
<span class="boring">}</span></code></pre></pre>
<p>The struct <code>HtmlDocument</code> is hidden behind a feature flag. To enable this feature we can add the following to our <code>cargo.toml</code>.</p>
<pre><code class="language-toml">[dependencies.web-sys]  
features = [ &quot;HtmlDocument&quot; ]
</code></pre>
<p>We can now extract our cookie data from the the <code>HtmlDocument</code>. I had a quick look over at the <code>web_sys</code> documentation to confirm which method exists on the HtmlDocument struct that'll allow me to set a cookies value. It's <a href="https://docs.rs/web-sys/0.3.5/web_sys/struct.HtmlDocument.html#method.set_cookie">set_cookie()</a> We can get the cookie value via get_cookie() too.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>doc.set_cookie(&quot;some data&quot;);
doc.set_cookie(&quot;my-key=first-value&quot;);
doc.set_cookie(&quot;my-key=second-value&quot;);

let cookie = doc.cookie().unwrap();
leptos::log!(&quot;{:?}&quot;, cookie );
<span class="boring">}</span></code></pre></pre>
<p>The above prints <code>my-key=second-value; some data=</code> to the console.</p>
<p>What's interesting about set_cookie and the cookie api, is that it will parse the key name and value to make sure the correct cookie is updated.</p>
<h3 id="reading-cookies"><a class="header" href="#reading-cookies">Reading cookies</a></h3>
<p>As we've seen above, we can read the complete text that makes up the cookie value by calling <code>cookie()</code> on an <code>HtmlDocument</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let doc: HtmlDocument = document().unchecked_into();
let raw_cookie_data = doc.cookie().unwrap_or_default();
<span class="boring">}</span></code></pre></pre>
<p>We'll need to parse that string into actual key=&gt;value pairs.</p>
<p>We'll first need to split these into individual cookies. We saw that the delimeter was a semicolon and space. We can call <code>split()</code> on the raw cookie data to break the string up.</p>
<p>Then we call collect() to turn it into an vector. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let kvp_strings: Vec&lt;&amp;str&gt; = raw_cookie_data
	.split(&quot;; &quot;)
	.collect();
<span class="boring">}</span></code></pre></pre>
<p>This provides us with an array of key value pair strings.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>[&quot;my-key=second-value&quot;, &quot;some data=&quot;]
<span class="boring">}</span></code></pre></pre>
<p>We need to add another step here. We need to split those strings by <code>=</code>. We'll add a map method call after the split. The map method will apply a function to each item. In this case, we're spliting the strings and returning the result as a <code>Vec&lt;&amp;str&gt;</code>, a vector of string references.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let raw_cookie_data: String = doc
	.cookie()
	.unwrap_or_default();  
	
let key_value_pairs: Vec&lt;Vec&lt;&amp;str&gt;&gt; = cookie  
    .split(&quot;; &quot;)  
    .map(|kvp_string|{  
        kvp_string.split('=').collect()  
    })
	.collect();  
	
leptos::log!(&quot;{:?}&quot;, key_value_pairs );
<span class="boring">}</span></code></pre></pre>
<p>We now have a multidimensional array but it's not very usable. We can't check to see if a value is set. Let's turn this multidimensional vector into a hash map.</p>
<p>We need to add a use statement to import the <code>HashMap</code> type into scope.</p>
<p>We'll update the cookies type to <code>HashMap</code> with two type parameters for the key type and value type. In this case they're both string slices.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let raw_cookie_data: String = doc
	.cookie()
	.unwrap_or_default();  

let cookies: HashMap&lt;&amp;str, &amp;str&gt; = raw_cookie_data  
    .split(&quot;; &quot;)  
    .map(|kvp_string|{  
        kvp_string.split('=').collect()  
    })    
    .collect();  

leptos::log!(&quot;{:?}&quot;, key_value_pairs );
<span class="boring">}</span></code></pre></pre>
<p>Now we'll turn our attention to the body of the map function which processes <code>kvp_string</code></p>
<p>We're starting with this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>kvp_string.split('=').collect()  
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>This would split a string into an vector of strings, cut at each '=' character.</p>
</blockquote>
<p>HashMaps can be made by providing a vector of tuples with key value pairs. We can use <code>split_at</code> to provide a tuple.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.map(|kvp_string|{  
	kvp_string.split_at(  
	    kvp_string.find(&quot;=&quot;).unwrap_or_default()  
	)
}
<span class="boring">}</span></code></pre></pre>
<p>Running the map with the above body provides the following results:
<code>(&quot;my-key&quot;, &quot;=second-value&quot;),</code>
<code>(&quot;some data&quot;, &quot;=&quot;)</code></p>
<p>Look like we need to do another transformation on these rows. We'll add another map which turns these tuples into tuples that have the first character removed from the values.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.map(|kvp_tuple|{  
    (kvp_tuple.0, &amp;kvp_tuple.1[1..])  
})
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>We're accessing the first and second elements of the tuple with <code>.0</code> and <code>.1</code>. By using the spread operator on the second value of the tuple (index <code>1</code>), we're able to tell the compiler, &quot;take from the 1st position onward,&quot; which ignores position 0 of the esequence which is the &quot;=&quot; symbol.</p>
</blockquote>
<blockquote>
<p>It is worth noting that these two values are wrapped in parenthesis and will be returned as <code>(&amp;str, &amp;str)</code> type. </p>
</blockquote>
<p>We can now use HashMap methods to interact with the cookie data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>leptos::log!(
	&quot;{:?}&quot;, 
	cookies.get(&quot;my-key&quot;).unwrap_or(&amp;&quot;&quot;) 
);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Here we log the value stored at &quot;my-key&quot; in the <code>cookies</code> <code>HashMap</code>. This returns a <code>Some(&amp;str)</code> type. We can unwrap this to make it either the string slice <code>&amp;str</code> or a reference to an empty string slice, which is also of type <code>&amp;str</code></p>
</blockquote>
<h2 id="the-finished-code"><a class="header" href="#the-finished-code">The finished code</a></h2>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
use web_sys::{KeyboardEvent, HtmlInputElement, HtmlDocument};  
use std::collections::HashMap;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;App /&gt;  
        }    })}  
  
#[component]  
fn App(cx: Scope) -&gt; Element {  
    let write_value_to_cookie = |e: KeyboardEvent| {  
  
        let input: HtmlInputElement = e.target().unwrap().unchecked_into();  
        let doc: HtmlDocument = document().unchecked_into();  
        let cookie_key = &quot;my-cookie&quot;;  
  
        let cookie_data = vec!(cookie_key, &amp;input.value() ).join(&quot;=&quot;);  
        doc.set_cookie(&amp;cookie_data);  
  
        // Parse cookie data and log it out  
        let cookie: String = doc.cookie().unwrap_or_default();  
        let key_value_pairs: HashMap&lt;&amp;str, &amp;str&gt; = cookie  
            .split(&quot;; &quot;)  
            .map(|kvp_string|{  
                kvp_string.split_at(  
                    kvp_string.find(&quot;=&quot;).unwrap_or_default()  
                )            
			})            
			.map(|kvp_tuple|{  
                (kvp_tuple.0, &amp;kvp_tuple.1[1..])  
            })
			.collect();  
  
        leptos::log!(&quot;{:?}&quot;, key_value_pairs.get(cookie_key).unwrap_or(&amp;&quot;&quot;) );  
    };  
    
    view! {  
        cx,  
        &lt;div&gt;  
            &lt;input  
                name=&quot;cookie_input&quot;  
               type=&quot;text&quot;  
              placeholder=&quot;Type text and I'll update a cookie!&quot;  
              on:keyup=write_value_to_cookie  
         /&gt;  
        &lt;/div&gt;  
    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="indexeddb"><a class="header" href="#indexeddb">IndexedDB</a></h1>
<blockquote>
<p><strong>This lesson is in <code>notes</code> status and is an extremely rough daft.</strong>
<em><strong>This lesson is not a complete notes draft</strong></em></p>
</blockquote>
<h2 id="what-we-know-19"><a class="header" href="#what-we-know-19">What we know</a></h2>
<ul>
<li>Data can be stored in the browser</li>
</ul>
<h2 id="what-well-learn-20"><a class="header" href="#what-well-learn-20">What we'll learn</a></h2>
<ul>
<li>Basic interaction with IndexedDB</li>
</ul>
<h2 id="caveat-2"><a class="header" href="#caveat-2">Caveat</a></h2>
<p>The IndexedDB API is complicated. Like all other web storage APIs, they are modifiable by any other scripts running on the page, making them untrusted. Pushing data from WASM to JS and back is slower than performing more work in WASM and letting Leptos update the resulting data. For these reasons, it's probably a better idea to think about your applications and create purpose built data structurs that you can query and work with instead of using the indexedDB API and data store.</p>
<h2 id="the-lesson-18"><a class="header" href="#the-lesson-18">The Lesson</a></h2>
<p>IndexedDB is a NoSQL like database that lives in the browser. We are able to grab data by creating a cursor that allows us to jump around the field of data that is the database. IndexedDB does not use structured query language (SQL) to retrieve data like MySQL, Maria, Postgres, etc.</p>
<p>The IndexedDB API is notoriously unconfortable to use. This article will provide a cursory overview and exploration of it for those curious. </p>
<p>Let's get things started with our Leptos <a href="client/store_data//quick_reference/client_side_app_setup">inital client side application</a>.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;App /&gt;  
        }    
	})
}
  
#[component]  
fn App(cx: Scope) -&gt; Element {  
    view! {  
        cx,  
        &lt;div&gt;  
            &quot;My App&quot;  
        &lt;/div&gt;  
    }
}</code></pre></pre>
<p>We'll jump over to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API">documentation</a> and scroll down to &quot;Interfaces&quot;. This gives us some hints for where we need to go. </p>
<p>The documentation reads:
&gt;To get access to a database, call <a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBFactory/open"><code>open()</code></a> on the <a href="https://developer.mozilla.org/en-US/docs/Web/API/indexedDB"><code>indexedDB</code></a> attribute of a <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window">window</a> object.</p>
<p>In my mind I think, &quot;I should make a button that will connect to the database when I click it.&quot; I find it's easiest to build and learn if I can provide my own input and introspect the result. </p>
<blockquote>
<p><strong>Reoccuring Pattern Alert:</strong> It's interesting how this feedback loop is the same as a servers request-&gt;response, or how applications are built in general. Programs are often the way they are because they're expressions of how we think.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn App(cx: Scope) -&gt; Element {  
    let connect_to_database = |_|{  
        leptos::log!(&quot;Connect to database&quot;)  
    };  
    view! {  
        cx,  
        &lt;div&gt;  
            &lt;button on:click=connect_to_database&gt;  
                &quot;Connect to DB&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The documentation states that indexedDB is an attribute of the <code>window</code> object. We'll use Leptos' <code>window()</code> function to grab it's cached reference to <code>window</code> as a <code>web_sys::Window</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let connect_to_database = |_|{  
	leptos::log!(&quot;Connect to database&quot;)    
	let window = window();  
};
<span class="boring">}</span></code></pre></pre>
<p>If we look at the <a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Window.html#method.indexed_db">web_sys::Window documentation</a> we'll see that there is a web_sys version of the indexedDB javascript proprty called <code>indexed_db</code>. Note the difference in case. Rust is prescriptive about it's use of snake case for function/method names. We can see that the return type is <code>Result&lt;Option&lt;IdbFactory&gt;, JsValue&gt;</code>.</p>
<p>This <code>IdbFactory</code> looks interesting. If we check the IndexedDB documentation we'll see a good definition of what it is.</p>
<blockquote>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBFactory"><code>IDBFactory</code></a>: Provides access to a database. This is the interface implemented by the global object <a href="https://developer.mozilla.org/en-US/docs/Web/API/indexedDB"><code>indexedDB</code></a> and is therefore the entry point for the API.</p>
</blockquote>
<p>This is perfect. We want an entry point for the API!</p>
<p>We can use the following match pattern to get the <code>IdbFactory</code> (note that this refers to the struct with its PascalCase) out of our <code>indexed_db()</code> call, or return (prematurely terminate the closure/click handler) if the pattern doesn't match.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let idb = match window().indexed_db() {  
    Ok(Some(idb_factory)) =&gt; idb_factory,  
    _ =&gt; return  
};
<span class="boring">}</span></code></pre></pre>
<p>The <code>web_sys::indexed_db()</code> documentation also states:</p>
<blockquote>
<p><em>This API requires the following crate features to be activated: <code>IdbFactory</code>, <code>Window</code></em></p>
</blockquote>
<p>We can enable these feature by adding the following to our cargo.toml file</p>
<pre><code class="language-toml">[dependencies.web-sys]  
features = [ &quot;Window&quot;,  &quot;IdbFactory&quot; ]
</code></pre>
<p><code>web_sys</code> has a lot of features and compiling all of them into the Leptos WASM application would make it needlessly large. For this reason, features are hidden behind feature flags like this so that we can pick and choose what gets added to our final application on a needs basis. Rust is very considerate.</p>
<p>Let's zip on over to the <a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.IdbFactory.html"><code>web_sys::IdbFactory</code> struct documentation</a> to see what's avaialble to us there. I see an <a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.IdbFactory.html#method.open"><code>open()</code></a> method which looks like what we want, so we'll try that. Note that we need to add some extra features to the web-sys crate. <code>open()</code> requires &quot;<em><code>IdbFactory</code>, <code>IdbOpenDbRequest</code></em>&quot;, so we'll add the missing <code>IdbOpenDbRequest</code> </p>
<pre><code class="language-toml">[dependencies.web-sys]  
features = [ &quot;Window&quot;,  &quot;IdbFactory&quot;, &quot;IdbOpenDbRequest&quot; ]
</code></pre>
<p>I made a few changes to make the code more visible. This is where we're at:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let connect_to_database = |_|{  
  
    // Grabbed a reference to window  
    let window = window();  
  
    // Got a factory to be able to make an open connection  
    let idb = match window.indexed_db() {  
        Ok(Some(idb_factory)) =&gt; idb_factory,  
        _ =&gt; return  
    };  
  
    let idb_open_request = match idb.open(&quot;my-database&quot;) {  
         Ok(idb_open_request) =&gt; idb_open_request,  
         _ =&gt; return  
    };  
  
    // Do something with the connection  
};
<span class="boring">}</span></code></pre></pre>
<p>The question that we now have is, how do we work with IndexedDB? We need some more information.</p>
<h3 id="store-type"><a class="header" href="#store-type">Store type</a></h3>
<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Basic_Terminology">MDN documentation</a> states that IndexedDB is a key-value store. The values can be complex objects, and keys can be properties of those objects. If we're thinking in terms of Rust, what they're saying is that we can store structs in IndexedDB, where properties like 'id' could be a key used to look up the struct.</p>
<h3 id="transactions"><a class="header" href="#transactions">Transactions</a></h3>
<p>All interactions with IndexedDB are done in the form of transactions. The mental model is such that we requst for a change in the database and the database will hold the request until it is safe to perform. This guarantees data integrity where we don't have two sources potentially modifying the same data, etc.</p>
<p>There are three transaction types. We'll only be looking at the first two:</p>
<ol>
<li>readwrite</li>
<li>readonly</li>
<li>versionchange</li>
</ol>
<h3 id="data-retrieval"><a class="header" href="#data-retrieval">Data Retrieval</a></h3>
<p>Data is not returned from the database as soon as you request it. Recall that we submit requests to the database as transactions for it to perform. The database decides when it is safe to perform those transactions. For this reason we'll need to provide indexedDB with callbacks to run when the transactions are preformed. We'll be reacting to the retrieval of data. In fact, IndexedDB uses DOM events to notifuy us when resuts are available. It's not dissimilar to how we worked with buttons and click events. </p>
<h3 id="mdn-to-the-rescue"><a class="header" href="#mdn-to-the-rescue">MDN to the rescue</a></h3>
<p>The wonderful Mozilla Developer Network (MDN) has a reference on <a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API/Using_IndexedDB">Using IndexedDB</a>. In it, they outline the basic usage steps as follows:</p>
<ol>
<li>Open a database.</li>
<li>Create an object store in the database.</li>
<li>Start a transaction and make a request to do some database operation, like adding or retrieving data.</li>
<li>Wait for the operation to complete by listening to the right kind of DOM event.</li>
<li>Do something with the results (which can be found on the request object).</li>
</ol>
<p>We'll follow along, but in Rust and Leptos.</p>
<p>Where we last left off, we created a <code>web_sys::IdbOpenDbRequest</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let idb_open_request = match idb.open(&quot;my-database&quot;) {  
     Ok(idb_open_request) =&gt; idb_open_request,  
     _ =&gt; return  
};  
<span class="boring">}</span></code></pre></pre>
<p>This isn't a connection persey. It is part of the chain of processes to setup a connection.</p>
<p>In the MDN documentation, the author establishes the same type of object in Javascript and then attaches event handlers to <code>onerror</code> and <code>onsuccess</code>.</p>
<p>We'll add callback functions/handlers to our Rust version.</p>
<p>If we look at the definitions of <a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.IdbOpenDbRequest.html#method.onsuccess"><code>set_onsuccess</code></a> and <a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.IdbOpenDbRequest.html#method.set_onerror"><code>set_onerror</code></a> we'll see that these are the functions that allow us to set the values of the onsuccess and onerror propreties of the JavaScript object. Exactly what we're looking for. Their definitions also tell us that we need to add the <code>IdbRequest</code> feature to our <code>cargo.toml</code> file.</p>
<pre><code class="language-toml">[dependencies.web-sys]  
features = [ &quot;IdbFactory&quot;, &quot;IdbOpenDbRequest&quot;, &quot;IdbRequest&quot;]
</code></pre>
<p>Intuitively I think, &quot;JavaScript accepts functions as the values for these properties, so I should use closures for mine. Though it'll need to be wrapped in a <code>Some</code> because it's an option.&quot;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>idb_open_request.set_onsuccess(
	Some(
		||{  
			// on success stuff here 
		}
	)
);  
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>This is all spaced out so that you can easily see the syntax.</p>
</blockquote>
<p>Unfortunately, my intuition is off. Even thought the word <code>Function</code> looks familiar, we have to remember that in Rust we have <code>Fn</code>, <code>FnOnce</code>, and <code>FnOnce</code> as function types. <code>Function</code> isn't a native function type. Looking closer I can see that <code>Function</code> is a special struct that is callable by WASM. It is a <code>js_sys::Function</code>.</p>
<h3 id="creating-javascript-closures-in-rust"><a class="header" href="#creating-javascript-closures-in-rust">Creating JavaScript closures in Rust</a></h3>
<p>What we need to do is create a <a href="https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/closure/struct.Closure.html"><code>wasm_bindgen::closure::Closure</code></a> and then  <a href="https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/closure/struct.Closure.html#casting-a-closure-to-a-js_sysfunction">cast the closure to a js_sys::Function</a>. The MDN documentation uses a struct with a <code>_closure</code> property. We'll do things slightly differently, stepping through each line of code and what it does.</p>
<p>The first step is making a closure. We'll use the <a href="https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/closure/struct.Closure.html#method.wrap"><code>Closure::wrap</code></a> method. The documentation defines it as:</p>
<blockquote>
<p>A more direct version of <code>Closure::new</code> which creates a <code>Closure</code> from a <code>Box&lt;dyn Fn&gt;</code>/<code>Box&lt;dyn FnMut&gt;</code>, which is how it’s kept internally.</p>
</blockquote>
<p>This sounds like exactly what we want,</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// cb stands for callback
let cb = wasm_bindgen::closure::Closure::wrap(
	// We need something here.
);
<span class="boring">}</span></code></pre></pre>
<p>We need to provide an argument which is a <code>Box</code> that contains a <code>dyn FnMut</code>. There's a lot here to unpack.</p>
<h4 id="box"><a class="header" href="#box">Box</a></h4>
<p>In Rust, there are two types of memory allocation, heap and stack. The stack is fast but requires the size of what's being stored in it to be consistent and known. The heap allows us to store things that may change in size, but they need to be looked up in the stack to get their actual values. It's two steps instead of one. Also, the heap isn't as organized as the stack, so it's lookups will also be slower. </p>
<p>A <code>Box</code> is a way for us to store data in the heap. The actual size of a <code>Box</code> is known, because it's a pointer to memory in the heap. </p>
<h4 id="dyn-dynamic"><a class="header" href="#dyn-dynamic">dyn (dynamic)</a></h4>
<p>Rust wants to know everything in advance to be able to optimize all code and make its security guarantees. If we're going to be skipping across contiquous zeros and ones in memory and interpreting them as data, we need to know the size of the data we're reading.</p>
<p>Unfortunately sometimes this isn't possible to do at compilation time. When we use traits as types in Rust, we're telling Rust that anything that impements the specified trait is fair game for use as an argument. This is a powerful technique because we're allowing any values to be used in the future provided someone writes an <code>impl</code> (implementation) for the given trait.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct RobotDuck{}  

impl RobotDuck {  
    fn assert_duckitude() {  
        println!(
	        &quot;I'm totally not a robot. 
	        Look at me click on these 
	        images of bread floating 
	        in a pond.&quot;
		)  
    }
}  
    
struct RealDuck{}  
  
trait Quack {  
    fn quack(&amp;self){  
        println!(&quot;QUACK&quot;);  
    }  
}  
  
impl Quack for RobotDuck{}  
impl Quack for RealDuck{}  
<span class="boring">}</span></code></pre></pre>
<p>In the above, example, we have two structs with different functions. As a result, they'll look different in memory. Both of these ducks implement the <code>Quack</code> trait and can call the default trait implementation <code>quack()</code>.</p>
<p>Let's say we have this function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn this_thing_quacks&lt;T&gt;(quackable: T) where T: Quack {
	println!(&quot;This thing quacks!&quot;);  
	quackable.quack();  
}
<span class="boring">}</span></code></pre></pre>
<p>We have a trait bound on the generic type <code>T</code> that requires implementation of <code>Quack</code>. When the compiler runs, it will actually create a version of this function for each type that impements <code>Quack</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn this_thing_quacks(quackable: RobotDuck){
	//...
}

fn this_thing_quacks(quackable: RealDuck){
	//...
}
<span class="boring">}</span></code></pre></pre>
<p>Recall that functions are also data! Rust needs to have guarantees about the sizes of data as arguments for the function with the generic <code>T</code>.</p>
<p>We'll get an error if we try to change the signature to this though.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn this_thing_quacks(quackable: Quack) {
	println!(&quot;This thing quacks!&quot;);  
	quackable.quack();  
}
<span class="boring">}</span></code></pre></pre>
<p>The reason being is that we don't know what size <code>Quack</code> is when it is being called. There are multiple things that implement <code>Quack</code> and they aren't all the same size! Rust doesn't stamp out the different versions because it hasn't been pre-defined. When we use a trait bound (with the where clause or with <code>&lt;T: Quack&gt;</code>) , Rust's precompilation can prepare the versions for you. When we use the trait object as a type, we defer to runtime checks.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn this_thing_quacks(quackable: dyn Quack) {
	println!(&quot;This thing quacks!&quot;);  
	quackable.quack();  
}
<span class="boring">}</span></code></pre></pre>
<p>By adding <a href="https://doc.rust-lang.org/std/keyword.dyn.html"><code>dyn</code></a> we tell the compiler that it will need to look up the data, and an associated table of its functions. If we knew the type at compilation time, we wouldn't need to look up associated functions because they would be known.</p>
<h3 id="fn--fnmut-function-trait-objects"><a class="header" href="#fn--fnmut-function-trait-objects">Fn / FnMut (Function Trait Objects)</a></h3>
<p>Closures and things that are callable implement one (or more) of three function traits in Rust. They are FnOnce, FnMut, and Fn. Closures that have data moved into them are actually like structs, with properties for their closed over values. For this reason they implement FnOnce (they can only be called once). </p>
<p><strong>The function traits cascade:</strong></p>
<ul>
<li>Fn can be used anywhere an FnMut and FnOnce can</li>
<li>FnMut can be used anywhere an FnOnce can</li>
<li>FnOnce can only be used where an FnOnce is specified</li>
</ul>
<p><em>The rules for what implements the traits are as follows:</em></p>
<ul>
<li>Fn - Accepts values that are owned or references as arguments</li>
<li>FnMut - Accepts values that have mutable references</li>
<li>FnOnce - uses move smenatics</li>
</ul>
<p>This should not be confused with <code>fn</code> which is a function pointer. Function pointers are used to refer to functions whoes identity (and as a result, size) are not known at compilation time. A pointer to a function needs to be used in this case, just like a Box&lt;&gt; gives us a pointer because the contents of a box might not be known.</p>
<p>With all that known, let's go back to the closure we're trying to make.</p>
<p>The parameter type of Closure::wrap is outlined as follows: </p>
<blockquote>
<p>A more direct version of <code>Closure::new</code> which creates a <code>Closure</code> from a <code>Box&lt;dyn Fn&gt;</code>/<code>Box&lt;dyn FnMut&gt;</code>, which is how it’s kept internally.</p>
</blockquote>
<p>To satisfy this the specification of <code>Closure:wrap</code> let's first add that <code>Box</code>. And in that box we'll put a closure.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cb = wasm_bindgen::closure::Closure::wrap(
	Box::new(
		|| {  
		    leptos::log!(&quot;Connected ok&quot;);  
		}
	)
);
<span class="boring">}</span></code></pre></pre>
<p>The Rust compiler will throw an error here, asking for us to be more specific:</p>
<blockquote>
<p>the trait <code>WasmClosure</code> is not implemented for closure <code>[closure@src/main.rs]</code></p>
</blockquote>
<p>We can tell the Rust compiler to treat our box as a specific type (which is will check against) with the <code>as Type</code> statement after the <code>Box</code>'s initialization.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cb = wasm_bindgen::closure::Closure::wrap(
	Box::new(
		|| {  
		    leptos::log!(&quot;Connected ok&quot;);  
		}
	) as Box&lt;dyn Fn()-&gt;()&gt;
);
<span class="boring">}</span></code></pre></pre>
<p>My hope is that now you'll look at this and read it as follows:</p>
<p>We're creating a closure but it needs to be stored in the heap. The value of the <code>Box</code> which specifies heap storage is a closure which doesn't have any arguments and does't close over any values. We can cast the internal type of the <code>Box</code> as a <code>dyn Fn()-&gt;()</code> because it's actual type won't be known until runtime and it accepts no arguments and returns no values (or returns a unit type <code>()</code>).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let cb = wasm_bindgen::closure::Closure::wrap(
	Box::new(
		|| {  
		    leptos::log!(&quot;Connected ok&quot;);  
		}
	) as Box&lt;dyn Fn()-&gt;()&gt;
);
<span class="boring">}</span></code></pre></pre>
<p>Note that in a lot of cases we can use the turbo fish to specify type arguments <code>Box::new</code> does not accept any generic as an argument so we need to specify it after the fact.</p>
<p>Let's keep climbing out of this hole back up to where we started, with trying to create a js_sys::Function that we can pass into the connection handler as a reference.</p>
<p>The result of this is whole thing is that we have a closure, but we don't have a reference to js_sys::Function. In fact, we need <code>Some(js_sys::Function)</code>.</p>
<p>Here we'll take our callback closure, well get it as a reference, then we'll cast that reference as a js_sys::Function with the turbo fish. And of course, we wrap it all in <code>Some()</code>. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Some(cb.as_ref().unchecked_ref::&lt;Function&gt;())
<span class="boring">}</span></code></pre></pre>
<p>One additional thing that we need to do here, for the sake of Leptos, is to add the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>on_cleanup(cx, move || {  
    drop(cb);  
});
<span class="boring">}</span></code></pre></pre>
<p>Leptos has a clean up routine that it runs when a context is closed. We need to move our callback closure, which is actually a handle, to the cleanup function's callback closure. </p>
<p><code>on_cleanup</code> is being told, &quot;Hey, when cx is cleaned up, run this closure!&quot; In that closure we've moved our callback and passed it into drop(). This means that it'll be cleaned up in WASM's memory, and JavaScript land will prune the closure on its side as well.</p>
<p>Our whole connection callback looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let connect_to_database = move |_|{  
  
    // Grabbed a reference to window  
    let window = window();  
  
    // Got a factory to be able to make an open connection  
    let idb = match window.indexed_db() {  
        Ok(Some(idb_factory)) =&gt; idb_factory,  
        _ =&gt; return  
    };  
  
    let idb_open_request = match idb.open(&quot;my-database&quot;) {  
         Ok(idb_open_request) =&gt; idb_open_request,  
         _ =&gt; return  
    };  
  
    let ok_cb = wasm_bindgen::closure::Closure::wrap(  
        Box::new(|| {  
            leptos::log!(&quot;Connected ok&quot;);  
        }) as Box::&lt;dyn Fn()-&gt;() &gt;  
    );  
  
    idb_open_request.set_onsuccess(  
        Some(ok_cb.as_ref().unchecked_ref::&lt;js_sys::Function&gt;())  
    );  
  
    on_cleanup(cx, move || {  
        drop(ok_cb);  
    });  
  
    let error_cb = wasm_bindgen::closure::Closure::wrap(  
        Box::new(|| {  
            leptos::log!(&quot;Connected error&quot;);  
        }) as Box::&lt;dyn Fn()-&gt;() &gt;  
    );  
  
    idb_open_request.set_onerror(  
        Some(error_cb.as_ref().unchecked_ref::&lt;js_sys::Function&gt;())  
    );  
  
    on_cleanup(cx, move || {  
        drop(error_cb);  
    });  
  
    // You are here.  
  
};
<span class="boring">}</span></code></pre></pre>
<p>So, here's where things get interesting. Our database connection is stored in the <code>result</code> property of our <code>IdbOpenDbRequest</code> if our connection was successful. What we want to do is create a signal so that we can store the <code>IDBDatabase</code> on success. It looks like our open database request may need to be used in a few scopes too. We can use Leptos signals to store this data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ( 
	idb_open_db_request, 
	set_idb_open_db_request 
) = create_signal::&lt;Option&lt;web_sys::IdbOpenDbRequest&gt;&gt;( cx, None );  

let ( 
	idb, 
	set_idb 
) = create_signal::&lt;Option&lt;web_sys::IdbDatabase&gt;&gt;( cx, None );
<span class="boring">}</span></code></pre></pre>
<p>It's important that we use <code>Option</code> types here so that we have the ability to set a default value of None. </p>
<p>We'll update our click handler closure with the <code>move</code> keyword, so that these signals will be moved into it when they're used. Keep in mind that signals support the <code>Copy</code> trait, so they'll be copied into the closurs without being moved from the scope they were defined it.</p>
<p>We'll also update the names of some of these variables so that they reflect their types and disambiguate from the new signals. There is a lot of idb this and idb that. </p>
<p>I present, the start of our on click connect to db handler closure/callback:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let connect_to_database = move |_|{  
  
    let window = window();  

	// Guard assignment
	// idb was renamed to idb_factory
    let idb_factory = match window.indexed_db() {  
        Ok(Some(idb_factory)) =&gt; idb_factory,  
        _ =&gt; return  
    };  

	// Guard assignment
	// updated to now set the reactive value
    match idb_factory.open(&quot;my-database&quot;) {  
         Ok(new_idb_open_request) =&gt; set_idb_open_db_request
	         .set(Some(new_idb_open_request)),  
         _ =&gt; return  
    };
<span class="boring">}</span></code></pre></pre>
<p>We need to update our callbacks for the database connection lifecycle to use our signals as well. In the <code>onsuccess</code> callback, we'll also need to pull the database connection out of the db connection requests <code>result</code>. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ok_cb = wasm_bindgen::closure::Closure::wrap(  
    Box::new(move|| {  
        
        leptos::log!(&quot;Connected ok&quot;);  

		// We'll get the request's value from the reactive system
        match idb_open_db_request.get() {  

			// If it is set we'll use it, referring to it herein
			// as ok_idb_open_request
            Some(ok_idb_open_request) =&gt; {  

				// We'll grab the result which in this context will
				// be an idb database. 
                match ok_idb_open_request.result() {  
		            
		            // If the result() was accessible
		            // it'll be a new_idb_connection
                    Ok(new_idb_connection) =&gt; {  

						// But this is from JavaScript so we have 
						// to unchecked_into with the Rust type.
                        let new_idb = new_idb_connection
	                        .unchecked_into::&lt;web_sys::IdbDatabase&gt;();  
                        
                        // We'll store this new connection in
                        // Leptos' reactive syste
                        set_idb.set(Some(new_idb));  
                    
	                    // We'll log the result from Leptos'
	                    // reactive system to confirm that it
	                    // worke as planned.
                        leptos::log!(&quot;{:?}&quot;, idb.get());  
                    },  
                    Err(_) =&gt; {}  
                }  
            },  
            None =&gt; {}  
        };  
  
    }) as Box::&lt;dyn Fn()-&gt;() &gt;  
);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>The above code is spaced wide and in a verbose syntax so that it is clear.</p>
</blockquote>
<p>The rest of the callback contains a our on error handler, and a new onupgrade needed.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	let error_cb = wasm_bindgen::closure::Closure::wrap(  
	    Box::new(move || {  
	        leptos::log!(&quot;Connected error&quot;);  
	    }) as Box::&lt;dyn Fn()-&gt;() &gt;  
	);  
	  
	let upgrade_cb = wasm_bindgen::closure::Closure::wrap(  
	    Box::new(move || {  
	        leptos::log!(&quot;Doing database upgrade or setup&quot;);  
	    }) as Box::&lt;dyn Fn()-&gt;() &gt;  
	);  
	  
	match idb_open_db_request.get() {  
	    Some(idb_odbr) =&gt; {  
	        idb_odbr.set_onsuccess(  
	            Some(ok_cb.as_ref().unchecked_ref::&lt;Function&gt;())  
	        );  
	        idb_odbr.set_onerror(  
	            Some(error_cb.as_ref().unchecked_ref::&lt;Function&gt;())  
	        );  
	        idb_odbr.set_onupgradeneeded(  
	            Some(upgrade_cb.as_ref().unchecked_ref::&lt;Function&gt;())  
	        );  
	    },  
	    None =&gt; {}  
	}  
	  
	on_cleanup(cx, move || {  
	    drop(ok_cb);  
	    drop(error_cb);  
	    drop(upgrade_cb);  
	});
}
<span class="boring">}</span></code></pre></pre>
<p>The on upgrade needed will fire when the database needs to be initialized or if the format of the database changes. This is where we will add our initialization code for the type of data stored in the database.</p>
<p>The interesting thing is that <code>onsuccess</code> will happen after the <code>onupgradeneeded</code>. As per the MDN documentation it looks like <code>onupgradeneeded</code> gets passed an event which we can use to extract the <code>event.target.result</code> out of.</p>
<pre><code class="language-javascript">// This event handles the event whereby a new version of
// the database needs to be created Either one has not
// been created before, or a new version number has been
// submitted via the window.indexedDB.open line above
// it is only implemented in recent browsers
DBOpenRequest.onupgradeneeded = (event) =&gt; {
  const db = event.target.result;
</code></pre>
<blockquote>
<p>From <a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBOpenDBRequest"># IDBOpenDBRequest MDN documentation</a></p>
</blockquote>
<p>We can update our closure with a parameter called event. We've changed the signature and size of the closure, which requres us to update the <code>as Box::&lt;dyn Fn()-&gt;()&gt;</code> to match. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let upgrade_cb = wasm_bindgen::closure::Closure::wrap(  
    Box::new(move |event| {  
        leptos::log!(&quot;Doing database upgrade or setup&quot;);  
    }) as Box::&lt;dyn Fn(Event)-&gt;() &gt;  
);
<span class="boring">}</span></code></pre></pre>
<p>We can't just write <code>Fn(Event) -&gt; ()</code> and we need to add the type for the parameter to work with it. So how do we go about finding th type? We can go to the <a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBOpenDBRequest/upgradeneeded_event">documentation page for the method</a> and take a look at the event type listed. It is stated as <a href="https://developer.mozilla.org/en-US/docs/Web/API/IDBVersionChangeEvent"><code>IDBVersionChangeEvent</code></a>. If I look that up but in Rust's required PascalCase <code>IdbVersionChangeEvent</code> I'll find this <a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.IdbVersionChangeEvent.html"><code>web_sys::IdbVersionChangeEvent</code></a>. We do need to add the feature to our cargo.toml as per the documentation as well. The feature is <code>IdbVersionChangeEvent</code>. By now you should be seeing a pattern of how we're progressing through solving this problem. We'll search for javascript examples (as Rust examples are few and far between), and then look up the web_sys equivalents.</p>
<p>Let's update the event with our expected type and the type in the <code>as Box::&lt;&gt;</code> part.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let upgrade_cb = wasm_bindgen::closure::Closure::wrap(  
    Box::new(move |event: web_sys::IdbVersionChangeEvent| {  
        leptos::log!(&quot;Doing database upgrade or setup&quot;);  
    }) as Box::&lt;dyn Fn(web_sys::IdbVersionChangeEvent) -&gt; ()&gt;  
);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Important:</strong> The upgrade callback will only run if the database has not been initialized or if it has a version change where the integer version number is greater than the existing version number. We haven't discussed version changes so for the time being you can change the name of the database to create a new one, always triggering the update callback.</p>
</blockquote>
<p>You'll frequently run into issues where you won't know whats the type is from the JavaScript side of things. In this case, we want to work with <code>web_sys::IdbVersionChangeEvent.target()</code> but we don't know what the return type of <code>target()</code> is. What I'll often do is log the value to the browser's console and look for hints for the type that I should cast the value into.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let upgrade_cb = wasm_bindgen::closure::Closure::wrap(  
    Box::new(move |event: web_sys::IdbVersionChangeEvent| {  
  
        match event.target() {  
            Some(event_target) =&gt; {  
                leptos::log!(&quot;{:?}&quot;, event_target);
            },
			None =&gt; {}  
        }    
	}) as Box::&lt;dyn Fn(web_sys::IdbVersionChangeEvent) -&gt; ()&gt;  
);
<span class="boring">}</span></code></pre></pre>
<p>The above logs <code>EventTarget { obj: Object { obj: JsValue(IDBOpenDBRequest) } }</code> to the console. This tells me that I can cast the value by calling <code>unchecked_into::&lt;IdbOpenDBRequest&gt;()</code>. It's important to note two things here; 1) The Rust trait has different casing than the JavaScript object type listed in JsValue; 2) You will likely need to enable the feature for that trait in web-sys.</p>
<p>We'll continue this same pattern to get the result, cast the result, and we'll be left with our database which we can initialize as a store for some form of data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let upgrade_cb = wasm_bindgen::closure::Closure::wrap(  
    Box::new(move |event: web_sys::IdbVersionChangeEvent| {  
  
        leptos::log!(&quot;Doing database upgrade or setup&quot;);  
        
        match event.target() {  
            Some(event_target) =&gt; {  
                let open_request = event_target
	                .unchecked_into::&lt;web_sys::IdbOpenDbRequest&gt;();  
                match open_request.result() {  
                    Ok(newly_opened_idb) =&gt; {  
                        let newly_opened_idb = newly_opened_idb
	                        .unchecked_into::&lt;web_sys::IdbDatabase&gt;();  
                        // Do things here  
                    }  
                    Err(_) =&gt; {}  
                }
			}, 
		   None =&gt; {}  
        }    
	}) as Box::&lt;dyn Fn(web_sys::IdbVersionChangeEvent) -&gt; ()&gt;  
);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Recall that we can use <code>web_sys::IdbDatabase</code> beacuse <code>web_sys</code> is brought into scope via <code>use leptos::*</code></p>
</blockquote>
<h3 id="structuring-the-database"><a class="header" href="#structuring-the-database">Structuring the database</a></h3>
<p>We now have a newly opened database in <code>newly_opened_idb</code>. We need to setup some tables in the database. IndexedDB doesn't use tables though. They use object stores. Each object in an object store is associated with a key. An object store can use a key path (you tell it how to source the key from the object being stored, <code>key_path</code>) or from a key generator (<code>auto_increment</code>). Object stores can contain objects and primitive data. If they contain objects, they may also have indexes which can enforce specific rules, and make queries faster.</p>
<h3 id="writing-data"><a class="header" href="#writing-data">Writing data</a></h3>
<h3 id="querying-data"><a class="header" href="#querying-data">Querying data</a></h3>
<h3 id="creating-stores-and-indexes-as-storage-bounds"><a class="header" href="#creating-stores-and-indexes-as-storage-bounds">Creating stores and indexes as storage bounds</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="initiative-tracker"><a class="header" href="#initiative-tracker">Initiative Tracker</a></h1>
<p>A tutorial project in which we build an initiative and game tracker for a role playing game like Dungeons and Dragons.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chat"><a class="header" href="#chat">Chat</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
