<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Building Apps with Rust</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Preface</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Acknowledgements</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> About this Book</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> About the Author</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> If you get stuck or lose steam</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Introductions</li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Programming</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> What it is</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Why it's worth it</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Why it's hard</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> Programmer Thinking</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Languages</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> Meaning and Interpretation</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Architectures</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> How your computer works</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> How the web works</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.3.</strong> The frontend-backend divide</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Tools and Languages</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">9.1.</strong> Bash and the terminal</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.2.</strong> Rust</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.3.</strong> Trunk</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.4.</strong> Web browsers</div></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Hello World</li><li class="chapter-item expanded "><a href="setup_intro.html"><strong aria-hidden="true">10.</strong> Setup</a></li><li class="chapter-item expanded "><a href="html_intro.html"><strong aria-hidden="true">11.</strong> Intro to HTML</a></li><li class="chapter-item expanded "><a href="view_macro_html.html"><strong aria-hidden="true">12.</strong> HTML and the view! macro</a></li><li class="chapter-item expanded "><a href="leptos_component_intro.html"><strong aria-hidden="true">13.</strong> Intro to Leptos Components</a></li><li class="chapter-item expanded "><a href="view_macro_variables.html"><strong aria-hidden="true">14.</strong> Variables and the view! macro</a></li><li class="chapter-item expanded "><a href="leptos_component_properties.html"><strong aria-hidden="true">15.</strong> Leptos Component properties</a></li><li class="chapter-item expanded "><a href="leptos_component_dynamic_content_separation.html"><strong aria-hidden="true">16.</strong> Leptos Component dynamic content separation</a></li><li class="chapter-item expanded "><a href="leptos_component_logging_events.html"><strong aria-hidden="true">17.</strong> Leptos Components witnessing events</a></li><li class="chapter-item expanded "><a href="leptos_component_update_from_event.html"><strong aria-hidden="true">18.</strong> Leptos Components reacting to events</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Building an Application</li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Design Patterns and Application Structure</li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Common Problems</li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Building Apps with Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <ol>
<li>Install Rust</li>
<li>Using up-to-date versions of rustc with <code>Nightly</code></li>
<li>Using up-to-date versions of Leptos from git</li>
</ol>
<hr />
<h3 id="1-install-rust"><a class="header" href="#1-install-rust">1. Install Rust</a></h3>
<p>Detail instructions on how to install Rust for your computer can be found here: https://www.rust-lang.org/tools/install</p>
<p>Installing rust will add a few things to your system.</p>
<ol>
<li>rustc - the rust compiler</li>
<li>rustup - a tool for managing rustc and the rust toolchain (https://rustup.rs)</li>
<li>cargo - the package manager and helper tool for rust (https://doc.rust-lang.org/stable/cargo/)</li>
</ol>
<h3 id="2-using-up-to-date-versions-of-rustc-with-nightly"><a class="header" href="#2-using-up-to-date-versions-of-rustc-with-nightly">2. Using up-to-date versions of rustc with <code>Nightly</code></a></h3>
<p>rustc is the rust compiler. It's possible to run different versions of the compiler. The Rust<br />
community is always working away adding new features. These new features are available<br />
immediately through nightly builds. Leptos, being brand new, makes use of some of these new<br />
features and currently requires <code>nightly</code> to run.</p>
<p>To confirm that you're using the <code>nightly</code> build of rustc (the rust compiler), open your<br />
shell/terminal and run the following command:</p>
<pre><code class="language-bash">rustc -V  
</code></pre>
<p>It should output something like this with 'nightly' in it:</p>
<pre><code class="language-bash">rustc 1.67.0-nightly (e631891f7 2022-11-13)  
</code></pre>
<p>If your version isn't the nightly build, run the following shell/terminal command:</p>
<pre><code class="language-bash">rustup default nightly  
</code></pre>
<p>Rustup is used to manage rustc. By calling the above, rustc is updated to us the nightly build<br />
as its default. You can change this to stable by using the following shell/terminal command:</p>
<pre><code class="language-bash">rustup default stable  
</code></pre>
<h3 id="3-using-up-to-date-versions-of-leptos-from-git"><a class="header" href="#3-using-up-to-date-versions-of-leptos-from-git">3. Using up-to-date versions of Leptos from git</a></h3>
<p>Leptos is changing all the time as well. It's recommended to grab the latest version directly<br />
from their git repository instead of from crates.io (https://crates.io/crates/leptos).</p>
<p>I'll go into detail on exactly how to do this when we start building our app. Don't stress if<br />
the following looks unfamiliar.</p>
<pre><code class="language-toml">[dependencies]  
leptos = { git = &quot;https://github.com/gbj/leptos&quot; }  
</code></pre>
<hr />
<h2 id="creating-your-first-app"><a class="header" href="#creating-your-first-app">Creating your first app</a></h2>
<ol>
<li>Using cargo to create a new rust app</li>
<li>Running your first rust app</li>
<li>Adding Leptos to your application as a dependency</li>
<li>Adding index.html to your application</li>
<li>Serving your index.html and bundling WASM with trunk</li>
<li>Updating client side HTML using Leptos</li>
</ol>
<hr />
<h3 id="1-using-cargo-to-create-a-new-rust-app-cargo-new"><a class="header" href="#1-using-cargo-to-create-a-new-rust-app-cargo-new">1. Using cargo to create a new rust app (<code>cargo new</code>)</a></h3>
<p>New rust projects are created with the following terminal command:</p>
<p>I'm calling my project <code>tut-leptos-client-side-event</code>, keeping in mind thst we're testing out how to handle a simple client side event.</p>
<pre><code class="language-bash">cargo new tut-leptos-client-side-event  
</code></pre>
<blockquote>
<p><strong>Did you know?</strong><br />
Cargo new will create the new project in your current working directory. You  can add path specifications to the application name to change where it's scafolded to. For example, <code>cargo new ~/dev/my-new-app</code> will create a new rust app in the <code>dev</code> directory inside your <code>~/</code> use home directory. If you see <code>~/</code> know that it's a shorthand for your user<br />
home. On OSX that would be <code>/Users/your-user-name</code>.</p>
</blockquote>
<p>When <code>cargo</code> runs with the <code>new</code> command, it creates the folder <code>tut-leptos-client-side-event</code>.</p>
<p>This folder gets setup with a few important things.</p>
<ol>
<li>A <code>src</code> directory that will contain all of our source code</li>
<li>A <code>src\main.rs</code> file, which contains our main function which is our <code>app</code>. This is called to<br />
tart our application and everything is run by calling code inside of it.</li>
<li>A <code>cargo.toml</code> file which contains meta data about our app, and it's dependences.</li>
<li>A <code>target</code> directory that will contain compiled data of our app. Ignore this folder for now.</li>
</ol>
<h3 id="2-running-your-first-rust-app-cargo-run"><a class="header" href="#2-running-your-first-rust-app-cargo-run">2. Running your first rust app (<code>cargo run</code>)</a></h3>
<p>Recall that we just made a new app with <code>cargo new tut-leptos-client-side-event</code>. Now we want to run it! Using the termninal/shell command <code>cargo run</code> will compile and run our app. Entering this terminal/shell command will not work right away. You'll get an error message:</p>
<blockquote>
<p>error: could not find <code>Cargo.toml</code> in ` ....... or any parent directory</p>
</blockquote>
<p>Cargo needs that cargo.toml file for context. It has information about which version of rust to compile for, which external bits of code (dependencies) need to be gathered to do the  compilation, and so forth.</p>
<p><code>C</code>hanging the <code>d</code>irectory of your <code>p</code>resent <code>w</code>orking <code>d</code>irectory to the directory created by <code>cargo new</code> will allow us to use the cargo.toml file for context, letting us compile the app.</p>
<blockquote>
<p><code>cd</code> â€“ is the terminal/shell command for changing directory</p>
</blockquote>
<blockquote>
<p><code>pwd</code> â€“ is the terminal/shell command for printing the present working directory</p>
</blockquote>
<p>The following list of commands need to be input individual, one line at a time. The first command changes the present working directory to our user home directory:</p>
<pre><code class="language-bash">cd ~/  
cargo new tut-leptos-client-side-event  
cd tut-leptos-client-side-event  
cargo run  
</code></pre>
<p>The application will take a brief period to compile and it'll print <code>Hello, world!</code> to your terminal/shell.</p>
<h3 id="3-adding-leptos-to-your-application-as-a-dependency"><a class="header" href="#3-adding-leptos-to-your-application-as-a-dependency">3. Adding Leptos to your application as a dependency</a></h3>
<p>We're going to add leptos to the mix as a dependency for our rust application.</p>
<p>First let's take a look at our stock <code>cargo.toml</code></p>
<pre><code class="language-toml">[package]  
name = &quot;tut-leptos-client-side-event&quot;  
version = &quot;0.1.0&quot;  
edition = &quot;2021&quot;  
  
# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html  
  
[dependencies]  
</code></pre>
<p>Note that we have no dependencies listed. All that exists is the heading <code>[dependencies]</code>.</p>
<p>Normally we'd use <code>cargo</code> to help us add dependencies. We'd need to call <code>cargo</code> in the<br />
context of our rust application's <code>cargo.toml</code> like we did with <code>cargo run</code>.</p>
<p>From within the <code>tut-leptos-client-side-event</code> folder we can call the following terminal/shell<br />
command:</p>
<pre><code class="language-bash">cargo add leptos  
</code></pre>
<p>Our <code>Cargo.toml</code> now includes the following:</p>
<pre><code class="language-cargo.toml">[dependencies]  
leptos = &quot;0.0.18&quot;  
</code></pre>
<p>In getting started we talked about using the git repository to grab the most up to date version of the dependency instead of the version published on crates.io (the rust package repository).</p>
<p>To do this we'll actually change the leptos entry to:</p>
<pre><code class="language-cargo.toml">leptos = { git = &quot;https://github.com/gbj/leptos&quot; }  
</code></pre>
<h3 id="4-adding-indexhtml"><a class="header" href="#4-adding-indexhtml">4. Adding index.html</a></h3>
<p>Our rust application will compile to wasm. That wasm will interact with a web page to create our client side experience. For this to work, we'll need to create an index.html.</p>
<p>Create this file in the root of your app, alongside cargo.toml. Your app directory should look like this:</p>
<pre><code>/tut-leptos-client-side-event  
	/src
		main.rs
	cargo.toml
	index.html
</code></pre>
<p>Inside the index.html should contain the following:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;  
&lt;html&gt;  
&lt;head&gt;  
    &lt;title&gt;Leptos App&lt;/title&gt;
	&lt;link data-trunk rel=&quot;rust&quot; data-wasm-opt=&quot;z&quot;/&gt;
&lt;/head&gt;  
&lt;body&gt;&lt;/body&gt;  
&lt;/html&gt;    
</code></pre>
<p>The important part of this is the following tag:</p>
<pre><code class="language-html">&lt;link data-trunk rel=&quot;rust&quot; data-wasm-opt=&quot;z&quot;/&gt;
</code></pre>
<p>A tool called <code>trunk</code> is going to eventually put all of these pieces together. The above <code>&lt;link&gt;</code> element will be replaced with rust application, compiled to wasm.</p>
<h3 id="4-serving-your-indexhtml-and-bundling-wasm-with-trunk"><a class="header" href="#4-serving-your-indexhtml-and-bundling-wasm-with-trunk">4. Serving your index.html and bundling WASM with trunk</a></h3>
<p>To use our application on the web, we need to serve it and bundle the WASM with the HTML.</p>
<p>We're going to use a tool called <code>trunk</code> which will do a few things:</p>
<ol>
<li>It'll serve index.html so that we can view it in our browser</li>
<li>It'll use <code>cargo</code> to compile the application to WASM</li>
<li>It'll attach the compiled WASM to our index.html, replacing <code>&lt;link data-trunk rel=&quot;rust&quot; data-wasm-opt=&quot;z&quot;/&gt;</code></li>
</ol>
<p>You will need to install the <code>trunk</code> tool. Instructions can be found here: https://trunkrs.dev/#install</p>
<p>For covenience, this will probably work:</p>
<pre><code class="language-shell">cargo install --locked trunk
</code></pre>
<p>To serve your app, use the following terminal/shell command while your application root is your present working directory:</p>
<pre><code class="language-shell">trunk serve
</code></pre>
<p>You'll see a variety of diagnostic information output to your prompt. The important line is this&quot;</p>
<pre><code class="language-shell">2022-11-26T15:40:19.251657Z  INFO ðŸ“¡ serving static assets at -&gt; /
2022-11-26T15:40:19.251861Z  INFO ðŸ“¡ server listening at http://127.0.0.1:8080
</code></pre>
<p>Listening at <code>127.0.0.1:8080</code> means that you can type that into your web browser to send a <strong>request</strong> to the server and it will provide the static files with your WASM bundled in (because it is a static file) back as the <strong>response</strong>.</p>
<p>You now have a web page!</p>
<h3 id="5-updating-client-side-html-using-leptos"><a class="header" href="#5-updating-client-side-html-using-leptos">5. Updating client side HTML using Leptos</a></h3>
<h4 id="51-understanding-mainrs"><a class="header" href="#51-understanding-mainrs">5.1 Understanding main.rs</a></h4>
<p>At this point we have a Rust application which compiles to WASM and we have a server running, listening at <code>127.0.0.1:8080</code> for requests, responding with our index.html and linked assets, most importantly our Rust application in WASM form.</p>
<p>What we don't have here is anything that updates our index.html or any form of interaction between our Rust application (WASM) and the DOM (Document Object Model â€” a name for the hierarchy of html elements/nodes) in the index.html.</p>
<p>We've addd leptos to our application as a dependency, and now we're going to put it to use.</p>
<p>If we look in our <code>src/main.rs</code> we can see the following:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {  
    println!(&quot;Hello, world!&quot;);  
}</code></pre></pre>
<p>Here we have a function (using the keyword <code>fn</code>) with the name <code>main</code>.  The <code>(</code> and <code>)</code> are like bookends that encapsulate a functions <strong>parameters</strong> (buckets to hold arguments passed to them) and <strong>arguments</strong> (values assigned to the parameters when called) that the function might use to run. In this case, the main function doesn't require anything to run, so it has nothing between its parenthesis after the function name. The following set of curley braces <code>{</code> and <code>}</code> encapsulate the function body here. This is what will be evaluated when the function is run; the work being done. This is the most minimal example of a <strong>function signature</strong>. There are more things that can be added but we'll get into those later.</p>
<p>The body of the function contains a single expression. Expressions need to end with <code>;</code>. You can think of it as a terminator for the end of an instruction or step that you want the application to perform.</p>
<p>Let's look at the content of this line.</p>
<p>We have <code>println!(&quot;Hello, world!&quot;);</code></p>
<p>We can look at this as <code>some-command</code>(<code>some-arguments</code>)<code>end</code></p>
<p>The command is <code>println!</code>, the argument is a sequence of characters wrapped by quotes as a convenient way to tell the compiler that you mean the characters and not other commands or variables, and an end of expression character <code>;</code> semicolon.</p>
<p>The command <code>println!</code> is provided by Rust's standard library for you to use to output text to the terminal. If you run your application you'll see <code>Hello, world!</code>, and this is why.</p>
<blockquote>
<p>Important: We've glossed over how to write your own functions with parameters. We've also skipped over how to write functions that return values. Don't worry, we'll cover that when appropriate.</p>
</blockquote>
<h5 id="macros"><a class="header" href="#macros">Macros</a></h5>
<p>We saw before that the main function is written as <code>fn main(){}</code>. There is no <code>!</code> after <code>main</code>. But there is a <code>!</code> after <code>println!</code>.</p>
<p>The <code>!</code> indicates that command is a macro. Macros are like code snippits or code templates that get expanded by the Rust compiler before it's final compilation.</p>
<p>There are function like macros, which use <code>()</code> to encapsulate their argumens. There are also procedural macros, which use <code>{}</code> to encapsulate a body of code which gets consumed by the macro.</p>
<p>As you can imagine, there is a lot involved in actually printing something to the terminal, but we can ignore the complexity with things like <code>println!</code>.</p>
<p>Macros have parameters which you can pass arguments to, just like functions. Leptos makes extensive use of macros to make our lives easier. They're wonderful!</p>
<blockquote>
<p>Important: Macros have the ability to parse (read through to understand/process) their arguments differently from standard Rust code. Keep in mind that the macro author is usually trying to do things that make life easier for the developer using their macro. Sometimes this includes reduction of noisey syntax that would normally be required, or inferences that can be assumed.</p>
</blockquote>
<h4 id="52-updating-mainrs-to-use-leptos"><a class="header" href="#52-updating-mainrs-to-use-leptos">5.2 Updating main.rs to use Leptos</a></h4>
<p>Now that we understand how Rust functions work we can start to bring Leptos into our main.rs.</p>
<p>We do this by telling the compiler that we want to <code>use</code> leptos.
We've added <code>leptos</code> as a dependency in our cargo.toml, so it now exisgts is our 'application universe' as a thing.</p>
<p>But, it doesn't exist in our <code>main.rs</code> because we haven't brought it into scope yet. Bringing things into scope is like bringing things to a workbench or crafting table to use. You need those things at hand, where you're working, so that when you refer to them the compiler knows what you mean and has the bits of code to actually use.</p>
<p>When we write <code>use leptos::*;</code> at the top of our main.rs file, we're telling Rust, <code>use</code> and think called <code>leptos</code> which you should be aware of because we defined it in our cargo.toml, and bring ALL of it's pieces into scope for us to use. The <code>::</code> is a separator the same a slash is a separator for hierarchy in your computer's file system. The <code>*</code> refers to 'everything'.</p>
<p><code>use leptos::*;</code></p>
<p>reads as</p>
<p>use everything from leptos.</p>
<p>To visualize this, think of it as taking a box of tools called &quot;Leptos&quot; and dumping all of them out onn your work bench. You can now grab any one of them for use.</p>
<h4 id="53-updating-fn-main-to-interact-with-your-html"><a class="header" href="#53-updating-fn-main-to-interact-with-your-html">5.3 Updating fn main() to interact with your html</a></h4>
<p>In our main.rs we have a <code>fn main(){}</code>. Currently it prints &quot;Hello, world!&quot; to our standard out (terminal/console).</p>
<p>What we want to do is to change the HTML in index.html when the WASM loads, which is also when the <code>fn main()</code> runs.</p>
<p>We'll use a function called <code>mount_to_body</code>, which is provided as a tool in <code>leptos</code>, made available in this scope (this main.rs file) with the use statement.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

fn main() {
	mount_to_body()
}</code></pre></pre>
<p><code>mount_to_body</code> requires some arguments to run correctly.</p>
<p>Specifically, it requires a closure. It requires a value that is actually 'runable' or 'callable'.</p>
<h5 id="closures"><a class="header" href="#closures">Closures</a></h5>
<p>A closure is functionality as a <strong>first class citizen</strong>. This means that it's a function that can be stored as a value and passed around to be called later.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_hi(){
	println!(&quot;Hi&quot;);
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>A standard function definition.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">fn main(){
	// let tells the compiler to assign
 	// the value of greeter to whatever is 
 	// after the = and before the semicolon.
	let greeter = || {
		println!(&quot;Hi&quot;);
	};
}</code></pre></pre>
<blockquote>
<p>Single line comments in Rust are prefixed by <code>//</code> at the beginning of the commend. These tell the compiler to ignore anything after it.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>|| {
	println!(&quot;Hi&quot;);
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>A closure</p>
</blockquote>
<p>The above closure syntax is like a function, but it doesn't have a name because we're expecting to assign the functionality to a name. Like we did with greeter above.</p>
<p>The parenthesis that normally encapsulate a functions arguments are converted to pipe characters to diambiguate the two. The body of the closure, just like the body of a function, is encapsulated by curly braces.</p>
<p>The following shows how a function and a closure can be called:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print_hi(); // This was a function
greeter();  // This was a value `greeter`
<span class="boring">}</span></code></pre></pre>
<p>The coolest thing here is that we can see both <code>print_hi</code> and <code>greeter</code> are names that exist in or applications context. They're ideas. Both of them are callable. And we can call them by adding parenthesis at the end.</p>
<p>This starts to hint at some of the underlying simplicity of a lot of programming. At the end of the day, we're giving names to things so that we can specify to the computer, what is what. Then we evaluate or run a bit of functionality, and give the result a name so that we can do something else after. It's this over and over again, all the way down.</p>
<h5 id="using-mount_to_body"><a class="header" href="#using-mount_to_body">Using mount_to_body</a></h5>
<p>Recall that our application's main.rs looked like this</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

fn main() {
	mount_to_body()
}</code></pre></pre>
<p>We have <code>mount_to_body</code> function being called when the application runs as WASM, when index.html is server with the WASM resource.</p>
<p>This function needs functionality to call. It needs a closure. We have the opportunity to tell it what to do with the assumption that when mount_to_body runs, it'll provide us the context in which it's running. This of this as a scope. We can make this assumption because mount_to_body specifies that it needs a closure that makes use of an argument, which we know to be context, abbreviated here as <code>cx</code>.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

fn main() {
	mount_to_body(|cx|{})
}</code></pre></pre>
<p>The above shows what an empty closure being passed to mount_to_body looks like. What this doesn't show is that the closure needs to return something that can be mounted.</p>
<p>If you ran the above you're probably receive an error like:</p>
<pre><code class="language-bash">T: Mountable, required by this bound in `leptos::mount_to_body`
</code></pre>
<p>The error messages will get easier to read over time, but it essentially says, &quot;The return type of the closure can't be used by the internals of mount_to_body. It was expecting something specific to come out of your instructions.&quot;</p>
<p>To solve this problem we're going to use the <code>view!</code> macro provided by leptos.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

fn main() {
	mount_to_body(|cx|{
		view! {  
	        cx,  
	        &lt;h1&gt;&quot;Hello, world!&quot;&lt;/h1&gt;  
	    }
	})
}</code></pre></pre>
<p>We've written the following in the body of the closure, being provided to <code>mount_to_body</code> as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>view! {  
	cx,  
	&lt;h1&gt;
		&quot;Hello, world!&quot;
	&lt;/h1&gt;  
}
<span class="boring">}</span></code></pre></pre>
<p>This procedural macros <code>view!</code> has a body which starts with cx, the context that will be provided to it by mount_to_body when it's run (again, this is inside mount_to_body and evaluated at a later time) and the view or html to mount.</p>
<p>There must be one top level item and all text needs to be quoted. It's a JSX like syntax and beautifully streamlined to write.</p>
<p>If you had <code>trunk serve</code> running this whole time, you can visit http://127.0.0.1:8080 to see your &quot;Hello, world!&quot;</p>
<p>Or, make sure your present working directory is the root of your application, type <code>trunk serve</code> and visit http://127.0.0.1:8080 to see your first working leptos WASM client side awesomeness!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intro-to-html"><a class="header" href="#intro-to-html">Intro to HTML</a></h1>
<h1 id="what-we-know"><a class="header" href="#what-we-know">What we know</a></h1>
<p>In <a href="/setup_intro">Setup</a> we developed a cursory understanding of:</p>
<ul>
<li>how to create a generic Rust application</li>
<li>how to add <code>Leptos</code> as a dependency to our Rust application</li>
<li>how to serve a file with <code>trunk</code></li>
<li>how to update an HTML file with Rust, using <code>Leptos</code>'s <code>mount_to_body</code> function and it's <code>view!</code> macro</li>
</ul>
<h1 id="what-well-learn"><a class="header" href="#what-well-learn">What we'll learn</a></h1>
<ul>
<li>Working with HTML and developing a mental model</li>
</ul>
<h1 id="where-were-at"><a class="header" href="#where-were-at">Where we're at</a></h1>
<p>Code from our <code>main.rs</code> looks like this:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;h1&gt;&quot;Hello, world!&quot;&lt;/h1&gt;  
        }  
    })  
}</code></pre></pre>
<blockquote>
<p>The <code>main</code> function <code>fn</code> is run when our application runs as WASM.</p>
<p>Recall that the <code>trunk</code> tool uses <code>cargo</code> also a tool with <code>rustc</code> to compile it to the WASM target, which gets served and linked to our index.html. We view (request) the page in our browser, loading the html and linked WASM, kicking the whole thing off.</p>
<p>When the application runs the function <code>mount_to_body</code> is called (runs), which we pass (or provide) a closure (a big of functionality stored as a value) as an argument to it's callback parameter (the bucket that holds things that <code>mount_to_body</code> needs to run, <em>&quot;function dependencies&quot;</em>).</p>
<p>When <code>mount_to_body</code> runs, it takes the  functionality we've provided as a closure (a <em>strategy</em> if you will) and calls it (makes it run) with its runtime context <code>cx</code>. This does all of the heaving lifting to write our heading the body of our HTML page in index.html</p>
</blockquote>
<h1 id="lesson-working-with-html-and-developing-a-mental-model"><a class="header" href="#lesson-working-with-html-and-developing-a-mental-model">Lesson: Working with HTML and developing a mental model</a></h1>
<p>We're not doing much more than creating a static template. If this is all you need, better to stick with a plain old HTML file.</p>
<h2 id="html-elements-and-tags"><a class="header" href="#html-elements-and-tags">HTML Elements and Tags</a></h2>
<p>HTML is made up of Elements. There are a whole list of HTML elements ready for use and supported by all current browsers, from heading and paragraphs to form elements for collecting data from users like. These Elements are written using HTML tags, <code>&lt;h1&gt;</code>, <code>&lt;p&gt;</code>, and <code>&lt;input&gt;</code> respectively.</p>
<h3 id="tags-with-content"><a class="header" href="#tags-with-content">Tags with content</a></h3>
<p>Some tags have content. The syntax is to encapsulate the content or wrap it with opening and closing tags. The closing tag has a slash before the tag name.</p>
<pre><code class="language-html">	&lt;h1&gt;Some Content&lt;/h1&gt;
</code></pre>
<blockquote>
<p>This Heading 1 tag has content, which requies a closing tag so that it's content can be wrapped/encapsulated.</p>
</blockquote>
<p>What's neat about this opening and closing tag business is that it's not <em>that</em> different from when we called a function and provided an argument (value) for it's parameter. As time goes on you'll start to see a pattern emerging. The above isn't going to look at different from:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	h1(&quot;Some Content&quot;)
<span class="boring">}</span></code></pre></pre>
<h3 id="tags-without-content"><a class="header" href="#tags-without-content">Tags without content</a></h3>
<p>Some tags don't have content. To express a tag without content we add a backslash at the end of the tag of the tag. This tells browsers that there is no closing tag.</p>
<pre><code class="language-html">&lt;hr /&gt;
</code></pre>
<blockquote>
<p>This Horizontal Rule tag doesn't have a closing tag</p>
</blockquote>
<h3 id="tag-configuration-with-properties-and-attributes"><a class="header" href="#tag-configuration-with-properties-and-attributes">Tag configuration with properties and attributes</a></h3>
<p>HTML Elements can be configured by setting values for supported properties and attributes. If you've played around with HTML before you'll probably have seen commong properties like <code>id</code> and <code>class</code>:</p>
<pre><code class="language-html">&lt;h1 id=&quot;my-unique-heading&quot;&gt;Hello, world!&lt;/h1&gt;
</code></pre>
<blockquote>
<p>Some poperties have specific requirements for their values. <code>id</code> for example, should have a unique value across all Elements on the page.</p>
</blockquote>
<pre><code class="language-html">&lt;input name=&quot;first-name&quot; placeholder=&quot;Enter your name...&quot; type=&quot;text&quot; /&gt;
</code></pre>
<blockquote>
<p>The input tag has a <code>type</code> which completely changes how its rendered (displayed to the user).</p>
</blockquote>
<h3 id="the-browser-as-interpreter"><a class="header" href="#the-browser-as-interpreter">The browser as interpreter</a></h3>
<p>When you send a request to the server, it returns a response which has a body (the data, often as text) and headers (meta information about the body). Information in the headers tells the browser how to interpret the body.</p>
<blockquote>
<p>Analogy time: Imagine if you went to a library and asked a librarian for a book. This is like you, the web browser, submitted a request to a server. The librarian (the server) will then provide a response to your request. They may return with the book and a slip of paper saying, &quot;I found the book and this book is in english.&quot; We can now use our knowlege of the english language to parse the book (turn it into meaningful data) and understand it.</p>
</blockquote>
<p>Traditionally servers respond to web requests telling the browser that the body's response  is text/html. A browser very deeply wants to render your page for you, so it dutifully reads through what it's been told is html, parses it into meaningful data (the DOM, Document Object Model), and renders it to the screen.</p>
<p>Things like:</p>
<pre><code class="language-html">&lt;input name=&quot;first-name&quot; placeholder=&quot;Enter your name...&quot; type=&quot;text&quot; /&gt;
</code></pre>
<p>Turn more into an object (a thing) with the following properties:</p>
<pre><code>HTML Element Type = &quot;input&quot;
name = &quot;first-name&quot;
placeholder = &quot;Enter your name...&quot;
type = &quot;text&quot;
</code></pre>
<blockquote>
<p>This isn't real code, but it does look a lot like what we'll call a <strong>struct</strong> in Rust later. Once again we can see similar shared underlying principles. This idea of &quot;a thing with stuff&quot; comes up time and time agin.</p>
</blockquote>
<p>There may be bits of information that the browser doesn't understand. Instead of crashing it often ignores this unknown information, or makes assumptions about it to still continue to render the page.</p>
<p>Browsers and HTML rendering engines are extremely complex and down right magical. We can throw so much at them and they keep on going.</p>
<h3 id="what-the-element"><a class="header" href="#what-the-element">What the element?</a></h3>
<p>Recall that before we talked about HTML elements, properties, and attributes. It might feel like HTML is an expressive programming language, but it is actually what we would call a DSL (Domain Specific Language). They're instructions that pertain specific to rendering web pages that tell the browser our intent. We <strong>declare</strong> what we want and it's the browser's <strong>imperative</strong> to decide how to render it.</p>
<p>In standard HTML you can not just make up properties or Elements/tags. It might look like we're choosing to write <code>h1</code> because it's convenient for us to think about a primary heading as a <code>h1</code>, but this is actually part of the specification of HTML.</p>
<p>Developers can now create their own custom elements with Javascript, but we're going to ignore that for now. Just know that it does exist but more work is required than just writing you own tag names.</p>
<h3 id="what-does-this-mean-for-the-view-macro-and-which-html-elements-we-can-use-in-it"><a class="header" href="#what-does-this-mean-for-the-view-macro-and-which-html-elements-we-can-use-in-it">What does this mean for the <code>view!</code> macro and which HTML elements we can use in it?</a></h3>
<p>The content that we place in our <code>view!</code> macro is interpreted by the <code>view!</code> macro when the rust compiler expands it. It takes what we've provided and says, &quot;Ok, so this is what you want... but the rest of the application can't work with this. What you've written isn't actually HTML and it's not actually Rust. I'll parse this input and rewrite it so that the rest of our application can use it, saving you from the verbosity and potentially error prone nature of writing it yourself.&quot;</p>
<p>In the next lesson we'll learn about making components which we can compose and how Leptos allows us to have custom components/elements while still generating HTML that the browser can parse and understand according to the HTML spec.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="html-and-the-view-macro"><a class="header" href="#html-and-the-view-macro">HTML and the <code>view!</code> macro</a></h1>
<h2 id="what-we-know-1"><a class="header" href="#what-we-know-1">What we know</a></h2>
<ul>
<li>HTML is a specification for a domain specific language that is parsed by a web browser to render a web page</li>
<li>The web browser will do its best to render a page, ignoring or gracefully interpreting code in a page that doesn't match the HTML specification.</li>
<li>The <code>view!</code> macro accepts its arguments between curly braces <code>{}</code>, accepting a context <code>cx</code> and HTML like mark-up.</li>
</ul>
<h1 id="what-well-learn-1"><a class="header" href="#what-well-learn-1">What we'll learn</a></h1>
<ul>
<li>Creating custom components</li>
</ul>
<h1 id="where-were-at-1"><a class="header" href="#where-were-at-1">Where we're at</a></h1>
<p>Code from our <code>main.rs</code> looks like this:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;h1&gt;&quot;Hello, world!&quot;&lt;/h1&gt;  
        }  
    })  
}</code></pre></pre>
<blockquote>
<p>We can see that after the context variable we have some HTML like text. If this were HTML, you'd have a heading that reads <strong>&quot;Hello, world!&quot;</strong> with the quotes displaying. However, this isn't pure HTML and the macro will process the template to remove the quotes.</p>
</blockquote>
<h2 id="view-macro-syntax"><a class="header" href="#view-macro-syntax"><code>View!</code> macro syntax</a></h2>
<p>The <a href="https://docs.rs/leptos/latest/leptos/macro.view.html">view! macro documentation</a> is very nicely detailed with details about it's basic and advanced syntax. It's a JSX like syntax. We'll slowly touch on all of the features as we continue to learn Rust and <code>Leptos</code>.</p>
<p>For now, the important thing to remember is that strings need to be quoted.</p>
<p>@todo, highlight that a view contains element markup and text nodes. That's it</p>
<h2 id="adding-more-to-a-view"><a class="header" href="#adding-more-to-a-view">Adding more to a view</a></h2>
<p>You can continue to add other html elements as if you were writing plain HTML. Line breaks and indentation will not break the syntax. HTML code often has a lot of line breaks or white space from code formatting. Web browsers will ignore this unless you specify that you want the white space retained. We won't go into that in this guide. Multiple space characters will get coalesced into a single space.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>view! {  
	cx,  
	&lt;h1&gt;&quot;Hello, world!&quot;&lt;/h1&gt;
	&lt;p id=&quot;NiceAffirmation&quot;&gt;&quot;
		I know things are hard, 
		but I think you're doing great!&quot;
	&lt;/p&gt;
}  
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Note that we have an id attribute set for the paragraph with a quoted value.</p>
</blockquote>
<h2 id="custom-elements"><a class="header" href="#custom-elements">Custom elements</a></h2>
<p>Recall that our Rust <code>view!</code> macro input is not actually HTML. It gets processed and converted into HTML. This gives us some extra freedom, like the ability to write our own custom elements in Rust with their own templates.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>view! {  
	cx,  
	&lt;h1&gt;&quot;Hello, world!&quot;&lt;/h1&gt;
	&lt;NiceAffirmation /&gt;
}  
<span class="boring">}</span></code></pre></pre>
<p>The above code will be converted into the following HTML:</p>
<pre><code class="language-html">&lt;h1&gt;Hello, world!&lt;/h1&gt;
&lt;NiceAffirmation&gt;&lt;/NiceAffirmation&gt;
</code></pre>
<p>The browser doesn't know what to do with the tag <code>&lt;NiceAffirmation&gt;</code>, so it treates it as a generic element that doesn't do anything.</p>
<p>We can define a template for our &quot;NiceAffirmation&quot; component and have it render our as if the element existed in the HTML spec. In a sense, we can make up our own specification for our own application using domain specific component names, and then let <code>Leptos</code> handle the rest.</p>
<p>In <code>Leptos</code> we call custome elements <code>components</code></p>
<h2 id="registering-a-custom-element-with-a-component-function"><a class="header" href="#registering-a-custom-element-with-a-component-function">Registering a custom element with a component function</a></h2>
<p>You're probably already thinking, &quot;I can imagine how I would want to break my application down into small components which I can compose/combine together.&quot; Thankfully, <code>Leptos</code> makes that exceptionally easy to do.</p>
<p>We do this by writing a function that returns (or evaluates to) the result of a <code>view!</code> macro.</p>
<p>In the following example we're using a pseudo-HTML component tag (our <strong>Leptos component</strong> tag) <code>&lt;NiceAffirmation /&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>view! {  
	cx,  
	&lt;h1&gt;&quot;Hello, world!&quot;&lt;/h1&gt;
	&lt;NiceAffirmation /&gt;
}  
<span class="boring">}</span></code></pre></pre>
<p>When the macro runs and expands the code, it'll look for a function that can be used to replace the <code>&lt;NiceAffirmation&gt;</code> tag. Leptos is magical and will do this look up for us, calling that function and embedding the the correct template as a replacement for our <strong>Leptos component</strong> tag.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
pub fn NiceAffirmation(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;You look nice today.&quot;&lt;/p&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>The definition of the function that will handle template generation for <code>&lt;NiceAffirmation /&gt;</code></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-we-know-2"><a class="header" href="#what-we-know-2">What we know</a></h1>
<ul>
<li>The <code>view!</code> macro has a body encapsulated by <code>{...}</code> with two components, the context/scope and the template, separated by a comma.</li>
<li>The <code>view!</code> macro can accept:
<ul>
<li>Quoted text</li>
<li><em>HTML element</em> tags, written in lower case</li>
<li><em>Custom web component</em> element tags, written in kebab-case (i.e. my-custom-component)</li>
<li><em>Leptos component</em> tags, written in PascalCase (i.e. MyCustomComponent)</li>
</ul>
</li>
<li>Leptos components only know what to render in place of their component tag if we provide a function with the same name as the component (in PascalCase), with <code>#[component]</code> on the line directly before the function's definition.</li>
<li>Rust's basic function syntax of <code>fn my_function_name(){}</code>.</li>
</ul>
<h1 id="what-well-learn-2"><a class="header" href="#what-well-learn-2">What we'll learn</a></h1>
<ul>
<li>Creating custom components</li>
<li>How components work</li>
</ul>
<h1 id="the-lesson"><a class="header" href="#the-lesson">The lesson</a></h1>
<p>In the previous lesson we presented the following code for a Leptos component, but we did not explain the code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn NiceAffirmation(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;You look nice today.&quot;&lt;/p&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Above we have a Leptos component (render function) which when called yield the result of a view! macro. Within the macro we have our standard two pieces, the context/scope, and the template mark-up.</p>
</blockquote>
<h3 id="breakdown"><a class="header" href="#breakdown">Breakdown</a></h3>
<h4 id="the-component-attribute-and-meta-programming"><a class="header" href="#the-component-attribute-and-meta-programming">The <code>#[component]</code> attribute and &quot;meta programming&quot;</a></h4>
<p>Rust makes use of a special attribute syntax which the compiler can use to process your source code before it's compiled. This is often called &quot;meta programming&quot; because part of our application is responsible for writing another part of our application.</p>
<p>Library authors include features like this so that users of the library can focus on writing domain specific code (code relating to the specific problem they're solving).</p>
<p>The effect of this is that we, the user of Leptos, only have to worry about writing a function that tells the application what the result of rendering a component yields (returns). What we don't have to worry about is writing the code to make sure the function is called if the component is used in other <code>view!</code> macros.</p>
<h4 id="function-definition-arguments-types-and-returns"><a class="header" href="#function-definition-arguments-types-and-returns">Function definition, arguments, types, and returns</a></h4>
<p>The following line in our code is a function definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn NiceAffirmation(cx: Scope) -&gt; Element {  
<span class="boring">}</span></code></pre></pre>
<p>It defines the idea of doing some work with a noun (the function's name) so that we can refer to it in the context of our application.  This idea of, &quot;we know nothing until we define it,&quot; is an important concept in communication in general but especially so in programming.</p>
<h5 id="breaking-down-the-function-definition"><a class="header" href="#breaking-down-the-function-definition">Breaking down the function definition</a></h5>
<p><code>fn</code> - The definition starts with this keyword which is an abbreviation for function. It tells the compiler that we're about to define a term for a process/task that can be done (called).</p>
<p><code>NiceAffirmation</code> - The name of the function in PascalCase. This name allows us to refer to the function so that if we say, &quot;Hey computer, do NiceAffirmation,&quot; it'll know where to look up what that means. It is important to note that standard function naming in Rust is written with snake_case, all lowercase letters with words separted by underscores. Leptos components use PascalCase so that the function responsible for rendering a component will match its tag name. <em>This deviates from standard Rust convention</em></p>
<p><code>(...)</code> - Some tasks require additional &quot;things&quot; for the task to be carried out. I use the term things because the requirements can be varied. Some tasks may require specialized tools (other tasks/processes), some tasks may require something to be worked upon (a subject), and some tasks require anciliary information that act as a reference (reference data). Parenthesis after the function name encapsulates this required data. These are called <strong>function parameters</strong> and they are written out separated by a comma. The values passed into these parameteres are called <strong>function arguments</strong>.</p>
<p><code>cx: Scope</code> - Each parameter listend between  <code>(</code>and <code>)</code> in a function's definition are written using a name that we can use to refer to it when doing  the work in the body of the function and the classification of what it is (it's type). The parameter name exemplified here as <code>cx</code> is written in snake_case and the type, written here as <code>Scope</code> is written in PascalCase. This helps disambiguate the two. <strong>Rust requires us to know the type of everything!</strong> But when you think about it, this makes complete sense. For example, imagine if we described a task called <code>paint_fruit_still_life</code>. To do this work we need an artist who must be a Painter, and a subject to paint which must be Fruit. It's important to note that we're just making this stuff up. We're describing the interaction of data to the application. Programming is often about setting up relationships. We would also want to guarantee that we always expect the result of this task to be a Painting. <em>It is up to us to define what it means to be a Painter, what Fruits are, and what a Painting is!</em> A definition for this could look like <code>fn paint_fruit_still_life( artist: Painter, subject: Fruits) -&gt; Painting {}</code>.  In case of Leptos components, the first thing we're accepting is the runtime context which we give the name <code>cx</code> which is of the type <code>Scope</code>. Scope is defined by Leptos and brough into the context of our application with the previously described <code>use leptos::*</code> (include all <code>*</code>) use statement.</p>
<blockquote>
<p>It's kind of fun to think about how much we imply these types in real life. If any of you have interacted with kids you can witness first hand how important it is to define the nouns we use and be clear about expectations.</p>
</blockquote>
<p><code>-&gt; Element</code> - The thin arrow followed by the name of a type indicates the result of running a function or doing a task. In the case of our Leptos component, the return type is an Element. This type is defined by Leptos and imported by our previously described <code>use leptos::*</code> (include all <code>*</code>) use statement. Some functions may not have this if they do not return anything as the result of doing their work.</p>
<h4 id="function-body-and-expressions"><a class="header" href="#function-body-and-expressions">Function body and expressions</a></h4>
<p>The body of a function is encapsulated by curly braces.<code>{...}</code>.  This is a scope. What happens in the scope, stays in the scope. A function will return the result of evaluating the last statement of its function body. You can think of statements like sentences, only the end with semicolons. This means that the last statement without a semicolon acts as the 'final word' for what a function yields. This is why the <code>view!</code> macro in our example does not have a semicolon at the end. The function runs, the last expression is the view! macro, which when evaluated yields an Element. Rust allows you to cut your application short by placing the <code>return</code> keyboard before a statement as well.</p>
<h1 id="what-we-learned"><a class="header" href="#what-we-learned">What we learned</a></h1>
<p>By defining the following function with the <code>#[component]</code> annotation, we can tell Leptos how to render specific HTML in place of a Leptos component tag in other <code>view!</code> macro's templates.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;NiceAffirmation /&gt;  
        }  
    })  
}

#[component]  
fn NiceAffirmation(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;You look nice today.&quot;&lt;/p&gt;  
    }  
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-and-the-view-macro"><a class="header" href="#variables-and-the-view-macro">Variables and the view! macro</a></h1>
<h1 id="what-we-know-3"><a class="header" href="#what-we-know-3">What we know</a></h1>
<ul>
<li>The <code>view!</code> macro can be used to create html</li>
<li>The view! macro can contain <em>custom web components</em> (using kebab-case names and requiring at least one hypen) and <em>Leptos components</em> (using PascalCase)</li>
<li>Leptos components are defined by defining a function with the name of the component using a standardized function signature (parameters and return type), and adding meta data to a function so that rust will pre-process the function and turn it into a component function for you behind the scenes.</li>
<li>Leptos components can be nested in other Leptos components</li>
</ul>
<h1 id="what-well-learn-3"><a class="header" href="#what-well-learn-3">What we'll learn</a></h1>
<ul>
<li>How to a number text in a variable (define a variable)</li>
<li>A introduction to types and memory safety</li>
</ul>
<h1 id="the-lesson-1"><a class="header" href="#the-lesson-1">The lesson</a></h1>
<p>In the previous lesson we presented the following code</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;NiceAffirmation /&gt;  
        }  
    })  
}

#[component]  
fn NiceAffirmation(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;You look nice today.&quot;&lt;/p&gt;  
    }  
}
</code></pre></pre>
<h2 id="adding-a-feature"><a class="header" href="#adding-a-feature">Adding a feature</a></h2>
<p>Along with this affirmation we'd like to add some kind of lucky number for the day to go with this affirmation.</p>
<p>This example uses integers because they are a simple data type in Rust and a good entry point into variables and Rust's type system. It's a silly example, I know. ^.^</p>
<p>We are going to add some things to our code and change a few existing components. The process of splitting code up and moving it around to allow for different changes is known as <em>Refactoring</em>.</p>
<p>First, have a read through the result to see if you can spot the changes. We're using all of the same principles as before.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
           &lt;NiceAffirmation /&gt;  
           &lt;LuckyNunber /&gt;
        }  
    })  
}

#[component]  
fn NiceAffirmation(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;You look nice today.&quot;&lt;/p&gt;  
    }  
}
#[component]  
fn LuckyNumber(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is 4&quot;&lt;/p&gt;  
    }  
}
</code></pre></pre>
<h3 id="developer-thoughts"><a class="header" href="#developer-thoughts">Developer thoughts</a></h3>
<p>Throughout these tutorials I will try to include the innner monologue that I have when thinking through a problem in the hope that it'll help you all develop your own. I also hope that the simplicity of the steps will help keep you focused when trying to work through your own problems. Don't get too far ahead of the next step in you mind. Keep this simple and break things down into small improvements. You do not need to completely solve the problem in one go. <em>Write, review, revise, repeat.</em></p>
<p>The steps to get to the above code are as follows:</p>
<ol>
<li>I need to add a new component for the LuckyNumber, so I'll write the component with a lucky number.</li>
<li>I need to add the component to the web page. I could make a new component called MorningGreeting, which has a NiceAffirmation and a LuckyNumber, but I stopped myself. This extra component would add complexity without adding anything beneficial just yet. I do not need to group these two Leptos components. They do not need to be separated from anything else. This is an important lesson to not prematurely cut your code apart and make things too comlicated. As a solution I'll just add the LuckyNumber component to my main function's view.</li>
<li>I can't change the value of the lucky number. Hooray, I've outlined an improvement and a next task. I need to find a way to be able to provide a number to my component. My component needs a parameter for the lucky number which I can provide as an argument (value).</li>
</ol>
<h2 id="tokens-and-values-in-view-components"><a class="header" href="#tokens-and-values-in-view-components">Tokens and values in <code>view!</code> components</a></h2>
<p>We've established that we need to take the 4 and make it something that can change. We need to add a token, like a symbol, as a placeholder. We need a way of saying &quot;use whatever we're calling the_lucky_number here.&quot;</p>
<p>In the <code>view!</code> macro we know that text input needs to be encapsulated by <code>&quot;...&quot;</code> quotes.</p>
<p>Values need to be encapsulated by <code>{...}</code> curley braces.</p>
<p>We'll update the following line:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        &lt;p&gt;&quot;Today's lucky number is 4&quot;&lt;/p&gt;  
<span class="boring">}</span></code></pre></pre>
<p>To look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
    }  
}

<span class="boring">}</span></code></pre></pre>
<p>Note that the quoted text no longer has the number <code>4</code>. Importantly, note that the token we've added after the string is encapsulated by curley braces. There's a space between string's closing quote and the token's first curley brace. This space will not be printed, it's just for ease of reading for developers.</p>
<p>But there's a problem. We've used <code>the_lucky_number</code> (an idea/thing/noun) but we haven't defined <em>what</em> the this idea refers to. Rust's compiler and our application doesn't understand the idea. We know it because it's in our mind, but we need to share it with the application. Writing a program is a lot like explaining something to a person who has no prior knowedge or context to understand what you're talking about. We need to define what we're talking about and what we mean.</p>
<blockquote>
<p><strong>Aside:</strong> We use shared context a lot in our lives without even knowing it. We have our own languageâ€”even slag/colloquialismsâ€”that we use without even thinking about it. We may say, &quot;Hey, can you put this bag in the bin?&quot; Someone might think, &quot;bin in my mind is defined as the garbage and they want this to be thrown out,&quot; and another might think, &quot;by bin they mean that basket over there and they want me to put this in storage.&quot; These are vastly different outcomes! Programming is tricky because we need to be aware of how others (in this case, the computer) will interpret the meaining of the language we use. You'll also find that being aware of the importance of context and how it impacts the decoding and interpreting of meaning will make you a better communicator and will help you understan others by thinking about the context they're assuming you have when interpreting their messages.</p>
</blockquote>
<p>To solve this missing and undefined context we'll write a statement that explicitly states what we mean by <code>the_lucky_number</code>.</p>
<p>Rust's syntax is very intuitive for this.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let the_lucky_number = 42;
<span class="boring">}</span></code></pre></pre>
<p>Now rust knows exactly what we mean when we say <code>the_lucky_number</code>. In this line we're telling the compiler, &quot;Hey rust, let <code>the_lucky_number</code>(the idea of a thing we're referring to as the_lucky_number) be assigned to the value 42&quot;. We can actually add even more specificity to this to tell the compiler what type of number it is.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let the_lucky_number: i32 = 42;
<span class="boring">}</span></code></pre></pre>
<p>In the above we've added a type to the noun. The pattern is as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let the_name_of_the_thing : the_type = the_value ;
<span class="boring">}</span></code></pre></pre>
<p>We've said, &quot;let the_lucky_number be an integer that is 32 bits in size (<code>i32</code>) with a value of 42&quot;. The Rust compiler will do its best to infer (figure out) the type if you don't explicitly state it. Rust will also tell you there's a problem if you've tried to assign a value that isn't a valid 32 bit integer.</p>
<p>The compiler will infer that when youi say <code>42</code> you don't mean a text string with the characters <code>42</code>, or that you don't mean 42.0 (a floating point number).</p>
<p>Our updated function isn't fully there yet, but we are able to place a number, known to Rust as an integer, into the `view! template.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope) -&gt; Element {  
	let the_lucky_number:i32 = 42;
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<h2 id="rusts-type-system"><a class="header" href="#rusts-type-system">Rust's Type System</a></h2>
<h3 id="a-mental-model-for-understanding-types"><a class="header" href="#a-mental-model-for-understanding-types">A mental model for understanding types</a></h3>
<p>Specifying the type of something is the same as specifying the range (a group) of possible values. If we specify <code>bool</code> (a boolean value) as a type, the possible values are <code>0</code> and <code>1</code>.  This is a <code>1 bit</code>.</p>
<p>When we state <code>i32</code> as a type for <code>the_lucky_number</code>, we're telling the Rust compiler, numbers in this range must be between -2,147,483,648 and 2,147,483,647. These are the largest and smallest numbers that you can create with a sequence of 32 zeros and ones <code>bits</code> in boolean, interpreted as a single number.</p>
<h3 id="the-importance-of-a-values-size"><a class="header" href="#the-importance-of-a-values-size">The importance of a value's size</a></h3>
<p>The really neat thing about computers and programs is that at the end of the day, everything is a sequence of zeros and ones. All of the things we're writing eventually get turned into bits laid out in memory.</p>
<blockquote>
<p>The really brain breaking thing hereâ€”don't dwell on it too muchâ€”is that functions are also all turned into zeros and ones!</p>
</blockquote>
<p>When we say that an <code>i32</code> is a sequence of bits, iterpreted as a single number, we mean just that. The application, under the hood, knows that 32 bits should be grabbed from memory and interpreted as a binary number. Imagine if in that same sequence of zeros and ones you had two 16 bit <code>i16</code> numbers. They would take up the same amount of space in memory (16 x 2 = 32) but they are not a 32bit number!</p>
<p>Our application needs to know how many bits to pick-up and read sequentially to interpret as a value. It also needs to know how much space (how many bits) are available to store data for that type.</p>
<p>This is one of the main features/benefits of the Rust programming language and how it lets us write safe programs. Knowledge of the size of a type allows us to safely read and write to memory.</p>
<p>Rust will always make sure that we can't have a situation where two 16 bit numbers get written in a block of 32 bits, and vise versa.</p>
<p>I realize this is complicated. Rust takes care of all of this for us. But it's important to know why we need to specify the type of a value throughout Rust, where as other languages often don't care.</p>
<h3 id="types-are-value-constraints"><a class="header" href="#types-are-value-constraints">Types are value constraints</a></h3>
<p>Rust's type system adds constraint based on size, but it also adds it based on capability/use. We'll learn more about that later but it's important that the idea be introduced.</p>
<p>At the end of the day, an easy mental model to keep is that types are constraints. An untyped value could be literally any size, supporting any functionality.</p>
<p>It's a kin to if someone said, &quot;I have a thing.&quot; You don't know if that thing is a sandwich that can be eated, if that thing is a feeling, or if that thing is a surprise that you'll be thrown a party on your birthday.&quot; As you can imagine, writing a progam where any idea could be any type can be tricky. We'd need to keep those types in our mind so that we don't inadvetantly try to do something with &quot;things&quot; that can be done to or with them.</p>
<p>When I think about types, I think about them as a list of possible values.</p>
<p>If the type is a <code>bool</code> it's possible values are 0 and 1. I can deal with that! If the type is  <code>i8</code>, then I know that the value will be a number between -128 and 127.</p>
<p>And that really is the important thing about types as constraints for Rust. Rust wants all types to be known (or to be inferable/figure-out-able) so that there <em>no surprises</em>. Rust's compiler will actually highlight spots where it sees that you've accounted or some of the possible values, but not all of them. It doesn't want you to be surprised. The Rust compiler is so nice. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leptos-component-properties"><a class="header" href="#leptos-component-properties">Leptos Component Properties</a></h1>
<h1 id="what-we-know-4"><a class="header" href="#what-we-know-4">What we know</a></h1>
<ul>
<li>Components are created with specific function definitions and a [#component] function anotation.</li>
<li>Variables can be injected into <code>view!</code> macro templates</li>
</ul>
<h1 id="what-well-learn-4"><a class="header" href="#what-well-learn-4">What we'll learn</a></h1>
<ul>
<li>How to pass values to components</li>
</ul>
<h1 id="the-lesson-2"><a class="header" href="#the-lesson-2">The Lesson</a></h1>
<p>In the previous lesson we created a component with a number, but that number is hard coded. It is static and can not change.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope) -&gt; Element {  
	let the_lucky_number:i32 = 42;
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>If we've played around with HTML or recall from earlier lessons, we might remember that HTML elements have properties, or key-value pairs of data. For example, in  <code>&lt;h1 class=&quot;fancy&quot;&gt;Lah dee dah&lt;/h1&gt;</code> we have a heading 1 element which has a class with the string value &quot;fancy&quot;. Input elements provide a more data driven example in that <code>&lt;input type=&quot;number&quot; value=&quot;42&quot; /&gt;</code> is an element that as a value property, with a value of 42.</p>
<p>What we're going to focus on is being able to write <code>&lt;LuckyNumber number={42} /&gt;</code>, actually provide it a number! We'll pass the value into the component the same as we would pass the value (argument) to a function as a property.</p>
<h2 id="step-1-updating-the-component-function-to-accept-an-external-value-as-a-property"><a class="header" href="#step-1-updating-the-component-function-to-accept-an-external-value-as-a-property">Step 1: Updating the component function to accept an external value as a property</a></h2>
<p>We need to move our noun <code>the_lucky_number</code> &quot;up and out&quot; of our component function. It needs to be a requirement of the component. We'll need someone else to provide its value for the component to work. To do this, we'll list it as a function parameter and remove the <code>let</code> statement where we define it's value.</p>
<p>The following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope) -&gt; Element {  
	let the_lucky_number : i32 = 42;
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>Turns into this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number : i32) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>Note how we've extrated the middle bits of our <code>let</code> line, moving <code>the_lucky_number : 32</code> into the function's parameter list). The name of the parameter is listed, followed by a colon, and the type of value that it's allowed to be.</p>
<blockquote>
<p>It's worth the reminder that variable names are written in snake_case by convention.</p>
</blockquote>
<h2 id="step-2-update-component-props-to-pass-a-value-to-a-component"><a class="header" href="#step-2-update-component-props-to-pass-a-value-to-a-component">Step 2: Update component props to pass a value to a component</a></h2>
<p>Our main function had a <code>view!</code> macro template with <code>&lt;LuckyNumber /&gt;  </code> in it. We've introduced the idea of a property called <code>the_lucky_number</code> in our component's definition, so we can make use of it here.  We can add the property, with the same name parameter name we used in the component, and assign a value to it.</p>
<p><code>&lt;LuckyNumber the_lucky_number=32/&gt;  </code></p>
<p>The updated main function now looks like this:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;NiceAffirmation /&gt;  
	        &lt;LuckyNumber the_lucky_number=32 /&gt;  
        }  
    })  
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leptos-component-dynamic-content-separation"><a class="header" href="#leptos-component-dynamic-content-separation">Leptos component dynamic content separation</a></h1>
<h2 id="what-we-know-5"><a class="header" href="#what-we-know-5">What we know</a></h2>
<ul>
<li>Leptos components can accept properties and use them in their <code>view!</code> templates.</li>
</ul>
<h2 id="what-well-learn-5"><a class="header" href="#what-well-learn-5">What we'll learn</a></h2>
<ul>
<li>How Leptos' components are able to differentiate between dynamic and static content in their templates</li>
</ul>
<h2 id="the-lesson-3"><a class="header" href="#the-lesson-3">The Lesson</a></h2>
<p>In the previous lesson we were able to pass a value as an argument to a Leptos component's property. The Leptos component's signature specifies this property as a function argument. When the application starts, Leptos expands these <code>view!</code> macros and creates templates. This happens once on startup. Leptos then updates the web page's document object model (DOM) through the <code>mount_to_body</code> function call.</p>
<p>The properties passed to the Leptos component have the ability to impact how the component is rendered. In the following example, the variability is visible as text inside the Leptos component's template paragraph tags.</p>
<p>This is all well and good by you might notice something interesting when we look at the HTML.</p>
<p>Observe the following Rust code, creating and using our Leptos component.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
	        &lt;LuckyNumber the_lucky_number=12 /&gt;  
        }  
    })  
}  
  
#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number: i32) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
    }  
}</code></pre></pre>
<p>If we run <code>trunk serve</code> from our Rust project's directory, we'll get some prompts about our web server running. Opening the page up reveals the following HTML.</p>
<pre><code class="language-html">&lt;p&gt;Today's lucky number is &lt;!----&gt;12&lt;/p&gt;
</code></pre>
<p>Surprisingly, the <code>&lt;LuckyNumber the_lucky_number=12 / &gt;</code> has compeltely dissolved away. This might seem shocking, given that our main function says we're mounting the <code>LuckyNumber</code> Leptos component to the body with a call to the <code>mount_to_body</code> function. The reason for that is, a <code>view!</code> template <em>is not</em> HTML. </p>
<p>There are a few things we'll need to go over to give you a really solid explanation of how this works and how Leptos handles dynamic content.</p>
<h3 id="leptos-components-and-templates"><a class="header" href="#leptos-components-and-templates">Leptos components and templates</a></h3>
<p>Leptos components are really interesting. Their <code>view!</code> templates all distill down to HTML. We previously talked about HTML elements which come to life as an HTML tag, and when parsed in the document object model (DOM), become a DOM node. This is a fancy way of saying, when we write HTML, the browser reads it, tries to make sense of it, and creates a nested tree like structure that has hierarchy of the components.</p>
<p>Text, even though it's not an HTML element, but also be interpreted and added to the DOM. To do this, a browser creates a text node.</p>
<p>Leptos adds HTML comments to force the web browser to break what seems like contiguous text, into multipe text nodes. This is done by adding HTML comments which are encapsulated by  <code>&lt;!--</code> and <code>--&gt;</code>. </p>
<p>With this in mind, the HTML output that we saw before:</p>
<pre><code class="language-html">&lt;p&gt;Today's lucky number is &lt;!----&gt;12&lt;/p&gt;
</code></pre>
<p>Creates the following paragraph node with two child text nodes.</p>
<pre><code class="language-html">	&lt;p&gt;
		Today's lucky number is &lt;-- this is a text node
		12                      &lt;-- this is a text node
	&lt;/p&gt;
</code></pre>
<p>And we can see how it directly matches up with the <code>view!</code> template if we think about the static text string as being one text node, and the dyamic text which will come from <code>the_lucky_number</code>'s value, as another.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	&lt;p&gt;
		&quot;Today's lucky number is &quot; 
		{the_lucky_number}
	&lt;/p&gt; 
<span class="boring">}</span></code></pre></pre>
<p>Leptos' ability to retain congruency of structure between the <code>view!</code> template and the HTML it yields allows Leptos it to know exactly which text nodes or areas in the page will be dynamic, or are subject to change.</p>
<h3 id="aside-how-leptos-components-deviate-from-expected-web-behaviour-and-custom-elements"><a class="header" href="#aside-how-leptos-components-deviate-from-expected-web-behaviour-and-custom-elements">Aside: How Leptos components deviate from expected web behaviour and custom elements</a></h3>
<blockquote>
<p>Section pending ^.^</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leptos-components-and-logging-events"><a class="header" href="#leptos-components-and-logging-events">Leptos components and logging events</a></h1>
<h2 id="what-we-know-6"><a class="header" href="#what-we-know-6">What we know</a></h2>
<ul>
<li>Leptos makes distinctions between which things are static (will not change) and which are dynamic (can change)</li>
</ul>
<h2 id="what-well-learn-6"><a class="header" href="#what-well-learn-6">What we'll learn</a></h2>
<ul>
<li>How we can make our application dynamic through client side events</li>
</ul>
<h2 id="the-lesson-4"><a class="header" href="#the-lesson-4">The Lesson</a></h2>
<p>We've worked with static templates so far but it would be great if we can start to interact with our application. It would be wonderful if we could do something and see that change happen before our very eyes. </p>
<p>The secret to achieving this is in the &quot;if we could do something,&quot; part of what I just wrote.</p>
<p>When something happens in the browserâ€”a key is pressed, a button is clicked, the mouse is movedâ€”an event is fired. A piece of functionality gets called as part of the browser's JavaScript runtime declaring what happened along with some information about that event. </p>
<p>If we were writing these applications in JavaScript, the native language of the web's interactive runtime, we could declare a function as a callback (will be called when) an event happens, reacting to the interaction. Unfortunately, we can't directly do that because we're writing Rust which becomes WASM. But never fear, we have some pretty great tools to help us around this shortcoming.</p>
<p>Leptos comes bundled with a crate called <code>wasm-bindgen</code>. WASM bindgen which acts as an interface, allowing Rust to call JavaScript features and vise-versa. There are some crates that add extra helper fuctionality on top of that like <code>web_sys</code> which provides types and wrappers to interact with web and browser APIs.</p>
<p>Let's refresh our memory and look at our lucky number Leptos component:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number: i32) -&gt; Element {  
    view!{  
        cx,  
        &lt;div&gt;  
            &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
        &lt;/div&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>Let's add a button to this which will eventually print a message in the client's web browser console (abbreviated for clarity).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	&lt;div&gt;  
		&lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
		&lt;button&gt;&quot;Your Secret Lucky Number&quot;&lt;/button&gt;  
	&lt;/div&gt;  
<span class="boring">}</span></code></pre></pre>
<p>Leptos makes it really easy to add event handlersâ€”functionality triggered by events. We simply write 'on:' followed by the name of the event, and the name of the handler. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;button&gt;&quot;Your Secret Lucky Number&quot;&lt;/button&gt;  
<span class="boring">}</span></code></pre></pre>
<p>... is made interactive as follows...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;button on:click=whisper_in_the_console &gt;&quot;Your Secret Lucky Number&quot;&lt;/button&gt;  
<span class="boring">}</span></code></pre></pre>
<p>But this is incomplete. We've written the name of a handler that we made up, which we're calling <code>whisper_in_the_console</code> but we haven't declared it anywhere. Rust doesn't know what this means. To fix this we'll declare this variable and assign a value to it which is a closure, a function which can run, but which is stored in a variable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number: i32) -&gt; Element {
	let whisper_in_the_console = |_|{  
	    web_sys::console::log_1(&amp;42.into());
	};  
	view!{  
	    cx,  
	    &lt;div&gt;  
	        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
	        &lt;button on:click=whisper_in_the_console &gt;
		        &quot;Your Secret Lucky Number&quot;
			&lt;/button&gt;  
	    &lt;/div&gt;  
	}
}
<span class="boring">}</span></code></pre></pre>
<p>Let's break down what this assignment means. We'll be less verbose in later chapters, but it's important to start thinking in terms of what we're communicating to the compiler. This will help you become a native speaker of the Rust language. :)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let whisper_in_the_console = |_|{  
    web_sys::console::log_1(&amp;42.into());
};  
<span class="boring">}</span></code></pre></pre>
<p>And like that, now when we click on the button we get the number 42 printed out in the console!</p>
<blockquote>
<p>SUPER IMPORTANT: You do not need to understand the body of this closure to continue. There will be numerous examples of event handlers in future chapters. I am specifically using this example so that you can log something to the browser's console. Further reading will expose you to some advanced concepts about the rust programming language.</p>
</blockquote>
<h4 id="event-handler-closure-signature"><a class="header" href="#event-handler-closure-signature">Event handler closure signature</a></h4>
<p>First let's look at how we even declared the closure and assigned it as a value to a variable. In case you're curious, this is what it means when functions are first class citizens. You might hear programmers mention this idea. It just means that a function can be assigned as a value and passed around.</p>
<p>Here's what the first line says:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	let whisper_in_the_console = |_|{ 
		// this is a comment, letting you know that we removed the
		// event handler's body which we'll step through soon
	};
<span class="boring">}</span></code></pre></pre>
<p><code>let</code> (let it be/declare) that <code>whisper_in_the_console</code> is equal to (there for, it is) a closure which accepts an argument which is never used (marked by the <code>_</code> /underscore character ).</p>
<p>Event handlers must be a function with a single parameter for the event that triggered the handler (the respondant). In our case we're not using that argument, so it's convention to write an underscore in its place instead of giving it a name.</p>
<h4 id="event-handler-body"><a class="header" href="#event-handler-body">Event handler body</a></h4>
<p>There is a lot to unpack in this single line of code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>web_sys::console::log_1(&amp;42.into());
<span class="boring">}</span></code></pre></pre>
<p>The first bit is the crate's, <code>web_sys</code>. Crates are what Rust nomenclature uses when refering to packages or libraries. <code>web_sys</code> can be used in this scope because it was made public and brought into the leptos crate's scope. By writing <code>use leptos::*;</code> at the top of our main.rs file we're bringing in everything that is public in Leptos'.</p>
<blockquote>
<p>You may ask &quot;How did you know to use web_sys?&quot; To be honest, it's a matter of asking around, seeing other examples and discovering useful crates. Some are very popular like web sys and you will use them because they're used in the libraries or frameworks that you're consuming. Developers don't magically know about all of these tools. It takes a lot of exposure to the community to develop this awareness and understanding. Stay cool about it. The knowledge will come with time. For now, trust the process.</p>
</blockquote>
<p>When we write <code>web_sys::console::log_1</code> we're saying, &quot;Use the log_1&quot; function in the console module, from the web_sys crate. </p>
<p>This is the <code>web_sys</code> crate's equivalent of calling console.log in the JavaScript console. In JavaScript you can include as many arguments as you want when calling the log function. This is what programmers call a &quot;variadic&quot; function. Rust does not allow this. To accommodate multiple arguments, console has functions for log, log_1, log_2, log_3 and so on. We have to specify the number of arguments in rust, which is sort of awkwardly, but clearly, done with the suffixed number.</p>
<p>The log function in Rust accept a reference to JsValue data type. Recall that we talked about how types are constraints for possible values. JsValue exists because JavaScript doesn't have any type system what so ever. Rust developers needed to make a type that could interoperate safely with JavaScripts untyped world. </p>
<p>To convert our number (an i32 litera) to a JsValue type we call the <code>into()</code> method on it, which will convert it ot the required type of the log_1 signature which happens to be a JsValue. The log method also requires that we do not pass the actual owned value. It is expecting a reference to data. We can add an ampersand to specify that this is a reference.
And like that we get...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>web_sys::console::log_1(&amp;42.into());
<span class="boring">}</span></code></pre></pre>
<p>Call web_sys's console module's log 1 function which we'll pass a single argument to using the number 42 which we'll convert to the accepted/required type and pass it as a reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leptos-components-updating-from-events"><a class="header" href="#leptos-components-updating-from-events">Leptos components updating from events</a></h1>
<h2 id="what-we-know-7"><a class="header" href="#what-we-know-7">What we know</a></h2>
<ul>
<li>Leptos components are templates that can be added to a web page's document object model DOM as nodes, with separate text nodes for dynamic data used in text strings.</li>
<li>Leptos components can have fuctions run in response to events on a given component.</li>
<li><code>wasm-bindgen</code> and other supporting crates work as bridges between our Rust code and the browser's JavaScript runtime.</li>
</ul>
<h2 id="what-well-learn-7"><a class="header" href="#what-well-learn-7">What we'll learn</a></h2>
<ul>
<li>Updating the DOM in response to events.</li>
</ul>
<h2 id="the-lesson-5"><a class="header" href="#the-lesson-5">The Lesson</a></h2>
<p>In our previous example we created a silly Leptos component that displays some text and has a button that, when clicked, echoes a number to the console.</p>
<p>We'll take this example and and instead of echoing 42 the console, we'll replace the lucky number with it.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;LuckyNumberCounter the_lucky_number=12 /&gt;  
        }  
    })  
}

#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number: i32) -&gt; Element {
	let whisper_in_the_console = |_|{  
	    web_sys::console::log_1(&amp;42.into());
	};  
	view!{  
	    cx,  
	    &lt;div&gt;  
	        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
	        &lt;button on:click=whisper_in_the_console &gt;
		        &quot;Your Secret Lucky Number&quot;
			&lt;/button&gt;  
	    &lt;/div&gt;  
	}
}</code></pre></pre>
<p>First, let's adjust the names of some of the event callback and put a placeholder into the event handler (or callback) body.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number: i32) -&gt; Element {
	let update_the_number = |_|{  
	    // This functionality is unknown.
	};  
	view!{  
	    cx,  
	    &lt;div&gt;  
	        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
	        &lt;button on:click=update_the_number &gt;
		        &quot;I need a more lucky number&quot;
			&lt;/button&gt;  
	    &lt;/div&gt;  
	}
}
<span class="boring">}</span></code></pre></pre>
<p>We know from previous lessons that Leptos component templates are setup statically when Leptos starts up. Given that this is the case we may ask ourselves, how can we have dynamic content if the template is static? </p>
<p>The secret to solving this problem involves combining two features of Leptos, one which we've seen before and one which is new.</p>
<ol>
<li>How Leptos separates static and dynamic content</li>
<li>Signals which can be converted into data</li>
</ol>
<h3 id="1-separation-of-static-and-dynamic-template-components"><a class="header" href="#1-separation-of-static-and-dynamic-template-components">1) Separation of static and dynamic template components</a></h3>
<p>We saw from the previous example that Leptos differentiates parts of our template from components that are variable. By doing this, it can zip together data that changes with the static template that does not change.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;p&gt;
	&quot;Today's lucky number is &quot; {the_lucky_number}
&lt;/p&gt;  
<span class="boring">}</span></code></pre></pre>
<p>The above could be interpreted as follows:</p>
<pre><code>[STATIC DATA] {DYNAMIC DATA} [STATC DATA]
</code></pre>
<pre><code>[&lt;p&gt;&quot;Today's lucky number is &quot;]  {the_lucky_number} [&lt;/p&gt;]
</code></pre>
<p>By doing this Leptos can reuse the template while leaving a holes, like fields in a form, for variable data.</p>
<h3 id="2-signals"><a class="header" href="#2-signals">2) Signals</a></h3>
<p>The problem with our Leptos component is that <code>the_lucky_number</code> is a variable who's value is defined outside of its component template. It's value is provided when the whole system starts up and the component is mounted to the body as shown in the &quot;<code>fn main()</code>&quot; main function.</p>
<p>Unfortunately our variable <code>the_lucky_number</code> doesn't have an opportunity to be updated or changed. It's been used in our template and it has been consumed. Rust has some very intereting rules about data. </p>
<h4 id="the-idea-of-movement-and-scope"><a class="header" href="#the-idea-of-movement-and-scope">The idea of movement and scope</a></h4>
<p>In a lot of programming languages, you can pass data into a function and then also use it elsewhere. In Rust if you pass data into a function it's considered to have been moved into the function. It has left the scope, or the space, which you were operating.</p>
<p>For example, consider a time where I gave my friend a sandwich and asked them to paint a picture of it for meâ€”it was a beautiful sandwich. If I gave the sandwich to my friend, I no longer have it. It's been <em>moved</em> into their hands. They may give it back to me, but until then, I won't have it. If you're working in Rust and see statements like, &quot;such and such has moved,&quot; this is what that means.</p>
<p>If Rust can make a copy of the data, it'll do so to get around the issue of moved values, but that only happens with simple data types like numbers. There are exceptions and a lot to explain with what is called the copy trait, but we won't get into that here. The idea of 'copy' is important to how Leptos allows dynamic content though.</p>
<h3 id="knowing-what-we-are-actually-moving"><a class="header" href="#knowing-what-we-are-actually-moving">Knowing what we are actually moving</a></h3>
<p>Let's go back to this sandwich example. Perhaps I don't want to relinquish my sandwich. I could provide a reference to it and my friend could look at it to make the painting. Though, they wouldn't be allowed to touch it. They are only allowed to look at it. In this case, I'm not losing my sandwich, but Rust will prevent me from changing it while someone is referencing it. Rust won't allow me to take a bit of my sandwich while I told my friend they could look at it to make the painting. Independent of how hungry I am. I could actually set up a plinth, place my sandwich on top, and allow a whole class of artisans to paint my sandwich. </p>
<p>Rust also allows me to loan out my sandwich by providing a mutable reference, but if I do that, I can't touch it, and no one else is allowed to reference it. It would be as if I told my friend, &quot;You can paint my sandwich and organize the lettuice and tomato so that it makes a nice composition.&quot; No one could safely paint that sandwich because my friend might still be moving parts of it around.</p>
<p>References in rust are achieved by adding an ampersand before a value. <code>42</code> is a number. <code>&amp;42</code> is a reference to that number. We can dereference or follow the reference to the original by placing an asterisk before a variable containing a reference. We'll expand on this later and explain how you references, and when to use them.</p>
<p>To summarize, the rules are:</p>
<ul>
<li>We can move an owned value (the sandwich)</li>
<li>We can create and move one or more references to the sandwich</li>
<li>We can create one single mutable reference, but we can not also have regular references if we do</li>
</ul>
<h3 id="the-borrow-checker"><a class="header" href="#the-borrow-checker">The borrow checker</a></h3>
<p>The above two concepts are key parts of what we call the Rust borrow checker. The purpose of the borrow checker is to make sure that our system (application) has predictable access to data. To do this, it tracks where we move things and how we reference them, to guarantee that we haven't inadvertantly written something stupid that will break our program or create secrity vulnerabilities. And trust me, we will write things like that. The borrow checker is your friend and asks you to do your best work. You will learn to appreciate how amazing it is in time.</p>
<p>Now that we know this, we can see how what felt like a simple problem to solve is actually pretty complicated. If we move a value into a component, it's gone. We can't update a value that doesn't exist as a result of some event. It might take some time to wrap your mind around this idea. It'll feel uncomfortable at first.</p>
<h3 id="leptos-solution"><a class="header" href="#leptos-solution">Leptos' solution</a></h3>
<p>What we really need is some sort of special variable. We need something that we can put in the template which can be notified when its value changes, and something that can transparently act as its value. </p>
<p>Imagine if we had a wearhouse of data who we could call and ask for data. &quot;Hey, I need the value of Aisle 2 bin 4.&quot; If we had the location of the data, we could always ask the wearhouse for whatever is stored there.</p>
<p>Or what if we could ask them to store something and they'd do so, responding with its location in the wearhouse. &quot;Can you store this gigantic novelty taco beanbag chair for me?&quot; we'd ask. &quot;Sure, and it's in aisle 2 bin 5,&quot; they'd respond. </p>
<p>This is what signals do. Signals are a formalized way of being able to communicate with the wearhouse (which in the context/scope in Leptos) to store data and retrieve data. When data changes, leptos can follow where it is being used, and update those usages accordingly. </p>
<p>I introduced the idea of copy earlier because the signals are actually indexes, storage positions in the context, which will be duplicated as you use them. This allows you to move a signal into a closure which will be handling an event while still using it in the view template. </p>
<h3 id="reactivity-in-action"><a class="header" href="#reactivity-in-action">Reactivity in action</a></h3>
<p>To create a signal, we need to call the function <code>create_signal()</code> and provide a scope (or context) as the first argument, and the default value as the second. It returns a tuple, a set of two values, which we can immediately give names to so that we can use them in the scope of our function.
The first part of the signal allows us to retrieve a copy of the value from the wearhouse. The second part of the signal allows us to set the value at the signal's location.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (value, set_value) = create_signal(cx, the_lucky_number);  
<span class="boring">}</span></code></pre></pre>
<p>The above is called destructuring. We could also have written in the long form way but it is actually harder to read and requires additional temporary assignments like <code>lucky_number_signal</code>. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let lucky_number_signal = create_signal(cx, the_lucky_number);  
let value = lucky_number_signal.0;
let set_value = lucky_number_signal.1;
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Note that <code>.0</code> and <code>.1</code> are properties on the <code>lucky_number_signal</code>. They're indexes for the first and second component in the tuple.</p>
</blockquote>
<p>Now that we have a signal we can update our callback and move the set_value signal into it. Not the addition of the move keyword before the closure's pipes which encapsulate it's properties, and the underscore which denotes that it will be provided a property when called, but we won't be using it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let update_the_lucky_number = move|_|{  
        set_value(42);  
    };  
<span class="boring">}</span></code></pre></pre>
<p>And in the view template we can update our previous value with our signal which can be used to derive the value.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;LuckyNumber the_lucky_number=12 /&gt;  
        }  
    })  
}  
  
#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number: i32) -&gt; Element {  
    let (value, set_value) = create_signal(cx, the_lucky_number);  
  
    let update_the_lucky_number = move|_|{  
        set_value(42);  
    };  
    view!{  
        cx,  
        &lt;div&gt;  
            &lt;p&gt;&quot;Today's lucky number is &quot; {value}&lt;/p&gt;  
            &lt;button on:click=update_the_lucky_number &gt;&quot;Pick a better number&quot;&lt;/button&gt;  
        &lt;/div&gt;  
    }  
}</code></pre></pre>
<p>The coolest part about this is that the signal is responsible for updating itself on the web page if it's value changes. LuckyNumber doesn't run again to create a new template. Leptos updates that special little text node, where <code>{value}</code> is used.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
