<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Building Apps with Rust</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Preface</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Acknowledgements</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> About this Book</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> About the Author</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> If you get stuck or lose steam</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Introductions</li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Programming</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> What it is</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Why it's worth it</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Why it's hard</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> Programmer Thinking</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Languages</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> Meaning and Interpretation</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Architectures</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> How your computer works</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> How the web works</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.3.</strong> The frontend-backend divide</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Tools and Languages</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">9.1.</strong> Bash and the terminal</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.2.</strong> Rust</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.3.</strong> Trunk</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.4.</strong> Web browsers</div></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Hello World</li><li class="chapter-item expanded "><a href="setup_intro.html"><strong aria-hidden="true">10.</strong> Setup</a></li><li class="chapter-item expanded "><a href="html_intro.html"><strong aria-hidden="true">11.</strong> Intro to HTML</a></li><li class="chapter-item expanded "><a href="view_macro_html.html"><strong aria-hidden="true">12.</strong> HTML and the view! macro</a></li><li class="chapter-item expanded affix "><li class="part-title">Leptos Components</li><li class="chapter-item expanded "><a href="leptos_component_intro.html"><strong aria-hidden="true">13.</strong> Intro to Leptos Components</a></li><li class="chapter-item expanded "><a href="view_macro_variables.html"><strong aria-hidden="true">14.</strong> Variables and the view! macro</a></li><li class="chapter-item expanded "><a href="leptos_component_properties.html"><strong aria-hidden="true">15.</strong> Leptos Component properties</a></li><li class="chapter-item expanded "><a href="leptos_component_dynamic_content_separation.html"><strong aria-hidden="true">16.</strong> Leptos Component dynamic content separation</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.</strong> Client Side</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">17.1.</strong> Events</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="leptos_component_logging_events.html"><strong aria-hidden="true">17.1.1.</strong> Leptos Components witnessing events</a></li><li class="chapter-item expanded "><a href="leptos_component_update_from_event.html"><strong aria-hidden="true">17.1.2.</strong> Leptos Components reacting to events</a></li><li class="chapter-item expanded "><a href="event_bubbling_and_signal_generics.html"><strong aria-hidden="true">17.1.3.</strong> Event Bubbling and Signal Generics</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.1.4.</strong> Preventing bubbling and default event behaviours </div></li><li class="chapter-item expanded "><a href="custom_events.html"><strong aria-hidden="true">17.1.5.</strong> Custom Events</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.1.6.</strong> Custom Event Data</div></li></ol></li><li class="chapter-item expanded "><a href="forms.html"><strong aria-hidden="true">17.2.</strong> Forms</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Building an Application</li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Design Patterns and Application Structure</li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Common Problems</li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Building Apps with Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <ol>
<li>Install Rust</li>
<li>Using up-to-date versions of rustc with <code>Nightly</code></li>
<li>Using up-to-date versions of Leptos from git</li>
</ol>
<hr />
<h3 id="1-install-rust"><a class="header" href="#1-install-rust">1. Install Rust</a></h3>
<p>Detail instructions on how to install Rust for your computer can be found here: https://www.rust-lang.org/tools/install</p>
<p>Installing rust will add a few things to your system.</p>
<ol>
<li>rustc - the rust compiler</li>
<li>rustup - a tool for managing rustc and the rust toolchain (https://rustup.rs)</li>
<li>cargo - the package manager and helper tool for rust (https://doc.rust-lang.org/stable/cargo/)</li>
</ol>
<h3 id="2-using-up-to-date-versions-of-rustc-with-nightly"><a class="header" href="#2-using-up-to-date-versions-of-rustc-with-nightly">2. Using up-to-date versions of rustc with <code>Nightly</code></a></h3>
<p>rustc is the rust compiler. It's possible to run different versions of the compiler. The Rust<br />
community is always working away adding new features. These new features are available<br />
immediately through nightly builds. Leptos, being brand new, makes use of some of these new<br />
features and currently requires <code>nightly</code> to run.</p>
<p>To confirm that you're using the <code>nightly</code> build of rustc (the rust compiler), open your<br />
shell/terminal and run the following command:</p>
<pre><code class="language-bash">rustc -V  
</code></pre>
<p>It should output something like this with 'nightly' in it:</p>
<pre><code class="language-bash">rustc 1.67.0-nightly (e631891f7 2022-11-13)  
</code></pre>
<p>If your version isn't the nightly build, run the following shell/terminal command:</p>
<pre><code class="language-bash">rustup default nightly  
</code></pre>
<p>Rustup is used to manage rustc. By calling the above, rustc is updated to us the nightly build<br />
as its default. You can change this to stable by using the following shell/terminal command:</p>
<pre><code class="language-bash">rustup default stable  
</code></pre>
<h3 id="3-using-up-to-date-versions-of-leptos-from-git"><a class="header" href="#3-using-up-to-date-versions-of-leptos-from-git">3. Using up-to-date versions of Leptos from git</a></h3>
<p>Leptos is changing all the time as well. It's recommended to grab the latest version directly<br />
from their git repository instead of from crates.io (https://crates.io/crates/leptos).</p>
<p>I'll go into detail on exactly how to do this when we start building our app. Don't stress if<br />
the following looks unfamiliar.</p>
<pre><code class="language-toml">[dependencies]  
leptos = { git = &quot;https://github.com/gbj/leptos&quot; }  
</code></pre>
<hr />
<h2 id="creating-your-first-app"><a class="header" href="#creating-your-first-app">Creating your first app</a></h2>
<ol>
<li>Using cargo to create a new rust app</li>
<li>Running your first rust app</li>
<li>Adding Leptos to your application as a dependency</li>
<li>Adding index.html to your application</li>
<li>Serving your index.html and bundling WASM with trunk</li>
<li>Updating client side HTML using Leptos</li>
</ol>
<hr />
<h3 id="1-using-cargo-to-create-a-new-rust-app-cargo-new"><a class="header" href="#1-using-cargo-to-create-a-new-rust-app-cargo-new">1. Using cargo to create a new rust app (<code>cargo new</code>)</a></h3>
<p>New rust projects are created with the following terminal command:</p>
<p>I'm calling my project <code>tut-leptos-client-side-event</code>, keeping in mind thst we're testing out how to handle a simple client side event.</p>
<pre><code class="language-bash">cargo new tut-leptos-client-side-event  
</code></pre>
<blockquote>
<p><strong>Did you know?</strong><br />
Cargo new will create the new project in your current working directory. You  can add path specifications to the application name to change where it's scafolded to. For example, <code>cargo new ~/dev/my-new-app</code> will create a new rust app in the <code>dev</code> directory inside your <code>~/</code> use home directory. If you see <code>~/</code> know that it's a shorthand for your user<br />
home. On OSX that would be <code>/Users/your-user-name</code>.</p>
</blockquote>
<p>When <code>cargo</code> runs with the <code>new</code> command, it creates the folder <code>tut-leptos-client-side-event</code>.</p>
<p>This folder gets setup with a few important things.</p>
<ol>
<li>A <code>src</code> directory that will contain all of our source code</li>
<li>A <code>src\main.rs</code> file, which contains our main function which is our <code>app</code>. This is called to<br />
tart our application and everything is run by calling code inside of it.</li>
<li>A <code>cargo.toml</code> file which contains meta data about our app, and it's dependences.</li>
<li>A <code>target</code> directory that will contain compiled data of our app. Ignore this folder for now.</li>
</ol>
<h3 id="2-running-your-first-rust-app-cargo-run"><a class="header" href="#2-running-your-first-rust-app-cargo-run">2. Running your first rust app (<code>cargo run</code>)</a></h3>
<p>Recall that we just made a new app with <code>cargo new tut-leptos-client-side-event</code>. Now we want to run it! Using the termninal/shell command <code>cargo run</code> will compile and run our app. Entering this terminal/shell command will not work right away. You'll get an error message:</p>
<blockquote>
<p>error: could not find <code>Cargo.toml</code> in ` ....... or any parent directory</p>
</blockquote>
<p>Cargo needs that cargo.toml file for context. It has information about which version of rust to compile for, which external bits of code (dependencies) need to be gathered to do the  compilation, and so forth.</p>
<p><code>C</code>hanging the <code>d</code>irectory of your <code>p</code>resent <code>w</code>orking <code>d</code>irectory to the directory created by <code>cargo new</code> will allow us to use the cargo.toml file for context, letting us compile the app.</p>
<blockquote>
<p><code>cd</code> – is the terminal/shell command for changing directory</p>
</blockquote>
<blockquote>
<p><code>pwd</code> – is the terminal/shell command for printing the present working directory</p>
</blockquote>
<p>The following list of commands need to be input individual, one line at a time. The first command changes the present working directory to our user home directory:</p>
<pre><code class="language-bash">cd ~/  
cargo new tut-leptos-client-side-event  
cd tut-leptos-client-side-event  
cargo run  
</code></pre>
<p>The application will take a brief period to compile and it'll print <code>Hello, world!</code> to your terminal/shell.</p>
<h3 id="3-adding-leptos-to-your-application-as-a-dependency"><a class="header" href="#3-adding-leptos-to-your-application-as-a-dependency">3. Adding Leptos to your application as a dependency</a></h3>
<p>We're going to add leptos to the mix as a dependency for our rust application.</p>
<p>First let's take a look at our stock <code>cargo.toml</code></p>
<pre><code class="language-toml">[package]  
name = &quot;tut-leptos-client-side-event&quot;  
version = &quot;0.1.0&quot;  
edition = &quot;2021&quot;  
  
# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html  
  
[dependencies]  
</code></pre>
<p>Note that we have no dependencies listed. All that exists is the heading <code>[dependencies]</code>.</p>
<p>Normally we'd use <code>cargo</code> to help us add dependencies. We'd need to call <code>cargo</code> in the<br />
context of our rust application's <code>cargo.toml</code> like we did with <code>cargo run</code>.</p>
<p>From within the <code>tut-leptos-client-side-event</code> folder we can call the following terminal/shell<br />
command:</p>
<pre><code class="language-bash">cargo add leptos  
</code></pre>
<p>Our <code>Cargo.toml</code> now includes the following:</p>
<pre><code class="language-cargo.toml">[dependencies]  
leptos = &quot;0.0.18&quot;  
</code></pre>
<p>In getting started we talked about using the git repository to grab the most up to date version of the dependency instead of the version published on crates.io (the rust package repository).</p>
<p>To do this we'll actually change the leptos entry to:</p>
<pre><code class="language-cargo.toml">leptos = { git = &quot;https://github.com/gbj/leptos&quot; }  
</code></pre>
<h3 id="4-adding-indexhtml"><a class="header" href="#4-adding-indexhtml">4. Adding index.html</a></h3>
<p>Our rust application will compile to wasm. That wasm will interact with a web page to create our client side experience. For this to work, we'll need to create an index.html.</p>
<p>Create this file in the root of your app, alongside cargo.toml. Your app directory should look like this:</p>
<pre><code>/tut-leptos-client-side-event  
	/src
		main.rs
	cargo.toml
	index.html
</code></pre>
<p>Inside the index.html should contain the following:</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;  
&lt;html&gt;  
&lt;head&gt;  
    &lt;title&gt;Leptos App&lt;/title&gt;
	&lt;link data-trunk rel=&quot;rust&quot; data-wasm-opt=&quot;z&quot;/&gt;
&lt;/head&gt;  
&lt;body&gt;&lt;/body&gt;  
&lt;/html&gt;    
</code></pre>
<p>The important part of this is the following tag:</p>
<pre><code class="language-html">&lt;link data-trunk rel=&quot;rust&quot; data-wasm-opt=&quot;z&quot;/&gt;
</code></pre>
<p>A tool called <code>trunk</code> is going to eventually put all of these pieces together. The above <code>&lt;link&gt;</code> element will be replaced with rust application, compiled to wasm.</p>
<h3 id="4-serving-your-indexhtml-and-bundling-wasm-with-trunk"><a class="header" href="#4-serving-your-indexhtml-and-bundling-wasm-with-trunk">4. Serving your index.html and bundling WASM with trunk</a></h3>
<p>To use our application on the web, we need to serve it and bundle the WASM with the HTML.</p>
<p>We're going to use a tool called <code>trunk</code> which will do a few things:</p>
<ol>
<li>It'll serve index.html so that we can view it in our browser</li>
<li>It'll use <code>cargo</code> to compile the application to WASM</li>
<li>It'll attach the compiled WASM to our index.html, replacing <code>&lt;link data-trunk rel=&quot;rust&quot; data-wasm-opt=&quot;z&quot;/&gt;</code></li>
</ol>
<p>You will need to install the <code>trunk</code> tool. Instructions can be found here: https://trunkrs.dev/#install</p>
<p>For covenience, this will probably work:</p>
<pre><code class="language-shell">cargo install --locked trunk
</code></pre>
<p>To serve your app, use the following terminal/shell command while your application root is your present working directory:</p>
<pre><code class="language-shell">trunk serve
</code></pre>
<p>You'll see a variety of diagnostic information output to your prompt. The important line is this&quot;</p>
<pre><code class="language-shell">2022-11-26T15:40:19.251657Z  INFO 📡 serving static assets at -&gt; /
2022-11-26T15:40:19.251861Z  INFO 📡 server listening at http://127.0.0.1:8080
</code></pre>
<p>Listening at <code>127.0.0.1:8080</code> means that you can type that into your web browser to send a <strong>request</strong> to the server and it will provide the static files with your WASM bundled in (because it is a static file) back as the <strong>response</strong>.</p>
<p>You now have a web page!</p>
<h3 id="5-updating-client-side-html-using-leptos"><a class="header" href="#5-updating-client-side-html-using-leptos">5. Updating client side HTML using Leptos</a></h3>
<h4 id="51-understanding-mainrs"><a class="header" href="#51-understanding-mainrs">5.1 Understanding main.rs</a></h4>
<p>At this point we have a Rust application which compiles to WASM and we have a server running, listening at <code>127.0.0.1:8080</code> for requests, responding with our index.html and linked assets, most importantly our Rust application in WASM form.</p>
<p>What we don't have here is anything that updates our index.html or any form of interaction between our Rust application (WASM) and the DOM (Document Object Model — a name for the hierarchy of html elements/nodes) in the index.html.</p>
<p>We've addd leptos to our application as a dependency, and now we're going to put it to use.</p>
<p>If we look in our <code>src/main.rs</code> we can see the following:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {  
    println!(&quot;Hello, world!&quot;);  
}</code></pre></pre>
<p>Here we have a function (using the keyword <code>fn</code>) with the name <code>main</code>.  The <code>(</code> and <code>)</code> are like bookends that encapsulate a functions <strong>parameters</strong> (buckets to hold arguments passed to them) and <strong>arguments</strong> (values assigned to the parameters when called) that the function might use to run. In this case, the main function doesn't require anything to run, so it has nothing between its parenthesis after the function name. The following set of curley braces <code>{</code> and <code>}</code> encapsulate the function body here. This is what will be evaluated when the function is run; the work being done. This is the most minimal example of a <strong>function signature</strong>. There are more things that can be added but we'll get into those later.</p>
<p>The body of the function contains a single expression. Expressions need to end with <code>;</code>. You can think of it as a terminator for the end of an instruction or step that you want the application to perform.</p>
<p>Let's look at the content of this line.</p>
<p>We have <code>println!(&quot;Hello, world!&quot;);</code></p>
<p>We can look at this as <code>some-command</code>(<code>some-arguments</code>)<code>end</code></p>
<p>The command is <code>println!</code>, the argument is a sequence of characters wrapped by quotes as a convenient way to tell the compiler that you mean the characters and not other commands or variables, and an end of expression character <code>;</code> semicolon.</p>
<p>The command <code>println!</code> is provided by Rust's standard library for you to use to output text to the terminal. If you run your application you'll see <code>Hello, world!</code>, and this is why.</p>
<blockquote>
<p>Important: We've glossed over how to write your own functions with parameters. We've also skipped over how to write functions that return values. Don't worry, we'll cover that when appropriate.</p>
</blockquote>
<h5 id="macros"><a class="header" href="#macros">Macros</a></h5>
<p>We saw before that the main function is written as <code>fn main(){}</code>. There is no <code>!</code> after <code>main</code>. But there is a <code>!</code> after <code>println!</code>.</p>
<p>The <code>!</code> indicates that command is a macro. Macros are like code snippits or code templates that get expanded by the Rust compiler before it's final compilation.</p>
<p>There are function like macros, which use <code>()</code> to encapsulate their argumens. There are also procedural macros, which use <code>{}</code> to encapsulate a body of code which gets consumed by the macro.</p>
<p>As you can imagine, there is a lot involved in actually printing something to the terminal, but we can ignore the complexity with things like <code>println!</code>.</p>
<p>Macros have parameters which you can pass arguments to, just like functions. Leptos makes extensive use of macros to make our lives easier. They're wonderful!</p>
<blockquote>
<p>Important: Macros have the ability to parse (read through to understand/process) their arguments differently from standard Rust code. Keep in mind that the macro author is usually trying to do things that make life easier for the developer using their macro. Sometimes this includes reduction of noisey syntax that would normally be required, or inferences that can be assumed.</p>
</blockquote>
<h4 id="52-updating-mainrs-to-use-leptos"><a class="header" href="#52-updating-mainrs-to-use-leptos">5.2 Updating main.rs to use Leptos</a></h4>
<p>Now that we understand how Rust functions work we can start to bring Leptos into our main.rs.</p>
<p>We do this by telling the compiler that we want to <code>use</code> leptos.
We've added <code>leptos</code> as a dependency in our cargo.toml, so it now exisgts is our 'application universe' as a thing.</p>
<p>But, it doesn't exist in our <code>main.rs</code> because we haven't brought it into scope yet. Bringing things into scope is like bringing things to a workbench or crafting table to use. You need those things at hand, where you're working, so that when you refer to them the compiler knows what you mean and has the bits of code to actually use.</p>
<p>When we write <code>use leptos::*;</code> at the top of our main.rs file, we're telling Rust, <code>use</code> and think called <code>leptos</code> which you should be aware of because we defined it in our cargo.toml, and bring ALL of it's pieces into scope for us to use. The <code>::</code> is a separator the same a slash is a separator for hierarchy in your computer's file system. The <code>*</code> refers to 'everything'.</p>
<p><code>use leptos::*;</code></p>
<p>reads as</p>
<p>use everything from leptos.</p>
<p>To visualize this, think of it as taking a box of tools called &quot;Leptos&quot; and dumping all of them out onn your work bench. You can now grab any one of them for use.</p>
<h4 id="53-updating-fn-main-to-interact-with-your-html"><a class="header" href="#53-updating-fn-main-to-interact-with-your-html">5.3 Updating fn main() to interact with your html</a></h4>
<p>In our main.rs we have a <code>fn main(){}</code>. Currently it prints &quot;Hello, world!&quot; to our standard out (terminal/console).</p>
<p>What we want to do is to change the HTML in index.html when the WASM loads, which is also when the <code>fn main()</code> runs.</p>
<p>We'll use a function called <code>mount_to_body</code>, which is provided as a tool in <code>leptos</code>, made available in this scope (this main.rs file) with the use statement.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

fn main() {
	mount_to_body()
}</code></pre></pre>
<p><code>mount_to_body</code> requires some arguments to run correctly.</p>
<p>Specifically, it requires a closure. It requires a value that is actually 'runable' or 'callable'.</p>
<h5 id="closures"><a class="header" href="#closures">Closures</a></h5>
<p>A closure is functionality as a <strong>first class citizen</strong>. This means that it's a function that can be stored as a value and passed around to be called later.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_hi(){
	println!(&quot;Hi&quot;);
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>A standard function definition.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">fn main(){
	// let tells the compiler to assign
 	// the value of greeter to whatever is 
 	// after the = and before the semicolon.
	let greeter = || {
		println!(&quot;Hi&quot;);
	};
}</code></pre></pre>
<blockquote>
<p>Single line comments in Rust are prefixed by <code>//</code> at the beginning of the commend. These tell the compiler to ignore anything after it.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>|| {
	println!(&quot;Hi&quot;);
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>A closure</p>
</blockquote>
<p>The above closure syntax is like a function, but it doesn't have a name because we're expecting to assign the functionality to a name. Like we did with greeter above.</p>
<p>The parenthesis that normally encapsulate a functions arguments are converted to pipe characters to diambiguate the two. The body of the closure, just like the body of a function, is encapsulated by curly braces.</p>
<p>The following shows how a function and a closure can be called:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print_hi(); // This was a function
greeter();  // This was a value `greeter`
<span class="boring">}</span></code></pre></pre>
<p>The coolest thing here is that we can see both <code>print_hi</code> and <code>greeter</code> are names that exist in or applications context. They're ideas. Both of them are callable. And we can call them by adding parenthesis at the end.</p>
<p>This starts to hint at some of the underlying simplicity of a lot of programming. At the end of the day, we're giving names to things so that we can specify to the computer, what is what. Then we evaluate or run a bit of functionality, and give the result a name so that we can do something else after. It's this over and over again, all the way down.</p>
<h5 id="using-mount_to_body"><a class="header" href="#using-mount_to_body">Using mount_to_body</a></h5>
<p>Recall that our application's main.rs looked like this</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

fn main() {
	mount_to_body()
}</code></pre></pre>
<p>We have <code>mount_to_body</code> function being called when the application runs as WASM, when index.html is server with the WASM resource.</p>
<p>This function needs functionality to call. It needs a closure. We have the opportunity to tell it what to do with the assumption that when mount_to_body runs, it'll provide us the context in which it's running. This of this as a scope. We can make this assumption because mount_to_body specifies that it needs a closure that makes use of an argument, which we know to be context, abbreviated here as <code>cx</code>.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

fn main() {
	mount_to_body(|cx|{})
}</code></pre></pre>
<p>The above shows what an empty closure being passed to mount_to_body looks like. What this doesn't show is that the closure needs to return something that can be mounted.</p>
<p>If you ran the above you're probably receive an error like:</p>
<pre><code class="language-bash">T: Mountable, required by this bound in `leptos::mount_to_body`
</code></pre>
<p>The error messages will get easier to read over time, but it essentially says, &quot;The return type of the closure can't be used by the internals of mount_to_body. It was expecting something specific to come out of your instructions.&quot;</p>
<p>To solve this problem we're going to use the <code>view!</code> macro provided by leptos.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

fn main() {
	mount_to_body(|cx|{
		view! {  
	        cx,  
	        &lt;h1&gt;&quot;Hello, world!&quot;&lt;/h1&gt;  
	    }
	})
}</code></pre></pre>
<p>We've written the following in the body of the closure, being provided to <code>mount_to_body</code> as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>view! {  
	cx,  
	&lt;h1&gt;
		&quot;Hello, world!&quot;
	&lt;/h1&gt;  
}
<span class="boring">}</span></code></pre></pre>
<p>This procedural macros <code>view!</code> has a body which starts with cx, the context that will be provided to it by mount_to_body when it's run (again, this is inside mount_to_body and evaluated at a later time) and the view or html to mount.</p>
<p>There must be one top level item and all text needs to be quoted. It's a JSX like syntax and beautifully streamlined to write.</p>
<p>If you had <code>trunk serve</code> running this whole time, you can visit http://127.0.0.1:8080 to see your &quot;Hello, world!&quot;</p>
<p>Or, make sure your present working directory is the root of your application, type <code>trunk serve</code> and visit http://127.0.0.1:8080 to see your first working leptos WASM client side awesomeness!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="intro-to-html"><a class="header" href="#intro-to-html">Intro to HTML</a></h1>
<h1 id="what-we-know"><a class="header" href="#what-we-know">What we know</a></h1>
<p>In <a href="/setup_intro">Setup</a> we developed a cursory understanding of:</p>
<ul>
<li>how to create a generic Rust application</li>
<li>how to add <code>Leptos</code> as a dependency to our Rust application</li>
<li>how to serve a file with <code>trunk</code></li>
<li>how to update an HTML file with Rust, using <code>Leptos</code>'s <code>mount_to_body</code> function and it's <code>view!</code> macro</li>
</ul>
<h1 id="what-well-learn"><a class="header" href="#what-well-learn">What we'll learn</a></h1>
<ul>
<li>Working with HTML and developing a mental model</li>
</ul>
<h1 id="where-were-at"><a class="header" href="#where-were-at">Where we're at</a></h1>
<p>Code from our <code>main.rs</code> looks like this:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;h1&gt;&quot;Hello, world!&quot;&lt;/h1&gt;  
        }  
    })  
}</code></pre></pre>
<blockquote>
<p>The <code>main</code> function <code>fn</code> is run when our application runs as WASM.</p>
<p>Recall that the <code>trunk</code> tool uses <code>cargo</code> also a tool with <code>rustc</code> to compile it to the WASM target, which gets served and linked to our index.html. We view (request) the page in our browser, loading the html and linked WASM, kicking the whole thing off.</p>
<p>When the application runs the function <code>mount_to_body</code> is called (runs), which we pass (or provide) a closure (a big of functionality stored as a value) as an argument to it's callback parameter (the bucket that holds things that <code>mount_to_body</code> needs to run, <em>&quot;function dependencies&quot;</em>).</p>
<p>When <code>mount_to_body</code> runs, it takes the  functionality we've provided as a closure (a <em>strategy</em> if you will) and calls it (makes it run) with its runtime context <code>cx</code>. This does all of the heaving lifting to write our heading the body of our HTML page in index.html</p>
</blockquote>
<h1 id="lesson-working-with-html-and-developing-a-mental-model"><a class="header" href="#lesson-working-with-html-and-developing-a-mental-model">Lesson: Working with HTML and developing a mental model</a></h1>
<p>We're not doing much more than creating a static template. If this is all you need, better to stick with a plain old HTML file.</p>
<h2 id="html-elements-and-tags"><a class="header" href="#html-elements-and-tags">HTML Elements and Tags</a></h2>
<p>HTML is made up of Elements. There are a whole list of HTML elements ready for use and supported by all current browsers, from heading and paragraphs to form elements for collecting data from users like. These Elements are written using HTML tags, <code>&lt;h1&gt;</code>, <code>&lt;p&gt;</code>, and <code>&lt;input&gt;</code> respectively.</p>
<h3 id="tags-with-content"><a class="header" href="#tags-with-content">Tags with content</a></h3>
<p>Some tags have content. The syntax is to encapsulate the content or wrap it with opening and closing tags. The closing tag has a slash before the tag name.</p>
<pre><code class="language-html">	&lt;h1&gt;Some Content&lt;/h1&gt;
</code></pre>
<blockquote>
<p>This Heading 1 tag has content, which requies a closing tag so that it's content can be wrapped/encapsulated.</p>
</blockquote>
<p>What's neat about this opening and closing tag business is that it's not <em>that</em> different from when we called a function and provided an argument (value) for it's parameter. As time goes on you'll start to see a pattern emerging. The above isn't going to look at different from:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	h1(&quot;Some Content&quot;)
<span class="boring">}</span></code></pre></pre>
<h3 id="tags-without-content"><a class="header" href="#tags-without-content">Tags without content</a></h3>
<p>Some tags don't have content. To express a tag without content we add a backslash at the end of the tag of the tag. This tells browsers that there is no closing tag.</p>
<pre><code class="language-html">&lt;hr /&gt;
</code></pre>
<blockquote>
<p>This Horizontal Rule tag doesn't have a closing tag</p>
</blockquote>
<h3 id="tag-configuration-with-properties-and-attributes"><a class="header" href="#tag-configuration-with-properties-and-attributes">Tag configuration with properties and attributes</a></h3>
<p>HTML Elements can be configured by setting values for supported properties and attributes. If you've played around with HTML before you'll probably have seen commong properties like <code>id</code> and <code>class</code>:</p>
<pre><code class="language-html">&lt;h1 id=&quot;my-unique-heading&quot;&gt;Hello, world!&lt;/h1&gt;
</code></pre>
<blockquote>
<p>Some poperties have specific requirements for their values. <code>id</code> for example, should have a unique value across all Elements on the page.</p>
</blockquote>
<pre><code class="language-html">&lt;input name=&quot;first-name&quot; placeholder=&quot;Enter your name...&quot; type=&quot;text&quot; /&gt;
</code></pre>
<blockquote>
<p>The input tag has a <code>type</code> which completely changes how its rendered (displayed to the user).</p>
</blockquote>
<h3 id="the-browser-as-interpreter"><a class="header" href="#the-browser-as-interpreter">The browser as interpreter</a></h3>
<p>When you send a request to the server, it returns a response which has a body (the data, often as text) and headers (meta information about the body). Information in the headers tells the browser how to interpret the body.</p>
<blockquote>
<p>Analogy time: Imagine if you went to a library and asked a librarian for a book. This is like you, the web browser, submitted a request to a server. The librarian (the server) will then provide a response to your request. They may return with the book and a slip of paper saying, &quot;I found the book and this book is in english.&quot; We can now use our knowlege of the english language to parse the book (turn it into meaningful data) and understand it.</p>
</blockquote>
<p>Traditionally servers respond to web requests telling the browser that the body's response  is text/html. A browser very deeply wants to render your page for you, so it dutifully reads through what it's been told is html, parses it into meaningful data (the DOM, Document Object Model), and renders it to the screen.</p>
<p>Things like:</p>
<pre><code class="language-html">&lt;input name=&quot;first-name&quot; placeholder=&quot;Enter your name...&quot; type=&quot;text&quot; /&gt;
</code></pre>
<p>Turn more into an object (a thing) with the following properties:</p>
<pre><code>HTML Element Type = &quot;input&quot;
name = &quot;first-name&quot;
placeholder = &quot;Enter your name...&quot;
type = &quot;text&quot;
</code></pre>
<blockquote>
<p>This isn't real code, but it does look a lot like what we'll call a <strong>struct</strong> in Rust later. Once again we can see similar shared underlying principles. This idea of &quot;a thing with stuff&quot; comes up time and time agin.</p>
</blockquote>
<p>There may be bits of information that the browser doesn't understand. Instead of crashing it often ignores this unknown information, or makes assumptions about it to still continue to render the page.</p>
<p>Browsers and HTML rendering engines are extremely complex and down right magical. We can throw so much at them and they keep on going.</p>
<h3 id="what-the-element"><a class="header" href="#what-the-element">What the element?</a></h3>
<p>Recall that before we talked about HTML elements, properties, and attributes. It might feel like HTML is an expressive programming language, but it is actually what we would call a DSL (Domain Specific Language). They're instructions that pertain specific to rendering web pages that tell the browser our intent. We <strong>declare</strong> what we want and it's the browser's <strong>imperative</strong> to decide how to render it.</p>
<p>In standard HTML you can not just make up properties or Elements/tags. It might look like we're choosing to write <code>h1</code> because it's convenient for us to think about a primary heading as a <code>h1</code>, but this is actually part of the specification of HTML.</p>
<p>Developers can now create their own custom elements with Javascript, but we're going to ignore that for now. Just know that it does exist but more work is required than just writing you own tag names.</p>
<h3 id="what-does-this-mean-for-the-view-macro-and-which-html-elements-we-can-use-in-it"><a class="header" href="#what-does-this-mean-for-the-view-macro-and-which-html-elements-we-can-use-in-it">What does this mean for the <code>view!</code> macro and which HTML elements we can use in it?</a></h3>
<p>The content that we place in our <code>view!</code> macro is interpreted by the <code>view!</code> macro when the rust compiler expands it. It takes what we've provided and says, &quot;Ok, so this is what you want... but the rest of the application can't work with this. What you've written isn't actually HTML and it's not actually Rust. I'll parse this input and rewrite it so that the rest of our application can use it, saving you from the verbosity and potentially error prone nature of writing it yourself.&quot;</p>
<p>In the next lesson we'll learn about making components which we can compose and how Leptos allows us to have custom components/elements while still generating HTML that the browser can parse and understand according to the HTML spec.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="html-and-the-view-macro"><a class="header" href="#html-and-the-view-macro">HTML and the <code>view!</code> macro</a></h1>
<h2 id="what-we-know-1"><a class="header" href="#what-we-know-1">What we know</a></h2>
<ul>
<li>HTML is a specification for a domain specific language that is parsed by a web browser to render a web page</li>
<li>The web browser will do its best to render a page, ignoring or gracefully interpreting code in a page that doesn't match the HTML specification.</li>
<li>The <code>view!</code> macro accepts its arguments between curly braces <code>{}</code>, accepting a context <code>cx</code> and HTML like mark-up.</li>
</ul>
<h1 id="what-well-learn-1"><a class="header" href="#what-well-learn-1">What we'll learn</a></h1>
<ul>
<li>Creating custom components</li>
</ul>
<h1 id="where-were-at-1"><a class="header" href="#where-were-at-1">Where we're at</a></h1>
<p>Code from our <code>main.rs</code> looks like this:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;h1&gt;&quot;Hello, world!&quot;&lt;/h1&gt;  
        }  
    })  
}</code></pre></pre>
<blockquote>
<p>We can see that after the context variable we have some HTML like text. If this were HTML, you'd have a heading that reads <strong>&quot;Hello, world!&quot;</strong> with the quotes displaying. However, this isn't pure HTML and the macro will process the template to remove the quotes.</p>
</blockquote>
<h2 id="view-macro-syntax"><a class="header" href="#view-macro-syntax"><code>View!</code> macro syntax</a></h2>
<p>The <a href="https://docs.rs/leptos/latest/leptos/macro.view.html">view! macro documentation</a> is very nicely detailed with details about it's basic and advanced syntax. It's a JSX like syntax. We'll slowly touch on all of the features as we continue to learn Rust and <code>Leptos</code>.</p>
<p>For now, the important thing to remember is that strings need to be quoted.</p>
<p>@todo, highlight that a view contains element markup and text nodes. That's it</p>
<h2 id="adding-more-to-a-view"><a class="header" href="#adding-more-to-a-view">Adding more to a view</a></h2>
<p>You can continue to add other html elements as if you were writing plain HTML. Line breaks and indentation will not break the syntax. HTML code often has a lot of line breaks or white space from code formatting. Web browsers will ignore this unless you specify that you want the white space retained. We won't go into that in this guide. Multiple space characters will get coalesced into a single space.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>view! {  
	cx,  
	&lt;h1&gt;&quot;Hello, world!&quot;&lt;/h1&gt;
	&lt;p id=&quot;NiceAffirmation&quot;&gt;&quot;
		I know things are hard, 
		but I think you're doing great!&quot;
	&lt;/p&gt;
}  
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Note that we have an id attribute set for the paragraph with a quoted value.</p>
</blockquote>
<h2 id="custom-elements"><a class="header" href="#custom-elements">Custom elements</a></h2>
<p>Recall that our Rust <code>view!</code> macro input is not actually HTML. It gets processed and converted into HTML. This gives us some extra freedom, like the ability to write our own custom elements in Rust with their own templates.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>view! {  
	cx,  
	&lt;h1&gt;&quot;Hello, world!&quot;&lt;/h1&gt;
	&lt;NiceAffirmation /&gt;
}  
<span class="boring">}</span></code></pre></pre>
<p>The above code will be converted into the following HTML:</p>
<pre><code class="language-html">&lt;h1&gt;Hello, world!&lt;/h1&gt;
&lt;NiceAffirmation&gt;&lt;/NiceAffirmation&gt;
</code></pre>
<p>The browser doesn't know what to do with the tag <code>&lt;NiceAffirmation&gt;</code>, so it treates it as a generic element that doesn't do anything.</p>
<p>We can define a template for our &quot;NiceAffirmation&quot; component and have it render our as if the element existed in the HTML spec. In a sense, we can make up our own specification for our own application using domain specific component names, and then let <code>Leptos</code> handle the rest.</p>
<p>In <code>Leptos</code> we call custome elements <code>components</code></p>
<h2 id="registering-a-custom-element-with-a-component-function"><a class="header" href="#registering-a-custom-element-with-a-component-function">Registering a custom element with a component function</a></h2>
<p>You're probably already thinking, &quot;I can imagine how I would want to break my application down into small components which I can compose/combine together.&quot; Thankfully, <code>Leptos</code> makes that exceptionally easy to do.</p>
<p>We do this by writing a function that returns (or evaluates to) the result of a <code>view!</code> macro.</p>
<p>In the following example we're using a pseudo-HTML component tag (our <strong>Leptos component</strong> tag) <code>&lt;NiceAffirmation /&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>view! {  
	cx,  
	&lt;h1&gt;&quot;Hello, world!&quot;&lt;/h1&gt;
	&lt;NiceAffirmation /&gt;
}  
<span class="boring">}</span></code></pre></pre>
<p>When the macro runs and expands the code, it'll look for a function that can be used to replace the <code>&lt;NiceAffirmation&gt;</code> tag. Leptos is magical and will do this look up for us, calling that function and embedding the the correct template as a replacement for our <strong>Leptos component</strong> tag.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
pub fn NiceAffirmation(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;You look nice today.&quot;&lt;/p&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>The definition of the function that will handle template generation for <code>&lt;NiceAffirmation /&gt;</code></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-we-know-2"><a class="header" href="#what-we-know-2">What we know</a></h1>
<ul>
<li>The <code>view!</code> macro has a body encapsulated by <code>{...}</code> with two components, the context/scope and the template, separated by a comma.</li>
<li>The <code>view!</code> macro can accept:
<ul>
<li>Quoted text</li>
<li><em>HTML element</em> tags, written in lower case</li>
<li><em>Custom web component</em> element tags, written in kebab-case (i.e. my-custom-component)</li>
<li><em>Leptos component</em> tags, written in PascalCase (i.e. MyCustomComponent)</li>
</ul>
</li>
<li>Leptos components only know what to render in place of their component tag if we provide a function with the same name as the component (in PascalCase), with <code>#[component]</code> on the line directly before the function's definition.</li>
<li>Rust's basic function syntax of <code>fn my_function_name(){}</code>.</li>
</ul>
<h1 id="what-well-learn-2"><a class="header" href="#what-well-learn-2">What we'll learn</a></h1>
<ul>
<li>Creating custom components</li>
<li>How components work</li>
</ul>
<h1 id="the-lesson"><a class="header" href="#the-lesson">The lesson</a></h1>
<p>In the previous lesson we presented the following code for a Leptos component, but we did not explain the code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn NiceAffirmation(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;You look nice today.&quot;&lt;/p&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Above we have a Leptos component (render function) which when called yield the result of a view! macro. Within the macro we have our standard two pieces, the context/scope, and the template mark-up.</p>
</blockquote>
<h3 id="breakdown"><a class="header" href="#breakdown">Breakdown</a></h3>
<h4 id="the-component-attribute-and-meta-programming"><a class="header" href="#the-component-attribute-and-meta-programming">The <code>#[component]</code> attribute and &quot;meta programming&quot;</a></h4>
<p>Rust makes use of a special attribute syntax which the compiler can use to process your source code before it's compiled. This is often called &quot;meta programming&quot; because part of our application is responsible for writing another part of our application.</p>
<p>Library authors include features like this so that users of the library can focus on writing domain specific code (code relating to the specific problem they're solving).</p>
<p>The effect of this is that we, the user of Leptos, only have to worry about writing a function that tells the application what the result of rendering a component yields (returns). What we don't have to worry about is writing the code to make sure the function is called if the component is used in other <code>view!</code> macros.</p>
<h4 id="function-definition-arguments-types-and-returns"><a class="header" href="#function-definition-arguments-types-and-returns">Function definition, arguments, types, and returns</a></h4>
<p>The following line in our code is a function definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn NiceAffirmation(cx: Scope) -&gt; Element {  
<span class="boring">}</span></code></pre></pre>
<p>It defines the idea of doing some work with a noun (the function's name) so that we can refer to it in the context of our application.  This idea of, &quot;we know nothing until we define it,&quot; is an important concept in communication in general but especially so in programming.</p>
<h5 id="breaking-down-the-function-definition"><a class="header" href="#breaking-down-the-function-definition">Breaking down the function definition</a></h5>
<p><code>fn</code> - The definition starts with this keyword which is an abbreviation for function. It tells the compiler that we're about to define a term for a process/task that can be done (called).</p>
<p><code>NiceAffirmation</code> - The name of the function in PascalCase. This name allows us to refer to the function so that if we say, &quot;Hey computer, do NiceAffirmation,&quot; it'll know where to look up what that means. It is important to note that standard function naming in Rust is written with snake_case, all lowercase letters with words separted by underscores. Leptos components use PascalCase so that the function responsible for rendering a component will match its tag name. <em>This deviates from standard Rust convention</em></p>
<p><code>(...)</code> - Some tasks require additional &quot;things&quot; for the task to be carried out. I use the term things because the requirements can be varied. Some tasks may require specialized tools (other tasks/processes), some tasks may require something to be worked upon (a subject), and some tasks require anciliary information that act as a reference (reference data). Parenthesis after the function name encapsulates this required data. These are called <strong>function parameters</strong> and they are written out separated by a comma. The values passed into these parameteres are called <strong>function arguments</strong>.</p>
<p><code>cx: Scope</code> - Each parameter listend between  <code>(</code>and <code>)</code> in a function's definition are written using a name that we can use to refer to it when doing  the work in the body of the function and the classification of what it is (it's type). The parameter name exemplified here as <code>cx</code> is written in snake_case and the type, written here as <code>Scope</code> is written in PascalCase. This helps disambiguate the two. <strong>Rust requires us to know the type of everything!</strong> But when you think about it, this makes complete sense. For example, imagine if we described a task called <code>paint_fruit_still_life</code>. To do this work we need an artist who must be a Painter, and a subject to paint which must be Fruit. It's important to note that we're just making this stuff up. We're describing the interaction of data to the application. Programming is often about setting up relationships. We would also want to guarantee that we always expect the result of this task to be a Painting. <em>It is up to us to define what it means to be a Painter, what Fruits are, and what a Painting is!</em> A definition for this could look like <code>fn paint_fruit_still_life( artist: Painter, subject: Fruits) -&gt; Painting {}</code>.  In case of Leptos components, the first thing we're accepting is the runtime context which we give the name <code>cx</code> which is of the type <code>Scope</code>. Scope is defined by Leptos and brough into the context of our application with the previously described <code>use leptos::*</code> (include all <code>*</code>) use statement.</p>
<blockquote>
<p>It's kind of fun to think about how much we imply these types in real life. If any of you have interacted with kids you can witness first hand how important it is to define the nouns we use and be clear about expectations.</p>
</blockquote>
<p><code>-&gt; Element</code> - The thin arrow followed by the name of a type indicates the result of running a function or doing a task. In the case of our Leptos component, the return type is an Element. This type is defined by Leptos and imported by our previously described <code>use leptos::*</code> (include all <code>*</code>) use statement. Some functions may not have this if they do not return anything as the result of doing their work.</p>
<h4 id="function-body-and-expressions"><a class="header" href="#function-body-and-expressions">Function body and expressions</a></h4>
<p>The body of a function is encapsulated by curly braces.<code>{...}</code>.  This is a scope. What happens in the scope, stays in the scope. A function will return the result of evaluating the last statement of its function body. You can think of statements like sentences, only the end with semicolons. This means that the last statement without a semicolon acts as the 'final word' for what a function yields. This is why the <code>view!</code> macro in our example does not have a semicolon at the end. The function runs, the last expression is the view! macro, which when evaluated yields an Element. Rust allows you to cut your application short by placing the <code>return</code> keyboard before a statement as well.</p>
<h1 id="what-we-learned"><a class="header" href="#what-we-learned">What we learned</a></h1>
<p>By defining the following function with the <code>#[component]</code> annotation, we can tell Leptos how to render specific HTML in place of a Leptos component tag in other <code>view!</code> macro's templates.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;NiceAffirmation /&gt;  
        }  
    })  
}

#[component]  
fn NiceAffirmation(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;You look nice today.&quot;&lt;/p&gt;  
    }  
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-and-the-view-macro"><a class="header" href="#variables-and-the-view-macro">Variables and the view! macro</a></h1>
<h1 id="what-we-know-3"><a class="header" href="#what-we-know-3">What we know</a></h1>
<ul>
<li>The <code>view!</code> macro can be used to create html</li>
<li>The view! macro can contain <em>custom web components</em> (using kebab-case names and requiring at least one hypen) and <em>Leptos components</em> (using PascalCase)</li>
<li>Leptos components are defined by defining a function with the name of the component using a standardized function signature (parameters and return type), and adding meta data to a function so that rust will pre-process the function and turn it into a component function for you behind the scenes.</li>
<li>Leptos components can be nested in other Leptos components</li>
</ul>
<h1 id="what-well-learn-3"><a class="header" href="#what-well-learn-3">What we'll learn</a></h1>
<ul>
<li>How to a number text in a variable (define a variable)</li>
<li>A introduction to types and memory safety</li>
</ul>
<h1 id="the-lesson-1"><a class="header" href="#the-lesson-1">The lesson</a></h1>
<p>In the previous lesson we presented the following code</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;

fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;NiceAffirmation /&gt;  
        }  
    })  
}

#[component]  
fn NiceAffirmation(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;You look nice today.&quot;&lt;/p&gt;  
    }  
}
</code></pre></pre>
<h2 id="adding-a-feature"><a class="header" href="#adding-a-feature">Adding a feature</a></h2>
<p>Along with this affirmation we'd like to add some kind of lucky number for the day to go with this affirmation.</p>
<p>This example uses integers because they are a simple data type in Rust and a good entry point into variables and Rust's type system. It's a silly example, I know. ^.^</p>
<p>We are going to add some things to our code and change a few existing components. The process of splitting code up and moving it around to allow for different changes is known as <em>Refactoring</em>.</p>
<p>First, have a read through the result to see if you can spot the changes. We're using all of the same principles as before.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
           &lt;NiceAffirmation /&gt;  
           &lt;LuckyNunber /&gt;
        }  
    })  
}

#[component]  
fn NiceAffirmation(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;You look nice today.&quot;&lt;/p&gt;  
    }  
}
#[component]  
fn LuckyNumber(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is 4&quot;&lt;/p&gt;  
    }  
}
</code></pre></pre>
<h3 id="developer-thoughts"><a class="header" href="#developer-thoughts">Developer thoughts</a></h3>
<p>Throughout these tutorials I will try to include the innner monologue that I have when thinking through a problem in the hope that it'll help you all develop your own. I also hope that the simplicity of the steps will help keep you focused when trying to work through your own problems. Don't get too far ahead of the next step in you mind. Keep this simple and break things down into small improvements. You do not need to completely solve the problem in one go. <em>Write, review, revise, repeat.</em></p>
<p>The steps to get to the above code are as follows:</p>
<ol>
<li>I need to add a new component for the LuckyNumber, so I'll write the component with a lucky number.</li>
<li>I need to add the component to the web page. I could make a new component called MorningGreeting, which has a NiceAffirmation and a LuckyNumber, but I stopped myself. This extra component would add complexity without adding anything beneficial just yet. I do not need to group these two Leptos components. They do not need to be separated from anything else. This is an important lesson to not prematurely cut your code apart and make things too comlicated. As a solution I'll just add the LuckyNumber component to my main function's view.</li>
<li>I can't change the value of the lucky number. Hooray, I've outlined an improvement and a next task. I need to find a way to be able to provide a number to my component. My component needs a parameter for the lucky number which I can provide as an argument (value).</li>
</ol>
<h2 id="tokens-and-values-in-view-components"><a class="header" href="#tokens-and-values-in-view-components">Tokens and values in <code>view!</code> components</a></h2>
<p>We've established that we need to take the 4 and make it something that can change. We need to add a token, like a symbol, as a placeholder. We need a way of saying &quot;use whatever we're calling the_lucky_number here.&quot;</p>
<p>In the <code>view!</code> macro we know that text input needs to be encapsulated by <code>&quot;...&quot;</code> quotes.</p>
<p>Values need to be encapsulated by <code>{...}</code> curley braces.</p>
<p>We'll update the following line:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        &lt;p&gt;&quot;Today's lucky number is 4&quot;&lt;/p&gt;  
<span class="boring">}</span></code></pre></pre>
<p>To look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
    }  
}

<span class="boring">}</span></code></pre></pre>
<p>Note that the quoted text no longer has the number <code>4</code>. Importantly, note that the token we've added after the string is encapsulated by curley braces. There's a space between string's closing quote and the token's first curley brace. This space will not be printed, it's just for ease of reading for developers.</p>
<p>But there's a problem. We've used <code>the_lucky_number</code> (an idea/thing/noun) but we haven't defined <em>what</em> the this idea refers to. Rust's compiler and our application doesn't understand the idea. We know it because it's in our mind, but we need to share it with the application. Writing a program is a lot like explaining something to a person who has no prior knowedge or context to understand what you're talking about. We need to define what we're talking about and what we mean.</p>
<blockquote>
<p><strong>Aside:</strong> We use shared context a lot in our lives without even knowing it. We have our own language—even slag/colloquialisms—that we use without even thinking about it. We may say, &quot;Hey, can you put this bag in the bin?&quot; Someone might think, &quot;bin in my mind is defined as the garbage and they want this to be thrown out,&quot; and another might think, &quot;by bin they mean that basket over there and they want me to put this in storage.&quot; These are vastly different outcomes! Programming is tricky because we need to be aware of how others (in this case, the computer) will interpret the meaining of the language we use. You'll also find that being aware of the importance of context and how it impacts the decoding and interpreting of meaning will make you a better communicator and will help you understan others by thinking about the context they're assuming you have when interpreting their messages.</p>
</blockquote>
<p>To solve this missing and undefined context we'll write a statement that explicitly states what we mean by <code>the_lucky_number</code>.</p>
<p>Rust's syntax is very intuitive for this.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let the_lucky_number = 42;
<span class="boring">}</span></code></pre></pre>
<p>Now rust knows exactly what we mean when we say <code>the_lucky_number</code>. In this line we're telling the compiler, &quot;Hey rust, let <code>the_lucky_number</code>(the idea of a thing we're referring to as the_lucky_number) be assigned to the value 42&quot;. We can actually add even more specificity to this to tell the compiler what type of number it is.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let the_lucky_number: i32 = 42;
<span class="boring">}</span></code></pre></pre>
<p>In the above we've added a type to the noun. The pattern is as follows:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let the_name_of_the_thing : the_type = the_value ;
<span class="boring">}</span></code></pre></pre>
<p>We've said, &quot;let the_lucky_number be an integer that is 32 bits in size (<code>i32</code>) with a value of 42&quot;. The Rust compiler will do its best to infer (figure out) the type if you don't explicitly state it. Rust will also tell you there's a problem if you've tried to assign a value that isn't a valid 32 bit integer.</p>
<p>The compiler will infer that when youi say <code>42</code> you don't mean a text string with the characters <code>42</code>, or that you don't mean 42.0 (a floating point number).</p>
<p>Our updated function isn't fully there yet, but we are able to place a number, known to Rust as an integer, into the `view! template.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope) -&gt; Element {  
	let the_lucky_number:i32 = 42;
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<h2 id="rusts-type-system"><a class="header" href="#rusts-type-system">Rust's Type System</a></h2>
<h3 id="a-mental-model-for-understanding-types"><a class="header" href="#a-mental-model-for-understanding-types">A mental model for understanding types</a></h3>
<p>Specifying the type of something is the same as specifying the range (a group) of possible values. If we specify <code>bool</code> (a boolean value) as a type, the possible values are <code>0</code> and <code>1</code>.  This is a <code>1 bit</code>.</p>
<p>When we state <code>i32</code> as a type for <code>the_lucky_number</code>, we're telling the Rust compiler, numbers in this range must be between -2,147,483,648 and 2,147,483,647. These are the largest and smallest numbers that you can create with a sequence of 32 zeros and ones <code>bits</code> in boolean, interpreted as a single number.</p>
<h3 id="the-importance-of-a-values-size"><a class="header" href="#the-importance-of-a-values-size">The importance of a value's size</a></h3>
<p>The really neat thing about computers and programs is that at the end of the day, everything is a sequence of zeros and ones. All of the things we're writing eventually get turned into bits laid out in memory.</p>
<blockquote>
<p>The really brain breaking thing here—don't dwell on it too much—is that functions are also all turned into zeros and ones!</p>
</blockquote>
<p>When we say that an <code>i32</code> is a sequence of bits, iterpreted as a single number, we mean just that. The application, under the hood, knows that 32 bits should be grabbed from memory and interpreted as a binary number. Imagine if in that same sequence of zeros and ones you had two 16 bit <code>i16</code> numbers. They would take up the same amount of space in memory (16 x 2 = 32) but they are not a 32bit number!</p>
<p>Our application needs to know how many bits to pick-up and read sequentially to interpret as a value. It also needs to know how much space (how many bits) are available to store data for that type.</p>
<p>This is one of the main features/benefits of the Rust programming language and how it lets us write safe programs. Knowledge of the size of a type allows us to safely read and write to memory.</p>
<p>Rust will always make sure that we can't have a situation where two 16 bit numbers get written in a block of 32 bits, and vise versa.</p>
<p>I realize this is complicated. Rust takes care of all of this for us. But it's important to know why we need to specify the type of a value throughout Rust, where as other languages often don't care.</p>
<h3 id="types-are-value-constraints"><a class="header" href="#types-are-value-constraints">Types are value constraints</a></h3>
<p>Rust's type system adds constraint based on size, but it also adds it based on capability/use. We'll learn more about that later but it's important that the idea be introduced.</p>
<p>At the end of the day, an easy mental model to keep is that types are constraints. An untyped value could be literally any size, supporting any functionality.</p>
<p>It's a kin to if someone said, &quot;I have a thing.&quot; You don't know if that thing is a sandwich that can be eated, if that thing is a feeling, or if that thing is a surprise that you'll be thrown a party on your birthday.&quot; As you can imagine, writing a progam where any idea could be any type can be tricky. We'd need to keep those types in our mind so that we don't inadvetantly try to do something with &quot;things&quot; that can be done to or with them.</p>
<p>When I think about types, I think about them as a list of possible values.</p>
<p>If the type is a <code>bool</code> it's possible values are 0 and 1. I can deal with that! If the type is  <code>i8</code>, then I know that the value will be a number between -128 and 127.</p>
<p>And that really is the important thing about types as constraints for Rust. Rust wants all types to be known (or to be inferable/figure-out-able) so that there <em>no surprises</em>. Rust's compiler will actually highlight spots where it sees that you've accounted or some of the possible values, but not all of them. It doesn't want you to be surprised. The Rust compiler is so nice. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leptos-component-properties"><a class="header" href="#leptos-component-properties">Leptos Component Properties</a></h1>
<h1 id="what-we-know-4"><a class="header" href="#what-we-know-4">What we know</a></h1>
<ul>
<li>Components are created with specific function definitions and a [#component] function anotation.</li>
<li>Variables can be injected into <code>view!</code> macro templates</li>
</ul>
<h1 id="what-well-learn-4"><a class="header" href="#what-well-learn-4">What we'll learn</a></h1>
<ul>
<li>How to pass values to components</li>
</ul>
<h1 id="the-lesson-2"><a class="header" href="#the-lesson-2">The Lesson</a></h1>
<p>In the previous lesson we created a component with a number, but that number is hard coded. It is static and can not change.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope) -&gt; Element {  
	let the_lucky_number:i32 = 42;
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>If we've played around with HTML or recall from earlier lessons, we might remember that HTML elements have properties, or key-value pairs of data. For example, in  <code>&lt;h1 class=&quot;fancy&quot;&gt;Lah dee dah&lt;/h1&gt;</code> we have a heading 1 element which has a class with the string value &quot;fancy&quot;. Input elements provide a more data driven example in that <code>&lt;input type=&quot;number&quot; value=&quot;42&quot; /&gt;</code> is an element that as a value property, with a value of 42.</p>
<p>What we're going to focus on is being able to write <code>&lt;LuckyNumber number={42} /&gt;</code>, actually provide it a number! We'll pass the value into the component the same as we would pass the value (argument) to a function as a property.</p>
<h2 id="step-1-updating-the-component-function-to-accept-an-external-value-as-a-property"><a class="header" href="#step-1-updating-the-component-function-to-accept-an-external-value-as-a-property">Step 1: Updating the component function to accept an external value as a property</a></h2>
<p>We need to move our noun <code>the_lucky_number</code> &quot;up and out&quot; of our component function. It needs to be a requirement of the component. We'll need someone else to provide its value for the component to work. To do this, we'll list it as a function parameter and remove the <code>let</code> statement where we define it's value.</p>
<p>The following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope) -&gt; Element {  
	let the_lucky_number : i32 = 42;
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>Turns into this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number : i32) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>Note how we've extrated the middle bits of our <code>let</code> line, moving <code>the_lucky_number : 32</code> into the function's parameter list). The name of the parameter is listed, followed by a colon, and the type of value that it's allowed to be.</p>
<blockquote>
<p>It's worth the reminder that variable names are written in snake_case by convention.</p>
</blockquote>
<h2 id="step-2-update-component-props-to-pass-a-value-to-a-component"><a class="header" href="#step-2-update-component-props-to-pass-a-value-to-a-component">Step 2: Update component props to pass a value to a component</a></h2>
<p>Our main function had a <code>view!</code> macro template with <code>&lt;LuckyNumber /&gt;  </code> in it. We've introduced the idea of a property called <code>the_lucky_number</code> in our component's definition, so we can make use of it here.  We can add the property, with the same name parameter name we used in the component, and assign a value to it.</p>
<p><code>&lt;LuckyNumber the_lucky_number=32/&gt;  </code></p>
<p>The updated main function now looks like this:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;NiceAffirmation /&gt;  
	        &lt;LuckyNumber the_lucky_number=32 /&gt;  
        }  
    })  
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leptos-component-dynamic-content-separation"><a class="header" href="#leptos-component-dynamic-content-separation">Leptos component dynamic content separation</a></h1>
<h2 id="what-we-know-5"><a class="header" href="#what-we-know-5">What we know</a></h2>
<ul>
<li>Leptos components can accept properties and use them in their <code>view!</code> templates.</li>
</ul>
<h2 id="what-well-learn-5"><a class="header" href="#what-well-learn-5">What we'll learn</a></h2>
<ul>
<li>How Leptos' components are able to differentiate between dynamic and static content in their templates</li>
</ul>
<h2 id="the-lesson-3"><a class="header" href="#the-lesson-3">The Lesson</a></h2>
<p>In the previous lesson we were able to pass a value as an argument to a Leptos component's property. The Leptos component's signature specifies this property as a function argument. When the application starts, Leptos expands these <code>view!</code> macros and creates templates. This happens once on startup. Leptos then updates the web page's document object model (DOM) through the <code>mount_to_body</code> function call.</p>
<p>The properties passed to the Leptos component have the ability to impact how the component is rendered. In the following example, the variability is visible as text inside the Leptos component's template paragraph tags.</p>
<p>This is all well and good by you might notice something interesting when we look at the HTML.</p>
<p>Observe the following Rust code, creating and using our Leptos component.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
	        &lt;LuckyNumber the_lucky_number=12 /&gt;  
        }  
    })  
}  
  
#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number: i32) -&gt; Element {  
    view!{  
        cx,  
        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
    }  
}</code></pre></pre>
<p>If we run <code>trunk serve</code> from our Rust project's directory, we'll get some prompts about our web server running. Opening the page up reveals the following HTML.</p>
<pre><code class="language-html">&lt;p&gt;Today's lucky number is &lt;!----&gt;12&lt;/p&gt;
</code></pre>
<p>Surprisingly, the <code>&lt;LuckyNumber the_lucky_number=12 / &gt;</code> has compeltely dissolved away. This might seem shocking, given that our main function says we're mounting the <code>LuckyNumber</code> Leptos component to the body with a call to the <code>mount_to_body</code> function. The reason for that is, a <code>view!</code> template <em>is not</em> HTML. </p>
<p>There are a few things we'll need to go over to give you a really solid explanation of how this works and how Leptos handles dynamic content.</p>
<h3 id="leptos-components-and-templates"><a class="header" href="#leptos-components-and-templates">Leptos components and templates</a></h3>
<p>Leptos components are really interesting. Their <code>view!</code> templates all distill down to HTML. We previously talked about HTML elements which come to life as an HTML tag, and when parsed in the document object model (DOM), become a DOM node. This is a fancy way of saying, when we write HTML, the browser reads it, tries to make sense of it, and creates a nested tree like structure that has hierarchy of the components.</p>
<p>Text, even though it's not an HTML element, but also be interpreted and added to the DOM. To do this, a browser creates a text node.</p>
<p>Leptos adds HTML comments to force the web browser to break what seems like contiguous text, into multipe text nodes. This is done by adding HTML comments which are encapsulated by  <code>&lt;!--</code> and <code>--&gt;</code>. </p>
<p>With this in mind, the HTML output that we saw before:</p>
<pre><code class="language-html">&lt;p&gt;Today's lucky number is &lt;!----&gt;12&lt;/p&gt;
</code></pre>
<p>Creates the following paragraph node with two child text nodes.</p>
<pre><code class="language-html">	&lt;p&gt;
		Today's lucky number is &lt;-- this is a text node
		12                      &lt;-- this is a text node
	&lt;/p&gt;
</code></pre>
<p>And we can see how it directly matches up with the <code>view!</code> template if we think about the static text string as being one text node, and the dyamic text which will come from <code>the_lucky_number</code>'s value, as another.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	&lt;p&gt;
		&quot;Today's lucky number is &quot; 
		{the_lucky_number}
	&lt;/p&gt; 
<span class="boring">}</span></code></pre></pre>
<p>Leptos' ability to retain congruency of structure between the <code>view!</code> template and the HTML it yields allows Leptos it to know exactly which text nodes or areas in the page will be dynamic, or are subject to change.</p>
<h3 id="aside-how-leptos-components-deviate-from-expected-web-behaviour-and-custom-elements"><a class="header" href="#aside-how-leptos-components-deviate-from-expected-web-behaviour-and-custom-elements">Aside: How Leptos components deviate from expected web behaviour and custom elements</a></h3>
<blockquote>
<p>Section pending ^.^</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leptos-components-and-logging-events"><a class="header" href="#leptos-components-and-logging-events">Leptos components and logging events</a></h1>
<h2 id="what-we-know-6"><a class="header" href="#what-we-know-6">What we know</a></h2>
<ul>
<li>Leptos makes distinctions between which things are static (will not change) and which are dynamic (can change)</li>
</ul>
<h2 id="what-well-learn-6"><a class="header" href="#what-well-learn-6">What we'll learn</a></h2>
<ul>
<li>How we can make our application dynamic through client side events</li>
</ul>
<h2 id="the-lesson-4"><a class="header" href="#the-lesson-4">The Lesson</a></h2>
<p>We've worked with static templates so far but it would be great if we can start to interact with our application. It would be wonderful if we could do something and see that change happen before our very eyes. </p>
<p>The secret to achieving this is in the &quot;if we could do something,&quot; part of what I just wrote.</p>
<p>When something happens in the browser—a key is pressed, a button is clicked, the mouse is moved—an event is fired. A piece of functionality gets called as part of the browser's JavaScript runtime declaring what happened along with some information about that event. </p>
<p>If we were writing these applications in JavaScript, the native language of the web's interactive runtime, we could declare a function as a callback (will be called when) an event happens, reacting to the interaction. Unfortunately, we can't directly do that because we're writing Rust which becomes WASM. But never fear, we have some pretty great tools to help us around this shortcoming.</p>
<p>Leptos comes bundled with a crate called <code>wasm-bindgen</code>. WASM bindgen which acts as an interface, allowing Rust to call JavaScript features and vise-versa. There are some crates that add extra helper fuctionality on top of that like <code>web_sys</code> which provides types and wrappers to interact with web and browser APIs.</p>
<p>Let's refresh our memory and look at our lucky number Leptos component:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number: i32) -&gt; Element {  
    view!{  
        cx,  
        &lt;div&gt;  
            &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
        &lt;/div&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>Let's add a button to this which will eventually print a message in the client's web browser console (abbreviated for clarity).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	&lt;div&gt;  
		&lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
		&lt;button&gt;&quot;Your Secret Lucky Number&quot;&lt;/button&gt;  
	&lt;/div&gt;  
<span class="boring">}</span></code></pre></pre>
<p>Leptos makes it really easy to add event handlers—functionality triggered by events. We simply write 'on:' followed by the name of the event, and the name of the handler. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;button&gt;&quot;Your Secret Lucky Number&quot;&lt;/button&gt;  
<span class="boring">}</span></code></pre></pre>
<p>... is made interactive as follows...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;button on:click=whisper_in_the_console &gt;&quot;Your Secret Lucky Number&quot;&lt;/button&gt;  
<span class="boring">}</span></code></pre></pre>
<p>But this is incomplete. We've written the name of a handler that we made up, which we're calling <code>whisper_in_the_console</code> but we haven't declared it anywhere. Rust doesn't know what this means. To fix this we'll declare this variable and assign a value to it which is a closure, a function which can run, but which is stored in a variable.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number: i32) -&gt; Element {
	let whisper_in_the_console = |_|{  
	    web_sys::console::log_1(&amp;42.into());
	};  
	view!{  
	    cx,  
	    &lt;div&gt;  
	        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
	        &lt;button on:click=whisper_in_the_console &gt;
		        &quot;Your Secret Lucky Number&quot;
			&lt;/button&gt;  
	    &lt;/div&gt;  
	}
}
<span class="boring">}</span></code></pre></pre>
<p>Let's break down what this assignment means. We'll be less verbose in later chapters, but it's important to start thinking in terms of what we're communicating to the compiler. This will help you become a native speaker of the Rust language. :)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let whisper_in_the_console = |_|{  
    web_sys::console::log_1(&amp;42.into());
};  
<span class="boring">}</span></code></pre></pre>
<p>And like that, now when we click on the button we get the number 42 printed out in the console!</p>
<blockquote>
<p>SUPER IMPORTANT: You do not need to understand the body of this closure to continue. There will be numerous examples of event handlers in future chapters. I am specifically using this example so that you can log something to the browser's console. Further reading will expose you to some advanced concepts about the rust programming language.</p>
</blockquote>
<h4 id="event-handler-closure-signature"><a class="header" href="#event-handler-closure-signature">Event handler closure signature</a></h4>
<p>First let's look at how we even declared the closure and assigned it as a value to a variable. In case you're curious, this is what it means when functions are first class citizens. You might hear programmers mention this idea. It just means that a function can be assigned as a value and passed around.</p>
<p>Here's what the first line says:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	let whisper_in_the_console = |_|{ 
		// this is a comment, letting you know that we removed the
		// event handler's body which we'll step through soon
	};
<span class="boring">}</span></code></pre></pre>
<p><code>let</code> (let it be/declare) that <code>whisper_in_the_console</code> is equal to (there for, it is) a closure which accepts an argument which is never used (marked by the <code>_</code> /underscore character ).</p>
<p>Event handlers must be a function with a single parameter for the event that triggered the handler (the respondant). In our case we're not using that argument, so it's convention to write an underscore in its place instead of giving it a name.</p>
<h4 id="event-handler-body"><a class="header" href="#event-handler-body">Event handler body</a></h4>
<p>There is a lot to unpack in this single line of code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>web_sys::console::log_1(&amp;42.into());
<span class="boring">}</span></code></pre></pre>
<p>The first bit is the crate's, <code>web_sys</code>. Crates are what Rust nomenclature uses when refering to packages or libraries. <code>web_sys</code> can be used in this scope because it was made public and brought into the leptos crate's scope. By writing <code>use leptos::*;</code> at the top of our main.rs file we're bringing in everything that is public in Leptos'.</p>
<blockquote>
<p>You may ask &quot;How did you know to use web_sys?&quot; To be honest, it's a matter of asking around, seeing other examples and discovering useful crates. Some are very popular like web sys and you will use them because they're used in the libraries or frameworks that you're consuming. Developers don't magically know about all of these tools. It takes a lot of exposure to the community to develop this awareness and understanding. Stay cool about it. The knowledge will come with time. For now, trust the process.</p>
</blockquote>
<p>When we write <code>web_sys::console::log_1</code> we're saying, &quot;Use the log_1&quot; function in the console module, from the web_sys crate. </p>
<p>This is the <code>web_sys</code> crate's equivalent of calling console.log in the JavaScript console. In JavaScript you can include as many arguments as you want when calling the log function. This is what programmers call a &quot;variadic&quot; function. Rust does not allow this. To accommodate multiple arguments, console has functions for log, log_1, log_2, log_3 and so on. We have to specify the number of arguments in rust, which is sort of awkwardly, but clearly, done with the suffixed number.</p>
<p>The log function in Rust accept a reference to JsValue data type. Recall that we talked about how types are constraints for possible values. JsValue exists because JavaScript doesn't have any type system what so ever. Rust developers needed to make a type that could interoperate safely with JavaScripts untyped world. </p>
<p>To convert our number (an i32 litera) to a JsValue type we call the <code>into()</code> method on it, which will convert it ot the required type of the log_1 signature which happens to be a JsValue. The log method also requires that we do not pass the actual owned value. It is expecting a reference to data. We can add an ampersand to specify that this is a reference.
And like that we get...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>web_sys::console::log_1(&amp;42.into());
<span class="boring">}</span></code></pre></pre>
<p>Call web_sys's console module's log 1 function which we'll pass a single argument to using the number 42 which we'll convert to the accepted/required type and pass it as a reference.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="leptos-components-updating-from-events"><a class="header" href="#leptos-components-updating-from-events">Leptos components updating from events</a></h1>
<h2 id="what-we-know-7"><a class="header" href="#what-we-know-7">What we know</a></h2>
<ul>
<li>Leptos components are templates that can be added to a web page's document object model DOM as nodes, with separate text nodes for dynamic data used in text strings.</li>
<li>Leptos components can have fuctions run in response to events on a given component.</li>
<li><code>wasm-bindgen</code> and other supporting crates work as bridges between our Rust code and the browser's JavaScript runtime.</li>
</ul>
<h2 id="what-well-learn-7"><a class="header" href="#what-well-learn-7">What we'll learn</a></h2>
<ul>
<li>Updating the DOM in response to events.</li>
</ul>
<h2 id="the-lesson-5"><a class="header" href="#the-lesson-5">The Lesson</a></h2>
<p>In our previous example we created a silly Leptos component that displays some text and has a button that, when clicked, echoes a number to the console.</p>
<p>We'll take this example and and instead of echoing 42 the console, we'll replace the lucky number with it.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;LuckyNumberCounter the_lucky_number=12 /&gt;  
        }  
    })  
}

#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number: i32) -&gt; Element {
	let whisper_in_the_console = |_|{  
	    web_sys::console::log_1(&amp;42.into());
	};  
	view!{  
	    cx,  
	    &lt;div&gt;  
	        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
	        &lt;button on:click=whisper_in_the_console &gt;
		        &quot;Your Secret Lucky Number&quot;
			&lt;/button&gt;  
	    &lt;/div&gt;  
	}
}</code></pre></pre>
<p>First, let's adjust the names of some of the event callback and put a placeholder into the event handler (or callback) body.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number: i32) -&gt; Element {
	let update_the_number = |_|{  
	    // This functionality is unknown.
	};  
	view!{  
	    cx,  
	    &lt;div&gt;  
	        &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
	        &lt;button on:click=update_the_number &gt;
		        &quot;I need a more lucky number&quot;
			&lt;/button&gt;  
	    &lt;/div&gt;  
	}
}
<span class="boring">}</span></code></pre></pre>
<p>We know from previous lessons that Leptos component templates are setup statically when Leptos starts up. Given that this is the case we may ask ourselves, how can we have dynamic content if the template is static? </p>
<p>The secret to solving this problem involves combining two features of Leptos, one which we've seen before and one which is new.</p>
<ol>
<li>How Leptos separates static and dynamic content</li>
<li>Signals which can be converted into data</li>
</ol>
<h3 id="1-separation-of-static-and-dynamic-template-components"><a class="header" href="#1-separation-of-static-and-dynamic-template-components">1) Separation of static and dynamic template components</a></h3>
<p>We saw from the previous example that Leptos differentiates parts of our template from components that are variable. By doing this, it can zip together data that changes with the static template that does not change.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;p&gt;
	&quot;Today's lucky number is &quot; {the_lucky_number}
&lt;/p&gt;  
<span class="boring">}</span></code></pre></pre>
<p>The above could be interpreted as follows:</p>
<pre><code>[STATIC DATA] {DYNAMIC DATA} [STATC DATA]
</code></pre>
<pre><code>[&lt;p&gt;&quot;Today's lucky number is &quot;]  {the_lucky_number} [&lt;/p&gt;]
</code></pre>
<p>By doing this Leptos can reuse the template while leaving a holes, like fields in a form, for variable data.</p>
<h3 id="2-signals"><a class="header" href="#2-signals">2) Signals</a></h3>
<p>The problem with our Leptos component is that <code>the_lucky_number</code> is a variable who's value is defined outside of its component template. It's value is provided when the whole system starts up and the component is mounted to the body as shown in the &quot;<code>fn main()</code>&quot; main function.</p>
<p>Unfortunately our variable <code>the_lucky_number</code> doesn't have an opportunity to be updated or changed. It's been used in our template and it has been consumed. Rust has some very intereting rules about data. </p>
<h4 id="the-idea-of-movement-and-scope"><a class="header" href="#the-idea-of-movement-and-scope">The idea of movement and scope</a></h4>
<p>In a lot of programming languages, you can pass data into a function and then also use it elsewhere. In Rust if you pass data into a function it's considered to have been moved into the function. It has left the scope, or the space, which you were operating.</p>
<p>For example, consider a time where I gave my friend a sandwich and asked them to paint a picture of it for me—it was a beautiful sandwich. If I gave the sandwich to my friend, I no longer have it. It's been <em>moved</em> into their hands. They may give it back to me, but until then, I won't have it. If you're working in Rust and see statements like, &quot;such and such has moved,&quot; this is what that means.</p>
<p>If Rust can make a copy of the data, it'll do so to get around the issue of moved values, but that only happens with simple data types like numbers. There are exceptions and a lot to explain with what is called the copy trait, but we won't get into that here. The idea of 'copy' is important to how Leptos allows dynamic content though.</p>
<h3 id="knowing-what-we-are-actually-moving"><a class="header" href="#knowing-what-we-are-actually-moving">Knowing what we are actually moving</a></h3>
<p>Let's go back to this sandwich example. Perhaps I don't want to relinquish my sandwich. I could provide a reference to it and my friend could look at it to make the painting. Though, they wouldn't be allowed to touch it. They are only allowed to look at it. In this case, I'm not losing my sandwich, but Rust will prevent me from changing it while someone is referencing it. Rust won't allow me to take a bit of my sandwich while I told my friend they could look at it to make the painting. Independent of how hungry I am. I could actually set up a plinth, place my sandwich on top, and allow a whole class of artisans to paint my sandwich. </p>
<p>Rust also allows me to loan out my sandwich by providing a mutable reference, but if I do that, I can't touch it, and no one else is allowed to reference it. It would be as if I told my friend, &quot;You can paint my sandwich and organize the lettuice and tomato so that it makes a nice composition.&quot; No one could safely paint that sandwich because my friend might still be moving parts of it around.</p>
<p>References in rust are achieved by adding an ampersand before a value. <code>42</code> is a number. <code>&amp;42</code> is a reference to that number. We can dereference or follow the reference to the original by placing an asterisk before a variable containing a reference. We'll expand on this later and explain how you references, and when to use them.</p>
<p>To summarize, the rules are:</p>
<ul>
<li>We can move an owned value (the sandwich)</li>
<li>We can create and move one or more references to the sandwich</li>
<li>We can create one single mutable reference, but we can not also have regular references if we do</li>
</ul>
<h3 id="the-borrow-checker"><a class="header" href="#the-borrow-checker">The borrow checker</a></h3>
<p>The above two concepts are key parts of what we call the Rust borrow checker. The purpose of the borrow checker is to make sure that our system (application) has predictable access to data. To do this, it tracks where we move things and how we reference them, to guarantee that we haven't inadvertantly written something stupid that will break our program or create secrity vulnerabilities. And trust me, we will write things like that. The borrow checker is your friend and asks you to do your best work. You will learn to appreciate how amazing it is in time.</p>
<p>Now that we know this, we can see how what felt like a simple problem to solve is actually pretty complicated. If we move a value into a component, it's gone. We can't update a value that doesn't exist as a result of some event. It might take some time to wrap your mind around this idea. It'll feel uncomfortable at first.</p>
<h3 id="leptos-solution"><a class="header" href="#leptos-solution">Leptos' solution</a></h3>
<p>What we really need is some sort of special variable. We need something that we can put in the template which can be notified when its value changes, and something that can transparently act as its value. </p>
<p>Imagine if we had a wearhouse of data who we could call and ask for data. &quot;Hey, I need the value of Aisle 2 bin 4.&quot; If we had the location of the data, we could always ask the wearhouse for whatever is stored there.</p>
<p>Or what if we could ask them to store something and they'd do so, responding with its location in the wearhouse. &quot;Can you store this gigantic novelty taco beanbag chair for me?&quot; we'd ask. &quot;Sure, and it's in aisle 2 bin 5,&quot; they'd respond. </p>
<p>This is what signals do. Signals are a formalized way of being able to communicate with the wearhouse (which in the context/scope in Leptos) to store data and retrieve data. When data changes, leptos can follow where it is being used, and update those usages accordingly. </p>
<p>I introduced the idea of copy earlier because the signals are actually indexes, storage positions in the context, which will be duplicated as you use them. This allows you to move a signal into a closure which will be handling an event while still using it in the view template. </p>
<h3 id="reactivity-in-action"><a class="header" href="#reactivity-in-action">Reactivity in action</a></h3>
<p>To create a signal, we need to call the function <code>create_signal()</code> and provide a scope (or context) as the first argument, and the default value as the second. It returns a tuple, a set of two values, which we can immediately give names to so that we can use them in the scope of our function.
The first part of the signal allows us to retrieve a copy of the value from the wearhouse. The second part of the signal allows us to set the value at the signal's location.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (value, set_value) = create_signal(cx, the_lucky_number);  
<span class="boring">}</span></code></pre></pre>
<p>The above is called destructuring. We could also have written in the long form way but it is actually harder to read and requires additional temporary assignments like <code>lucky_number_signal</code>. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let lucky_number_signal = create_signal(cx, the_lucky_number);  
let value = lucky_number_signal.0;
let set_value = lucky_number_signal.1;
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Note that <code>.0</code> and <code>.1</code> are properties on the <code>lucky_number_signal</code>. They're indexes for the first and second component in the tuple.</p>
</blockquote>
<p>Now that we have a signal we can update our callback and move the set_value signal into it. Not the addition of the move keyword before the closure's pipes which encapsulate it's properties, and the underscore which denotes that it will be provided a property when called, but we won't be using it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let update_the_lucky_number = move|_|{  
        set_value(42);  
    };  
<span class="boring">}</span></code></pre></pre>
<p>And in the view template we can update our previous value with our signal which can be used to derive the value.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;LuckyNumber the_lucky_number=12 /&gt;  
        }  
    })  
}  
  
#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number: i32) -&gt; Element {  
    let (value, set_value) = create_signal(cx, the_lucky_number);  
  
    let update_the_lucky_number = move|_|{  
        set_value(42);  
    };  
    view!{  
        cx,  
        &lt;div&gt;  
            &lt;p&gt;&quot;Today's lucky number is &quot; {value}&lt;/p&gt;  
            &lt;button on:click=update_the_lucky_number &gt;&quot;Pick a better number&quot;&lt;/button&gt;  
        &lt;/div&gt;  
    }  
}</code></pre></pre>
<p>The coolest part about this is that the signal is responsible for updating itself on the web page if it's value changes. LuckyNumber doesn't run again to create a new template. Leptos updates that special little text node, where <code>{value}</code> is used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="event-bubbling-and-signal-generics"><a class="header" href="#event-bubbling-and-signal-generics">Event Bubbling and Signal Generics</a></h1>
<h2 id="what-we-know-8"><a class="header" href="#what-we-know-8">What we know</a></h2>
<ul>
<li>We can monitor activity in the browser by responding to events</li>
<li>We can add functions that run when events happen to Leptos components. These functions are called event handlers. Event handlers added to Leptos components are also added to their DOM node counterparts and connected behind the scenes with Leptos' use of <code>wasm_bindgen</code> making their use transparent.</li>
<li>The syntax for an event handler is similar to adding a property to a component, but with a prefix of <code>on:</code> followed by the event name. e.g. <code>&lt;LeptosComponent on:click=my_event_handler /&gt;</code>.</li>
<li>Event handlers (event callbacks) are closures (a one time function that encapsulates the values used in it) that are assigned to a variable. e.g. <code>let my_event_handler = |event|{ ... }</code>.</li>
<li>the <code>move</code> keyword that can preceed a closure's parameters, indicating that variables used in the closure's function body will be moved into the closure itself and removed from the current scope as if they were passed into a function. Variables that are types that support the Copy trait will automatically be copied and will still be available in the current scope. </li>
<li>Signal read and write components support Copy.</li>
</ul>
<h2 id="what-well-learn-8"><a class="header" href="#what-well-learn-8">What we'll learn</a></h2>
<ul>
<li>How events can be captured in parent components</li>
<li>What generics are in Rust's type system at an introductory level</li>
</ul>
<h2 id="the-lesson-6"><a class="header" href="#the-lesson-6">The Lesson</a></h2>
<blockquote>
<p>Caveat: The following lesson is intended to show you an overview of a pattern to respond to events which are emmitted by a component's children. This is not a complete patter. A description of the tricky spots exists at the end of this lesson. </p>
</blockquote>
<p>We've established that the document object model (DOM) is a tree like representation of DOM nodes which is a browsers data structure containing information about what's on a web page. When events happen in a browser, the event will triggered at the lowest, most specific, DOM node. That event will bubble up until it's handled or prevented from continuing. Bubbling up means that the original event will be given the opportunity to handled by the originating element's parents, one at a time, until it reaches the top of the DOM tree.</p>
<p>If we take the following HTML:</p>
<pre><code class="language-html">&lt;html&gt;
	&lt;body&gt;
		&lt;div id=&quot;application&quot;&gt;
			&lt;div class=&quot;button-container&quot;&gt;
				&lt;button&gt;Click me&lt;/button&gt;
			&lt;/div&gt;
		&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Clicking on the click me button would create the intial event. <code>on:click</code> events handlers on this element will run first. Then, <code>on:click</code> handlers for the &quot;.button-container&quot; would run, and so forth.</p>
<p>This means that you can place handler logic on a parent component that has multiple children who emit events. For example, you could use this way of thinking to run a validation script on a form any time any input field is changed. Or, imagine if you wanted to capture any click as some form of analytics. You could setup a click handler in your main app which will capture all events that bubble up to it.</p>
<h3 id="using-bubbled-events-to-update-leptos-component-properties"><a class="header" href="#using-bubbled-events-to-update-leptos-component-properties">Using bubbled events to update Leptos component properties</a></h3>
<p>The following is an example of how we can move the lucky number value's handler out of the component and into a new Leptos component we're calling <code>RadApp</code>.</p>
<p>To start, we'll create a new component called <code>RadApp</code>, add it to the mount_to_body <code>view!</code>, and setup our <code>LuckyNumber</code> component as a child.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;RadApp /&gt;  
        }  
    })  
}  
  
#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;LuckyNumber the_lucky_number=12 /&gt;  
    }  
}  
  
#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number: i32) -&gt; Element {  
    view!{  
        cx,  
        &lt;div&gt;  
            &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
            &lt;button&gt;&quot;Pick a better number&quot;&lt;/button&gt;  
        &lt;/div&gt;  
    }  
}</code></pre></pre>
<p><code>LuckyNumber</code> has a button that we want to activate. That event will bubble up so we can put the on click handler on the Leptos component instead of on the button, like we did previously.</p>
<p>Let's add the <code>on:click</code> and we'll use the leptos log macro to write a message to the browser console.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
	let update_the_lucky_number = |_|{  
	  leptos::log!(&quot;We should be updating the lucky number&quot;);  
	};
	  
    view!{  
        cx,  
        &lt;LuckyNumber on:click=update_the_lucky_number the_lucky_number=12 /&gt;  
    }  
}  
<span class="boring">}</span></code></pre></pre>
<p>Rust's compiler may complain saying <code> cannot find type MouseEvent in this scope</code> followed by <code>consider importing this struct</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::web_sys::MouseEvent;
<span class="boring">}</span></code></pre></pre>
<p>You can literally copy and paste this into your main.rs file right after <code>use leptos::*</code>.</p>
<p>Now we need to create our signal so that we can read and update the data over time. We need to register it in our scope.
`</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
	let (value, set_value) = create_signal(cx, 12);
	let update_the_lucky_number = |_|{  
	  leptos::log!(&quot;We should be updating the lucky number&quot;);  
	};
	  
    view!{  
        cx,  
        &lt;LuckyNumber on:click=update_the_lucky_number the_lucky_number=12 /&gt;  
    }  
}  
<span class="boring">}</span></code></pre></pre>
<p>We might intuitively think, &quot;Hey, we can just put value where the number 12 previously was as a property of <code>LuckyNumber</code>,&quot; like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> &lt;LuckyNumber on:click=update_the_lucky_number the_lucky_number=value /&gt;  
<span class="boring">}</span></code></pre></pre>
<p>But this won't work. There's a problem. Value is a <code>ReadSignal</code>, and our property is supposed to be a 32 bit integer. We can see this in the function definition of the <code>LuckyNumber</code> component.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn LuckyNumber(cx: Scope, the_lucky_number: i32) -&gt; Element {
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><code>the_lucky_number</code> is supposed to be any 32 bit integer, denoted by <code>i32</code>.</p>
</blockquote>
<p>Rust's compiler will actually give you an error showcasing what was expected and what it received:</p>
<pre><code> note: expected type `i32`
       found struct `ReadSignal&lt;{integer}&gt;`

</code></pre>
<blockquote>
<p>All of these errors will appear in the terminal that you typed <code>trunk serve</code> in.</p>
</blockquote>
<p>The type ReadSignal&lt;{integer}&gt; probably looks a little bit weird to you. You might ask yourself, why is there a bunch of stuff after the type's name? What does <code>&lt;{integer}&gt;</code> mean?</p>
<p>Recall that functions have parameters which follow the function the function name and are encapsulated by parenthesis.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// this is pseudo code to show you the structure of the signature
fn function_name(parameter_name: SomeType)
<span class="boring">}</span></code></pre></pre>
<p>Types have parameters called generics which follow the type name and are encapsulated by angle brackets.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>SomeType&lt;SomeGenericType&gt;
<span class="boring">}</span></code></pre></pre>
<p>Generics allow us to configure a type with additional types. </p>
<p>For example, let's say that we have a bunch of containers and we're preparing our lunch for the day. We can store things in all of the containers and we can eat the contents from each container. All of the containers, though different sizes and colours, share the same type. They're containers. But some containers may contain liquids and others will contain solids.
If we were to eat or drink from one of the containers we could use the type system to guarantee that we wouldn't try to drink our sandwich or chew our milk by using parameter types like, <code>Container&lt;Solid&gt;</code> and <code>Container&lt;Liquid&gt;</code> respectively. </p>
<p>If we pop back over to Leptos, we can see how the context (scope) is similar. If we think about our wearhouse that we use to store and retrieve value from, we need some way to embed what type of values those are. </p>
<p>If we create_signal with an integer like an i32, we're saying that the ReadSignal is actually <code>ReadSignal&lt;i32&gt;</code>. This tells rust, &quot;Hey, this ReadSignal works like any other read signal, but when you get the contents out of it, it'll absolutely be a valid i32&quot;.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number: ReadSignal&lt;i32&gt;) -&gt; Element {  
    view!{  
        cx,  
        &lt;div&gt;  
            &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
            &lt;button&gt;&quot;Pick a better number&quot;&lt;/button&gt;  
        &lt;/div&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>We need to update our RadApp component to pass the signal to the component as well. Our whole working example looks like this.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
use web_sys::MouseEvent;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;RadApp /&gt;  
        }  
    })  
}  
  
#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
    let (value, set_value) = create_signal(cx, 12);  
    let update_the_lucky_number = move|_|{  
      set_value(42)  
    };  
    view!{  
        cx,  
        &lt;LuckyNumber on:click=update_the_lucky_number the_lucky_number=value /&gt;  
    }  
}  
  
#[component]  
fn LuckyNumber(cx: Scope, the_lucky_number: ReadSignal&lt;i32&gt;) -&gt; Element {  
    view!{  
        cx,  
        &lt;div&gt;  
            &lt;p&gt;&quot;Today's lucky number is &quot; {the_lucky_number}&lt;/p&gt;  
            &lt;button&gt;&quot;Pick a better number&quot;&lt;/button&gt;  
        &lt;/div&gt;  
    }  
}</code></pre></pre>
<h3 id="an-important-caveat-when-capturing-child-node-events"><a class="header" href="#an-important-caveat-when-capturing-child-node-events">An important caveat when capturing child node events</a></h3>
<p>One very important thing to note here is that ANY click events within the <code>&lt;LuckyNumber /&gt;</code> component will trigger the <code>on:click</code> event handler. </p>
<p>When we placed the event handler on the button itself, it was locked to that button. </p>
<p>When we place the hander on the parent, all clicks bubble up to it.</p>
<p>The distinction is important because while clicking on the button if there is one button yields the same behaviour, there are some subtle differences you shuold be aware of.</p>
<ol>
<li>Clicking anywhere will trigger the <code>on:click</code> handler</li>
<li>The event handler does not differentiate between buttons if one or more existed.</li>
</ol>
<p>The above example and lesson is not suitable in most cases but it a good simple example of capturing an event outside of its source. We will go into detail about how to filter the child events, prevent further bubbling, and so forth in later lessons.</p>
<h3 id="event-delegation-and-bubbling"><a class="header" href="#event-delegation-and-bubbling">Event delegation and bubbling</a></h3>
<p>Adding event listeners to DOM nodes has non trivial overhead. Leptos solves this problem with a clever optimization. It registers one top level handler for each event type and attaches this event handler to the Window DOM node. </p>
<p>Event handlers that we register in Leptos get added to a list of handlers for that event type. When an event fires in the browser, it bubbles up to the Window and is handled by the top level handler (created by Leptos as part of the aforementioned optimization). Events include a path component which Leptos can use to walk the DOM tree and fake bubble the event through its ancestors (the parts of its path). </p>
<p>Custom events created through web_sys do not bubble by default and will not be able to reach the Window from it's origin. For this reason, you need to ensure that custom events bubble so that they reach the Window and Leptos can handle them, delegating to the hander that you wrote.</p>
<blockquote>
<p><strong>From the author of Leptos:</strong> Leptos uses event delegation to make the creation of DOM nodes faster. This means that rather than attaching event listeners to individual HTML elements, the framework adds a single event listener to the page per event type (like <code>click</code> or <code>change</code>), and calls the handlers you define by looking them up manually. This adds a small increase in Wasm binary size in exchange for faster rendering times.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-events"><a class="header" href="#custom-events">Custom Events</a></h1>
<h2 id="what-we-know-9"><a class="header" href="#what-we-know-9">What we know</a></h2>
<ul>
<li>One of the key ways applications change data over time is in response to stimulus. We can witness these changes through a browser's runtime through the browser's event system.</li>
</ul>
<h2 id="what-well-learn-9"><a class="header" href="#what-well-learn-9">What we'll learn</a></h2>
<ul>
<li>Which events exist and/or are supported</li>
<li>Create custom events</li>
<li>Tips on how to read Rust documentation</li>
<li>The dangers of complexity and trying to think about simplicity</li>
<li>An introduction to structs, data, instance methods, and static methods</li>
<li>An introduction to match statements</li>
<li>An introduction to Result types</li>
<li>An introduction to Option types</li>
<li>Creating DOM node references for Leptos components</li>
</ul>
<h2 id="the-lesson-7"><a class="header" href="#the-lesson-7">The Lesson</a></h2>
<p>There are some common events that you can probably intuitively guess. Going from pure intuition is only going to get you so far. </p>
<p>We frame the way we solve problems through the lense of the tools we have at hand. For this reason, it's a good idea to familiarize yourself with the HTML tags that exist and the web events that exist. The web platform has a ton of features that a lot of people don't know about because they stopped learning HTML at <code>&lt;div&gt;</code> and <code>&lt;p&gt;</code> tags.</p>
<p>The mozilla foundation has a wonderful website called MDN which contains invaluable reference to help expand your knowledge.</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML">HTML elements and reference</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Events#event_listing">List of web events</a></li>
</ul>
<p>The List of web events will provide everything you need to know to respond to actions on elements which you can attach to your Leptos components.</p>
<h3 id="custom-events-1"><a class="header" href="#custom-events-1">Custom Events</a></h3>
<p>You may wish to create your own custom events. Custom events can be useful when you want to differentiate a generic behaviour in the web, from a specific behaviour or event in your application. </p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn MyLunchbox(cx: Scope) -&gt; Element {  
    let consume_sandwich = |_|{  
      // do something in response to  
      // the sandwich being eaten.
    };  
    view!{  
        cx,  
        &lt;Sandwich on:eat=consume_sandwich/&gt;  
    }  
}

#[component]  
fn Sandwich(cx: Scope) -&gt; Element {  
    let trigger_eating_event = |_|{  
      // Code that triggers the custom event
      // which will bubble up to from the 
      // botton to it's parent
    };  
    view!{  
        cx,  
        &lt;button on:click=trigger_eating_event/&gt;
	        I'm a snack
        &lt;/button&gt; 
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>If we were to write this with standard events, we would need some more introspection and features of the platform start to leak up into higher levels of our application. This issue can be simplified as saying, knowledge of the application needs to span across the boundary of multiple components. More things to keep in your head makes programs harder to reason about, more difficult to extend/modify, and less clear to newcomers wishing to contribute to the application. Or, maybe you just came back from a vacation and forgot all about how sometihng worked. Ideally you shouldn't need to know how (which is imperative), being able to focus on what (which is declarative).</p>
<p>Ultimately we probably don't care if a click event triggered the sandwich to be eaten, or if it was a key press that triggered it. Maybe the button was focused and they hit the enter key. </p>
<p>This is my opinion but I would say that In some sense the custom event simplifies our application because we're handling the <em>what</em> of the event insted of the <em>how</em> (click, key press, etc). </p>
<p>In the following standard event example, MyLunchbox needs to be aware of which events might exist to bubbling up to it as clicks. The event handler needs to filter out the appropriate event, introspect the event (look inside of it), and then take the appropriate action. Imagine that our sandwich in our system has a special identifier. </p>
<p>We could should out, &quot;Eat #2&quot; which happens to be the sandwich, emitting an eat event with a payload (data assocaited with the event) that is the food's identifier in your lunchbox.</p>
<p>The standard event equivalent would, &quot;I'm doing a thing with my lunchbox stuff,&quot; requiring someone to then ask, &quot;Ok, so um... what are you doing? Are you trying to eat something? What are you trying to eat? Does it have an identifier? Can I get that identifier?&quot;</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn MyLunchbox(cx: Scope) -&gt; Element {  
    let maybe_consume_sandwich = |event|{  
      // Introspection may be required in more
      // complicated use cases to make sure the 
      // right event bubbled up to be handled
      // and that it has the correct data to be
      // able to follow through with the desired
      // application behaviour.
    };  
    view!{  
        cx,  
        &lt;Sandwich on:click=maybe_consume_sandwich/&gt;  
    }  
}

#[component]  
fn Sandwich(cx: Scope) -&gt; Element {  
    view!{  
        cx,  
        &lt;button on:click=trigger_eating_event/&gt;
	        I'm a snack
        &lt;/button&gt; 
    }  
}

<span class="boring">}</span></code></pre></pre>
<h4 id="caution-beware-complexity"><a class="header" href="#caution-beware-complexity">Caution: Beware complexity!</a></h4>
<p>It can be tempting to cut your application up into a ton of domain specific—specific to the problem you're solving with language appropriate to that problem—events, but that comes at a cost. You will lose some forms of flexibility as you add focus and specificity to your application. </p>
<p>In the standard event example, we do still have the ability to introspect the event when handling it in MyLunchbox. That might be really useful. If we needed some additional data with our custom event we'd need to go into the Sandwich component and include it.</p>
<p>And that's the thing with programming. It always depends.</p>
<p>I advocate for, favour simplicity and only cut things apart when they get too big to keep together. Some problems are inherently complicated because of the types of problems they are. Ideally you should be able to walk away from your program, come back, and understand what's happening. We can not rely on being in the flow state or &quot;zone&quot; as the required mode to understand what we wrote. I would say this is actually a liability. Besides, we should create applications that allow us to be interrupted by life without causing frustration. </p>
<h3 id="creating-a-custom-event"><a class="header" href="#creating-a-custom-event">Creating a custom event</a></h3>
<p>Creating a custom event normally happens in JavaScript, because it's part of the browser's runtime. The code looks like this:</p>
<pre><code class="language-javascript">
const event = new Event('build');

// Listen for the event.
elem.addEventListener('build', (e) =&gt; { /* … */ }, false);

// Dispatch the event.
elem.dispatchEvent(event);

</code></pre>
<blockquote>
<p>https://developer.mozilla.org/en-US/docs/Web/Events/Creating_and_triggering_events</p>
</blockquote>
<p>We need to do something similar in our Rust code. To do this we'll use the web_sys crate.</p>
<p>There is a struct in <code>web_sys</code> called <code>CustomEvent</code> <a href="https://docs.rs/web-sys/latest/web_sys/struct.CustomEvent.html#method.new">Docs</a></p>
<p>Let's go over some struct basics since we're going to e using them for this lesson and going forward.</p>
<h4 id="introduction-to-structs"><a class="header" href="#introduction-to-structs">Introduction to Structs</a></h4>
<p>A struct is like a class in a lot of object oriented languages. It is a category of <code>type</code> that has the ability to group data, functionality related to that data, and functionality related to its general idea, all around a single name. Recall that a <code>type</code> is the name that describes a set of possible values.</p>
<h5 id="struct-data"><a class="header" href="#struct-data">Struct data</a></h5>
<p>One of the key features of structs in Rust is that they specify a grouping of data types and values which we call properties. I suspect this is why they're called structs—structured data or data structure. If we had a Bacon Lettuce and Tomato sandwich struct it's definition would look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct BLTSandwich {
	bread: TypeOfBread,
	lettuce: TypeOfLettuce,
	tomato: TypeOfTomato,
	bacon: TypeOfBacon,
	mayo: bool
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>The above example expects that TypeOfBread, TypeOfLettuce, TypeOfTomato, and TypeOfBacon are all defined earlier. They are used here to illustrate that BLTSandwich has constrained which values it's specific proeprties can have. You can not have a BLTSandwich with rocks as a value for bacon, because rocks are not a type of bacon! This is why type systems are important. They help prevent us from eating rocks... or... making mistakes in our programs. :)</p>
</blockquote>
<p>If you have keen eyes you'll recognize something here. There's a pattern that we've seen a few times before.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// a function definition
fn function_name( parameter: type ) {}

// a struct definition
struct StructName{ property: type }
<span class="boring">}</span></code></pre></pre>
<p>This pattern can be abstracted to the following:</p>
<ul>
<li>Rust keyword to define context/subject (<code>fn</code>, <code>struct</code>)</li>
<li>A name to be able to use the noun(<code>function_name</code>, <code>StructName</code>)</li>
<li>Some form of encapsulation with configuration</li>
</ul>
<h5 id="make-a-new-thing-from-an-idea-a-concretion"><a class="header" href="#make-a-new-thing-from-an-idea-a-concretion">Make a new thing from an idea (a concretion)</a></h5>
<p>A struct or structure is like an idea. And ideas aren't real in a sense that we can't hold them. We have an idea of what a BLT Sandwich is, but we can't eat the idea. But we have written specification for what the BLT is in the definition of our struct.</p>
<p>If we were to take <strong>the idea of a  BLT sandwich</strong> and <em>make</em> <strong>A BLT sandwich</strong> we would say that we were making a concretion. A thing that is concrete or real. In object oriented programming (OOP) we would say that we are instantiating the idea (in oop ideas are classes). We are creating an instance of it. </p>
<p>The syntax to create a struct includes writing the stuct's name, followed by curly braces, and a list of the property names and their values. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Assuming that the values for these 
// properties were already defined in scope
// with statements like
// let canadian_rye = get_the_best_sandwich_bread();
BLTSandwich{  
	bread: canadian_rye,
	lettuce: romaine,
	tomato: black_krim,
	bacon: farm_smoked_apple_bacon,
}
<span class="boring">}</span></code></pre></pre>
<p>Most library (crate) authors write functions associated with a struct (with the idea of it) to make a concretion. It's convention for this function to be called 'new'. Calling the function follows this syntax:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	let my_thing = SomeStruct::new();
<span class="boring">}</span></code></pre></pre>
<h5 id="functionality-associated-with-the-idea-static-methods"><a class="header" href="#functionality-associated-with-the-idea-static-methods">Functionality associated with the idea (static methods)</a></h5>
<p>Structs can have functionality associated with the name of the struct. Some would described as functions that are namespaced, meaning that they are prefixed to or expected to be understood in the context of the name (being the struct's name).</p>
<p>The following showcases a <code>new</code> function in the <code>BLTSandwich</code> namespace which returns a new <code>BLTSandwich</code> (a concretion).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl BLTSandwich {
	pub fn new() -&gt; BLTSandwich {
		BLTSandwich{  
			bread: canadian_rye,
			lettuce: romaine,
			tomato: black_krim,
			bacon: farm_smoked_apple_bacon
		}
	}
	pub fn name() -&gt; String {
		&quot;Bacon, Lettuce and Tomato Sandwich&quot;.to_string()
	}
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Normally there would be parameters in the new function to accept arguments to configure the new thing being created. I skipped on that for the sake of simplicity. </p>
</blockquote>
<p>We can see here that we also have a name function which returns a long form name of the sandwich as a string.</p>
<p>We could call this by writing:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let the_sandwich_name : String = BLTSandwich::name();
<span class="boring">}</span></code></pre></pre>
<p>Again, we can see that these are functions associated with the idea and separated by two colons. </p>
<p>But again, look closely! A pattern emerges! We previously used a function called <code>leptos::log!</code>. But leptos isn't a struct, it's a crate! </p>
<p>Rust uses the same pattern of double colons to say, &quot;We're setting the context to qualify which thing we're talking about&quot;. When we say BLTSandwich::name, we're telling Rust &quot;Ok, think about BLTSandwich things... when I say name, you know what I'm talking about.&quot;</p>
<p>The Rust language designers have done a superb job at making these things easy to remember <em>if</em> you're aware that there is a pattern and design behind the decision. I can only assume that these design decisions were very deliberate.</p>
<h5 id="functionality-associated-with-the-a-concretion-methods"><a class="header" href="#functionality-associated-with-the-a-concretion-methods">Functionality associated with the a concretion (methods)</a></h5>
<p>We can associate functionality with a specific concretion (a struct made real) which we often call methods. </p>
<p>If we had a mthod called <code>calories</code> we could call with the following Rust code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sandwich = BLTSandwich::new();
let calories = sandwich.calories();
<span class="boring">}</span></code></pre></pre>
<p>Here we make a sandwich and call calories on it.</p>
<p>The context here is so tightly coupled that we use a single dot as a separator. I like to think of it as this.</p>
<ol>
<li>4 dots — A namespace is a grouping of many things, so we use many dots.</li>
<li>1 dot — A value is a single thing, so we use one dot.</li>
</ol>
<p>The neat thing about the above is that if you didn't need to use sandwich you can chain these all together:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let calories = BLTSandwich::new().total_calories();
			   ^----------------^
				This will evaluate into a 'sandwich'
				which we can call total_calories() on.
<span class="boring">}</span></code></pre></pre>
<p>Methods always have a special &amp;self parameter as the first argument to denote that they're able to make reference to itself. This is how a function has the ability to do anything with it's own data. Recall that we can not use a piece of data unless it is in scope.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>// Imagine that there is some function called calories, 
// which accepts things that can be turned into a calories
// value which is a 32 bit integer. Don't worry about how this
// would work. This is just a simple example.

impl BLTSandwich {
	// imagine the other static methods or namespace 
	// function from before were still here.

	pub fn total_calories(&amp;self) -&gt; i32 {
		calories(self.bread) + 
		calories(self.lettuce) + 
		calories(self.tomato) + 
		calories(self.bacon)
		// Recall that this function will evaluate to the 
		// last statement in its body. That's why there's no
		// semicolon at the end of this last item.
	}
	pub fn name() -&gt; String {
		&quot;Bacon, Lettuce and Tomato Sandwich&quot;.to_string()
	}
}
<span class="boring">}</span></code></pre></pre>
<p>Note that we're able to use the value of the struct's properties with <code>.bread</code>.
If we look at the function <code>total_calories</code> it starts to look really similar to <code>.bread</code>. with the exception of us adding parenthesis at the end to call the fucntion. Yet another pattern emerges, methods on a value are properties on the value that you can call!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sandwich = BLTSandwich::new();
sandwich.bread;
sandwich.total_calories; //&lt;- but then we add () to call it
<span class="boring">}</span></code></pre></pre>
<h4 id="using-web_syscustomevent"><a class="header" href="#using-web_syscustomevent">Using web_sys::CustomEvent</a></h4>
<p>We're well positioned to use the web_sys crate's CustomEvent struct.</p>
<p>If we zip over to the documentation we can see that there is a new method on the struct <a href="https://docs.rs/web-sys/latest/web_sys/struct.CustomEvent.html#">Docs</a>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>web_sys::CustomEvent::new(&quot;my-custom-event&quot;);
<span class="boring">}</span></code></pre></pre>
<p>But there's a notice under the definition of the <code>new</code> method that states the following: </p>
<blockquote>
<p><em>This API requires the following crate features to be activated: <code>CustomEvent</code></em></p>
</blockquote>
<p>I did a quick search for &quot;web_sys enable feature&quot; which lead me to this support doc <a href="https://rustwasm.github.io/wasm-bindgen/web-sys/using-web-sys.html#enable-the-cargo-features-for-the-apis-youre-using">Enable the cargo features for the APIs you're using</a>.</p>
<p>Leptos includes these web_sys features for you as part of its library.</p>
<p>If we go back to the <code>new</code> method's definition in the web_sys::CustomEvent docs we'll see the following definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new(type_: &amp;str) -&gt; Result&lt;CustomEvent, JsValue&gt;
<span class="boring">}</span></code></pre></pre>
<p>Notice that it returns <code>after the -&gt;</code> a Result type, which has some type arguments (generics). The first one refers to what we get if new is run and the result is Ok, the second is the result that we get if new runs and the result is an Error. We can handle these with some in build pattern matching which we'll go into more later.</p>
<p>Our component code now looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn MyComponent(cx: Scope) -&gt; Element {  
    let trigger_sending_of_custom_event = |_|{  
        match web_sys::CustomEvent::new(&quot;my-custom-event&quot;) {  
            Ok(event) =&gt; {  
                // We have an event that we can send  
            },  
            Err(_) =&gt; {  
                // There as an error in creating the event  
                // We're not doing anything with this for now
				// so we'll use an '_' to destructure it's error
				// message            
			}  
        }  
    };  
    view!{  
        cx,  
        &lt;div&gt;  
            &lt;button on:click=trigger_sending_of_custom_event&gt;  
                &quot;Trigger custom event&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>match</code> keyword requires that we create branches/arms for each possible option. Recall that we talked about types as restrictions that describe possible values. A result is an enumeration (a list of possible values or strict set of options) which can be one of two values. It can be Ok or Err. The options are called variants. </p>
<p>In both of those cases there is a value that we can destructure out of the variants. Their types are listed as the the first and second type arguments in the returned type's signature. <code>Result&lt;CustomEvent, JsValue&gt;</code> means that we'll have an <code>Ok( CustomEvent )</code> or an <code>Err(JsValue)</code>.</p>
<p>I know from the JavaScript custom event documentation that it's not enough to create the event. We need to emit it. This is called <code>dispatching</code>. The javascript looks like this.</p>
<pre><code class="language-javascript">elem.dispatchEvent(event);
</code></pre>
<p>What we need is some way to refer to our <code>&lt;MyComponent /&gt;</code> so that we can dispatch the event on it. We need a reference to it.</p>
<h3 id="getting-a-reference-to-self-as-a-dom-node-with-noderef"><a class="header" href="#getting-a-reference-to-self-as-a-dom-node-with-noderef">Getting a reference to self as a DOM node with NodeRef</a></h3>
<p>Leptos provides us with the ability to get a reference to the DOM node created by its <code>view!</code> template. Think of it like a direct line to its DOM counterpoint.</p>
<p>The first step is to create the nodeRef, and add it as a special <code>_ref</code> property to the parent/root element in the <code>view!</code> template. Recall that the Leptos component is proxy for the <code>view!</code> template's root element. Putting the reference on this div is the same as putting the reference on <code>&lt;MyComponent /&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn MyComponent(cx: Scope) -&gt; Element {  
    let dom_node_ref = NodeRef::new(cx);
    // abbreviated/folded Rust code here for space saving
    view!{  
	    cx,  
	    &lt;div _ref=dom_node_ref&gt;  
	        &lt;button on:click=trigger_sending_of_custom_event&gt;  
	            &quot;Trigger custom event&quot;  
	        &lt;/button&gt;  
	    &lt;/div&gt;  
	}
}
<span class="boring">}</span></code></pre></pre>
<p>The dom_node_ref uses signals under the hood so we can move it into our handler closure without stressing about move semantics. We'll add the move keyword to the closure  and we'll add some more matching if we are able to make our custom event.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match dom_node_ref.get() {  
	None =&gt; {  
		// None will only happen if this component isn't  
		// mounted to the DOM, but it has to be in order                   
		// for the click event to fire, so we can ignore this                    
	}  
	Some(dom_element) =&gt; {  
		// Emit/dispatch our custom event  
	}  
}  
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>We call 'get' on the dom_node_ref to get the actual DOM element in Rust form. There are cases when the DOM element/node might not exist. Rust requires us to account for all possibilities, which is why the get method returns a option type. It's return type definition is <code>Option&lt;web_sys::Element&gt;</code>. Option is an enum which can be <code>None</code> or <code>Some</code> with the type argument provided in it's signature. In this case it's of the <code>web_sys::Element</code> type. We're destructing it and giving it the label <code>dom_element</code></p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn MyComponent(cx: Scope) -&gt; Element {  
    let dom_node_ref = NodeRef::new(cx);  
  
    let trigger_sending_of_custom_event = move |_|{  
        match web_sys::CustomEvent::new(&quot;my-custom-event&quot;) {  
            Ok(event) =&gt; {  
                match dom_node_ref.get() {  
                    None =&gt; {  
                        // None will only happen if this component isn't  
		                // mounted to the DOM, but it has to be in order                   
			            // for the click event to fire, so we can ignore this                    
		            }  
                    Some(dom_element) =&gt; {  
                        // Emit/dispatch our custom event  
                    }  
                }  
            },  
            Err(_) =&gt; {}  
        }  
    };  
    view!{  
        cx,  
        &lt;div _ref=dom_node_ref&gt;  
            &lt;button on:click=trigger_sending_of_custom_event&gt;  
                &quot;Trigger custom event&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>Intuitively, we'll probably want to try something like this for the actual event sending. This is a focused view of the happy path match arm:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match dom_node_ref.get() {  
    None =&gt; {}  
    Some(dom_element) =&gt; {  
        dom_element.dispatch_event(event);  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>Unfortuantely this doesn't work. Rust tells us that dispatch_event is expecting a <code>&amp;event</code>, a reference to an event. Let's add an ampersand before event to send a reference.</p>
<p>Rust's compiler may complain about unhandled results from the event dispatch. We can add another match statement to handle those.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match dom_element.dispatch_event(&amp;event) {  
    Ok(_) =&gt; { 
	    leptos::log!(&quot;Custom event sent&quot;) 
	},  
    Err(_) =&gt; { 
	    leptos::log!(&quot;Failed to send&quot;) 
	}  
}
<span class="boring">}</span></code></pre></pre>
<p>We can now listen to our custom event from our Leptos component:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
    let log_response = |_| {  
        leptos::log!(&quot;Our custom event happened&quot;)  
    };  
    view! {  
        cx,  
        &lt;MyComponent on:myCustomEvent=log_response/&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Note that event names are camelCased</p>
</blockquote>
<p>We're still not totally there yet though. We need to actually tell this new custom event to bubble.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>//We need to create a config that is mutable (so we add 'mut' after let)
let mut event_config = web_sys::CustomEventInit::new();  

// We set the bubble property to true
event_config.bubbles(true);  

// We create a new event with the special config using a different constructor method

let event = web_sys::CustomEvent::new_with_event_init_dict(
	&quot;myCustomEvent&quot;, 
	&amp;event_config
);

// was previous
// let event = web_sys::CustomEvent::new(&quot;myCustomEvent&quot;); 
<span class="boring">}</span></code></pre></pre>
<p>And just like that we have custom events on components with references! </p>
<h4 id="the-complete-code"><a class="header" href="#the-complete-code">The Complete Code</a></h4>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;RadApp /&gt;  
        }  
    })  
}  
  
#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
    let log_response = |_| {  
        leptos::log!(&quot;Our custom event happened&quot;)  
    };  
    view! {  
        cx,  
        &lt;MyComponent on:myCustomEvent=log_response /&gt;  
    }  
}  
  
#[component]  
fn MyComponent(cx: Scope) -&gt; Element {  
    let dom_node_ref = NodeRef::new(cx);  
  
    let trigger_sending_of_custom_event = move |_| {  
  
        let mut event_config = web_sys::CustomEventInit::new();  
        event_config.bubbles(true);  
        let event = web_sys::CustomEvent::new_with_event_init_dict(&quot;myCustomEvent&quot;, &amp;event_config);  
  
        match event {  
             Ok(event) =&gt; {  
                 match dom_node_ref.get() {  
                    None =&gt; {}  
                    Some(dom_element) =&gt; {  
                        match dom_element.dispatch_event(&amp;event) {  
                            Ok(_) =&gt; { leptos::log!(&quot;Custom event sent&quot;) },  
                            Err(_) =&gt; { leptos::log!(&quot;Failed to send&quot;) }  
                        }  
                    }  
                }  
            }  
            Err(_) =&gt; {}  
        }  
    };  
    view! {  
        cx,  
        &lt;div _ref=dom_node_ref&gt;  
            &lt;button on:click=trigger_sending_of_custom_event&gt;  
                &quot;Trigger custom event&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }  
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="forms"><a class="header" href="#forms">Forms</a></h1>
<h2 id="what-we-know-10"><a class="header" href="#what-we-know-10">What we know</a></h2>
<ul>
<li>We can capture events and respond to them</li>
<li>Signals allow us to persist data across events</li>
</ul>
<h2 id="what-well-learn-10"><a class="header" href="#what-well-learn-10">What we'll learn</a></h2>
<ul>
<li>How to respond to multipart form data</li>
</ul>
<h2 id="the-lesson-8"><a class="header" href="#the-lesson-8">The Lesson</a></h2>
<p>Back in the day we used to interact with websites by submitted form data to a server with a requested resource (like a specific page). The page would render, often using or processing the form data that was sent with it, would generate HTML, and then provide us a response. This is how the majority of the web still works to this day!</p>
<p>We're going to replicate a similar data flow so that you can collect sets of data using forms, but process them all on the client (in the browser).</p>
<p>We'll start with a Rad app component and some boiler plate, mounting it to the body:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;RadApp /&gt;  
        }  
    })  
}  
  
#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
    view! {  
        cx,  
        &lt;form&gt;  
        &lt;/form&gt;  
    }  
}</code></pre></pre>
<p>Our form has no submit button, so we'll add that in:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
    view! {  
        cx,  
        &lt;form&gt;  
	        &lt;input type=&quot;submit&quot; value=&quot;Submit&quot;/&gt;
        &lt;/form&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>We now have a basic form that we can submit. If we click submit, the form takes it data (of which there is none) and posts it to the form's action destination, which if non will default to the current page. This effectively looks like the page has reloaded even though it's actually being re-requesed with the updated form data.</p>
<p>Let's add a text field so that we can submit some data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;form&gt;  
	&lt;input type=&quot;text&quot;  
	    name=&quot;fav_thing_to_paint&quot;  
	    placeholder=&quot;Your fav thing to paint...&quot;  
	    value=&quot;&quot;  
	/&gt;
	&lt;input type=&quot;submit&quot; value=&quot;Submit&quot;/&gt;
&lt;/form&gt;  
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>I broke the lines up here purely for formatting. HTML elements don't care about line breaks inbetween attributes.</p>
</blockquote>
<p>If we type in something into the text field and hit submit, you'll see the page load, and the field gets reset. What is happening here is that the form is taking its form data and submitting it to the form's action url as part of a new request. The action property is a property on the form element telling the form where to send its data. It defaults to the current page that it's on if the action is not set.</p>
<p>If we had <code>&lt;form action=&quot;https://www.rust-lang.org&quot;&gt;</code> and we clicked submit, the form would send our data to rust-lang.org! And isntead of looking like a page reload, we'd see the rust-lang.org home page.</p>
<p>We always have to remember that here we're just making a more complicated request with some configuration (the form data) and our brower is rendering the response.</p>
<p>In old school website, a server would render a template and process form submissions for that template at the same time. If a request came in without form data, the fields would be blank. If a request came in that had posted data (submitted via the form submission), whoever coded the form template which is processed on the server could pluck out that posted data, and enter in the submitted values as the values of the input fields in the form. This way form submission data doesn't get erased if, for example, some form validation failed. The data just gets passed back and forth. It is not persisting anywhere.</p>
<blockquote>
<p>Fun Fact! Forms default to 'post' as their method of sending data. You can change this method to 'get' and your data will become query string variables.</p>
</blockquote>
<h3 id="responding-to-the-event"><a class="header" href="#responding-to-the-event">Responding to the event</a></h3>
<p>Let's add a from handler for the <code>submit</code> event. But this point, things should look pretty familiar.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
	
	// We create a form handler
    let form_handler = |_|{  
        leptos::log!(&quot;The form was submitted&quot;);  
    };  

	// And we added it with `on:submit` to the form element
    view! {  
        cx,  
        &lt;form on:submit=form_handler&gt;  
            &lt;input type=&quot;text&quot;  
                name=&quot;fav_thing_to_paint&quot;  
                placeholder=&quot;Your fav thing to paint...&quot;  
                value=&quot;&quot;  
            /&gt;  
            &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;  
        &lt;/form&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<h3 id="preventing-the-form-from-sending"><a class="header" href="#preventing-the-form-from-sending">Preventing the form from sending</a></h3>
<p>When we click submit, the form submits so quickly that we can't even see the <code>form_handler</code>'s message. Also, we're working on a client side application in this context, so we don't want this page to reload and rerender. We want to <em>prevent the default behaviour</em>.</p>
<p>To do this we need to actually do something with the event in our event handler that we've been ignoring this whole time. Let's change it from an underscore to something easy to understand, like <code>submission_event</code>. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	let form_handler = |submission_event|{  
        submission_event.prevent_default();
    };  
<span class="boring">}</span></code></pre></pre>
<p>The above won't work though, because the closure doesn't know where it will be used. Rust doesn't know that this closure will be called from the event system and that the first argument will be an event. To fix this problem we'll give it a type <code>web_sys::SubmitEvent</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	let form_handler = |submission_event: web_sys::SubmitEvent|{  
        submission_event.prevent_default();
    };  
<span class="boring">}</span></code></pre></pre>
<p>Calling prevent_default() on the submit event will prevent the form from actually being submitted. We've short circuited the default behaviour!</p>
<blockquote>
<p>Sometimes I find that I don't know exactly what to write for the type so I'll put in some form of type, try to compile the application, and then let Rust's compiler tell me what was supposed to be there. It's right most of the time.</p>
</blockquote>
<h3 id="capturing-form-data"><a class="header" href="#capturing-form-data">Capturing form data</a></h3>
<p>Events have the source stored at a proeprty called <code>target</code>. We can grab the element that emitted the event by calling it. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let form_handler = |submission_event: web_sys::SubmitEvent|{  
	submission_event.prevent_default();
	let form = submission_event.target();
};  
<span class="boring">}</span></code></pre></pre>
<p>We don't know for sure if the target will actually be a proper element. The return type of the <code>target</code> method is <code>Option&lt;EventTarget&gt;</code>. As we learned in the previous lessons, we can match on the form's value to account for Some(form) or None.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let form_handler = |submission_event: web_sys::SubmitEvent|{  
    submission_event.prevent_default();  
    match submission_event.target() {  
        None =&gt; {},  
        Some(form_event_target) =&gt; {  
            // we need to do things here
		}  
    }  
};
<span class="boring">}</span></code></pre></pre>
<p>form_event_target doesn't have a specific type yet, so we need to explicitly tell Rust, &quot;Hey, this is a HtmlFormElement&quot; which we need to derive a form data object. </p>
<blockquote>
<p>It should be noted that it took research to sort through this which is why I'm presenting it to you. This way you have one place to look it all up. :)</p>
</blockquote>
<p>We're going to add the following line once we've destructured our <code>form_event_target</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let form_element = form_event_target.unchecked_ref::&lt;web_sys::HtmlFormElement&gt;();  
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Here we take our target, which is untyped and called <code>unchecked_ref()</code> to type it. We add a turbofish <code>::&lt;SomeType&gt;</code> between the name of the method and the parenthesis to specify the generic type. In this case, it's the type that it will become when we call unchecked_ref on it.</p>
</blockquote>
<p>This will fail to work, and Rust's compiler wil complain. If we look at the definition of web_sys::HtmlFormElement we'll see that it needs to be set as a feature dependency in cargo.toml.</p>
<p>We'll add the following to our cargo.toml to ensure that websys uses the two features we'll need:</p>
<pre><code class="language-toml">[dependencies.web-sys]  
features = [ &quot;FormData&quot;, &quot;HtmlFormElement&quot;]
</code></pre>
<p>Next we'll setup form data which will use data from the form element. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let form_data = web_sys::FormData::new_with_form(&amp;form_element);
<span class="boring">}</span></code></pre></pre>
<p>This returns a result type, with its return type being <code>Result&lt;FormData, JsValue&gt;</code>. As we've sen before, we'll need to destructure it to pull out the value that is of type <code>FormData</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let form_data = web_sys::FormData::new_with_form(&amp;form_element);  
match form_data{  
    Err(_) =&gt; {},  
    Ok(data) =&gt;{  
        // the data here is a FormData thing.
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>FormData has some useful methods, one of which we can use to extract values from fields by name.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fav_thing = data.get(&quot;fav_thing_to_paint&quot;).as_string();
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Here we ask the form data to give us its value for &quot;fav_thing_to_paint&quot; as a string value. This is still an option, so we'll have to deal with <code>Some(the_value)</code> or <code>None</code>.</p>
</blockquote>
<p>I'm specifically showing you pattern matchin as the simplest way to deal with these result and option types. There are many shorter ways of doing that which you will learn later.</p>
<p>It is also possible to inline the match statement and avoid assigning the temporary variable. We could write the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let fav_thing = data.get(&quot;fav_thing_to_paint&quot;).as_string();  
match fav_thing {  
    Some(actual_fav_thing_value) =&gt; {},  
    None =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>or</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match data.get(&quot;fav_thing_to_paint&quot;).as_string() {  
    Some(fav_thing) =&gt; {},  
    None =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>The whole thing all together looks like this:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;RadApp /&gt;  
        }  
    })  
}  
  
#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
    let form_handler = |submission_event: web_sys::SubmitEvent|{  
        submission_event.prevent_default();  
        match submission_event.target() {  
            None =&gt; {},  
            Some(form_event_target) =&gt; {  
                let form_element = form_event_target.unchecked_ref::&lt;web_sys::HtmlFormElement&gt;();  
                let form_data = web_sys::FormData::new_with_form(&amp;form_element);  
                match form_data{  
                    Err(_) =&gt; {},  
                    Ok(data) =&gt;{  
                        match data.get(&quot;fav_thing_to_paint&quot;).as_string() {  
                            Some(fav_thing) =&gt; {  
                                leptos::log!(&quot;{:?}&quot;, fav_thing);  
                            },  
                            None =&gt; {}  
                        }  
                    }  
                }  
            }  
        }  
    };  
    view! {  
        cx,  
        &lt;form on:submit=form_handler&gt;  
            &lt;input type=&quot;text&quot;  
                name=&quot;fav_thing_to_paint&quot;  
                placeholder=&quot;Your fav thing to paint...&quot;  
                value=&quot;&quot;  
            /&gt;  
            &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;  
        &lt;/form&gt;  
    }  
}</code></pre></pre>
<h3 id="adding-signals"><a class="header" href="#adding-signals">Adding signals</a></h3>
<p>We can now create a signal and use it to store the posted/submitted data.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let (last_fav_thing, set_last_fav_thing) = create_signal(cx, String::new());
<span class="boring">}</span></code></pre></pre>
<p>We will add <code>move</code> to the handler, so that we can move the signal into it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let form_handler = move|submission_event: web_sys::SubmitEvent|{
<span class="boring">}</span></code></pre></pre>
<p>And we'll store the value using the signal:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>set_last_fav_thing(fav_thing);
<span class="boring">}</span></code></pre></pre>
<p>The last piece is displaying the last submission in our <code>view!</code> template:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&lt;p&gt;&quot;Your last fav thing was: &quot; {last_fav_thing}&lt;/p&gt;
<span class="boring">}</span></code></pre></pre>
<p>All togehter we have a nice example of how to collect form data so that we can work with it!</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;RadApp /&gt;  
        }  
    })  
}  
  
#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
  
    let (last_fav_thing, set_last_fav_thing) = create_signal(cx, String::new());  
  
    let form_handler = move|submission_event: web_sys::SubmitEvent|{  
        submission_event.prevent_default();  
        match submission_event.target() {  
            None =&gt; {},  
            Some(form_event_target) =&gt; {  
                let form_element = form_event_target.unchecked_ref::&lt;web_sys::HtmlFormElement&gt;();  
                let form_data = web_sys::FormData::new_with_form(&amp;form_element);  
                match form_data{  
                    Err(_) =&gt; {},  
                    Ok(data) =&gt;{  
                        match data.get(&quot;fav_thing_to_paint&quot;).as_string() {  
                            Some(fav_thing) =&gt; {  
                                set_last_fav_thing(fav_thing);  
                            },  
                            None =&gt; {}  
                        }  
                    }  
                }  
            }  
        }  
    };  
    view! {  
        cx,  
        &lt;form on:submit=form_handler&gt;  
            &lt;p&gt;&quot;Your last fav thing was: &quot; {last_fav_thing}&lt;/p&gt;  
            &lt;input type=&quot;text&quot;  
                name=&quot;fav_thing_to_paint&quot;  
                placeholder=&quot;Your fav thing to paint...&quot;  
                value=&quot;&quot;  
            /&gt;  
            &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;  
        &lt;/form&gt;  
    }  
}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
