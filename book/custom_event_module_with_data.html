<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Custom Event Module with Data - Building Apps with Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Preface</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Acknowledgements</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> About this Book</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> About the Author</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> If you get stuck or lose steam</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Introductions</li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Programming</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> What it is</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Why it's worth it</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Why it's hard</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> Programmer Thinking</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Languages</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> Meaning and Interpretation</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Architectures</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> How your computer works</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> How the web works</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.3.</strong> The frontend-backend divide</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Tools and Languages</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">9.1.</strong> Bash and the terminal</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.2.</strong> Rust</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.3.</strong> Trunk</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.4.</strong> Web browsers</div></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Rust and Leptos</li><li class="chapter-item expanded "><a href="setup_intro.html"><strong aria-hidden="true">10.</strong> Setup</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Foundations</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="html_intro.html"><strong aria-hidden="true">11.1.</strong> Intro to HTML</a></li><li class="chapter-item expanded "><a href="view_macro_html.html"><strong aria-hidden="true">11.2.</strong> HTML and the view! macro</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Architecture</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">12.1.</strong> Leptos Components - #[component]</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.2.</strong> Signals (reactive values) - create_signal</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.3.</strong> Effects (side effects) - create_effect</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> Leptos Components</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="leptos_component_intro.html"><strong aria-hidden="true">13.1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="view_macro_variables.html"><strong aria-hidden="true">13.2.</strong> Variables and the view! macro</a></li><li class="chapter-item expanded "><a href="leptos_component_properties.html"><strong aria-hidden="true">13.3.</strong> Component properties</a></li><li class="chapter-item expanded "><a href="leptos_component_dynamic_content_separation.html"><strong aria-hidden="true">13.4.</strong> Component dynamic content separation</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.5.</strong> Loops and conditionas in components</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> Client Side</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">14.1.</strong> Events</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="leptos_component_logging_events.html"><strong aria-hidden="true">14.1.1.</strong> Witnessing events</a></li><li class="chapter-item expanded "><a href="leptos_component_update_from_event.html"><strong aria-hidden="true">14.1.2.</strong> Reacting to events with event handlers</a></li><li class="chapter-item expanded "><a href="event_handlers_as_props.html"><strong aria-hidden="true">14.1.3.</strong> Event handers as props</a></li><li class="chapter-item expanded "><a href="event_bubbling_and_signal_generics.html"><strong aria-hidden="true">14.1.4.</strong> Event Bubbling and Signal Generics</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.1.5.</strong> Preventing bubbling and default event behaviours </div></li><li class="chapter-item expanded "><a href="custom_events.html"><strong aria-hidden="true">14.1.6.</strong> Custom Events</a></li><li class="chapter-item expanded "><a href="custom_event_data.html"><strong aria-hidden="true">14.1.7.</strong> Custom Event Data</a></li><li class="chapter-item expanded "><a href="custom_event_module.html"><strong aria-hidden="true">14.1.8.</strong> Custom Event Module</a></li><li class="chapter-item expanded "><a href="custom_event_module_with_data.html" class="active"><strong aria-hidden="true">14.1.9.</strong> Custom Event Module with Data</a></li><li class="chapter-item expanded "><a href="custom_event_data_with_signals_and_effects.html"><strong aria-hidden="true">14.1.10.</strong> Custom Event Data with Signals and Effects</a></li><li class="chapter-item expanded "><a href="custom_event_data_with_signals_and_effects_part2.html"><strong aria-hidden="true">14.1.11.</strong> Custom Event Data with Signals and Effects - Part 2</a></li></ol></li><li class="chapter-item expanded "><a href="forms.html"><strong aria-hidden="true">14.2.</strong> Forms</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> Server Side Rendering - Traditional</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">15.1.</strong> Responding to URL requests with HTML</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.2.</strong> Responding to form Post actions with HTML</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> Server Side Rendering - Partial with Hydration</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Building an Application</li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Design Patterns and Application Structure</li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Common Problems</li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Building Apps with Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="custom-event-module-with-data"><a class="header" href="#custom-event-module-with-data">Custom event module with data</a></h1>
<h2 id="what-we-know"><a class="header" href="#what-we-know">What we know</a></h2>
<ul>
<li>Data can be assocaited with custom events</li>
<li>We can hide the complexity of creating custom events behind an easy to use function inside a module.</li>
</ul>
<h2 id="what-well-learn"><a class="header" href="#what-well-learn">What we'll learn</a></h2>
<ul>
<li>How to add data to our module.</li>
</ul>
<h2 id="the-lesson"><a class="header" href="#the-lesson">The lesson</a></h2>
<p>In a previous lesson we created a module that made dispatching a custom event super easy. We discussed adding data to events before and how useful it is, but we can't add data to be disptched with the events in our custom event module. We should fix that!</p>
<p>Our simple module looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod component_custom_event {  
    use leptos::web_sys;  
    use leptos::wasm_bindgen::JsValue;  
  
    fn new(name: &amp;str) -&gt; Result&lt;web_sys::CustomEvent, JsValue&gt; {  
        // configuration  
        let mut event_config = web_sys::CustomEventInit::new();  
        event_config.bubbles(true);  
        // generation  
        web_sys::CustomEvent::new_with_event_init_dict(  
            name,  
            &amp;event_config,  
        )  
    }  
  
    pub fn dispatch( name: &amp;str, target_ref : NodeRef) 
    -&gt; Result&lt;bool, JsValue&gt;{  
  
        let event = new(name);  
        let target = target_ref.get();  
  
        match (event, target) {  
            (Ok(event), Some(target)) =&gt; {  
                target.dispatch_event(&amp;event)  
            },  
            (_,_) =&gt; Err(JsValue::null())  
        }  
    }  
}  
<span class="boring">}</span></code></pre></pre>
<h3 id="adding-jsvalue-data-to-the-event"><a class="header" href="#adding-jsvalue-data-to-the-event">Adding JsValue data to the event</a></h3>
<p>I have an example from a previous lesson where I added a payload to an event through the details method on the event configuration. Let's add that back in. </p>
<p>The first step is adding a new parameter to the <code>new</code> function which allows us to get a JsValue in there.</p>
<p>We'll add an Option, because sometimes we might not have a payload. Alternately we could create a function called 'new_with_payload' but this is fine.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn new(name: &amp;str, payload: Option&lt;JsValue&gt;) -&gt; Result&lt;web_sys::CustomEvent, JsValue&gt; 
<span class="boring">}</span></code></pre></pre>
<p>Then we'll conditionally add it to the event_config if we're given Some(data) for the payload.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(data) = payload {  
	event_config.detail(&amp;data);  
}  
<span class="boring">}</span></code></pre></pre>
<p>All finished, we have this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn new(name: &amp;str, payload: Option&lt;JsValue&gt;) -&gt; Result&lt;web_sys::CustomEvent, JsValue&gt; {  
    let mut event_config = web_sys::CustomEventInit::new();  
    event_config.bubbles(true);  
    if let Some(data) = payload {  
        event_config.detail(&amp;data);  
    }  
    web_sys::CustomEvent::new_with_event_init_dict(name, &amp;event_config)  
}
<span class="boring">}</span></code></pre></pre>
<h3 id="simplified-sending-methods-api"><a class="header" href="#simplified-sending-methods-api">Simplified sending methods (API)</a></h3>
<p>There is no way to specify a default parameter value in Rust. We want our api to be simple and declarative. We don't want to force people to always provide &quot;None&quot; if they're not including a payload. To fix this we can make a private method called real_dispatch and then a public method to dispatch and event without and with a payload respectively, called <code>dispatch</code> and <code>dispatch_with_data</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn real_dispatch( 
	name: &amp;str, 
	target_ref : NodeRef, 
	payload: Option&lt;JsValue&gt;
	) -&gt; Result&lt;bool, JsValue&gt;{  
  
    let event = new(name, payload);  
    let target = target_ref.get();  
  
    match (event, target) {  
        (Ok(event), Some(target)) =&gt; {  
            target.dispatch_event(&amp;event)  
        },        (_,_) =&gt; Err(JsValue::null())  
    }
}

pub fn dispatch( 
	name: &amp;str, 
	target_ref : NodeRef
	) -&gt; Result&lt;bool, JsValue&gt;{  
    real_dispatch( name, target_ref, None)  
}

pub fn dispatch_with_data( 
	name: &amp;str, 
	target_ref : NodeRef, 
	data: JsValue
	) -&gt; Result&lt;bool, JsValue&gt;{  
    real_dispatch( name, target_ref, Some(data))  
}
    
<span class="boring">}</span></code></pre></pre>
<p>While we're at it, let's add a function to grab the value a bit more easily too:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn extract_data( event: web_sys::Event) -&gt; JsValue {  
    event
	    .unchecked_into::&lt;web_sys::CustomEvent&gt;()
	    .detail()  
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>We've seen this in a prior lesson. Were just packaging it as part of the module here.</p>
</blockquote>
<h3 id="structured-data"><a class="header" href="#structured-data">Structured Data</a></h3>
<p>Here's where things get interestng. We probably don't to just send a single value. We might want to send a few values. If we went back to our BLT example, maybe we want to send a struct of the whole BLT Sandwich config.</p>
<p>JavaScript requires everything to be sent as text. We need a way to convert structured data into a sequence of characters that can faithfully represent it. The process of producing this is called serialization. Converting data from a serialized representation to it's typed and structured form is called deserialization. </p>
<p>Currently what we have will allow us to send stuctured data but it's on the application developer to serialize data and convert it into a JsValue for use with <code>dispatch_with_data()</code>. I think it would be convenient to do this for them so that they don't have to think about serialization. </p>
<p>Let's start by adding a new function. I don't know what the type of data will be so I'm writing UNKNOWN for the sake of this example. This is not a Rust thing. It's just for you, the reader, to help you follow my thought process.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn dispatch_with_data_serialized(  
    name: &amp;str,  
    target_ref : NodeRef,  
    data: UNKNOWN
    ) -&gt; Result&lt;bool, JsValue&gt;{  
	// ..
}
<span class="boring">}</span></code></pre></pre>
<p>I did some searching and found a great crate called &quot;serde&quot; which received it's name from ser-ialize de-serialize. It turns out that there is a version of serde specifically designed to work with wasm, which is supposidly more efficient than converting structured data into JSON (JavaScript Object Notation) and it gives us a JsValue! How great is that!</p>
<p>I've added the dependency to cargo.toml as such:</p>
<pre><code class="language-toml">serde-wasm-bindgen = &quot;0.4&quot;
</code></pre>
<p>And now I can author the body of the function which is actually realtively simple:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match serde_wasm_bindgen::to_value(data) {  
	Ok(data) =&gt; dispatch_with_data( name, target_ref, data),
	Err(_) =&gt; Err( JsValue::null() )  
}
<span class="boring">}</span></code></pre></pre>
<p>We're matching on the result of converting a reference of our data to the JsValue, if it's ok, we destructure it and return the result of dispatch_with_data, otherwise we'll return a null JsValue as an error. </p>
<p>Again, recall that we're keeping the return types the same as <code>EventTarget.dispatch()</code>.</p>
<p>We're not quite done though. We don't know what type to put for the data. Rust requires that we specific the type so that it can verify that we're calling the appropriate methods on it, and correctly managing memory for it.</p>
<p>To do this we'll revisit type generics, which are those type arguments that I talked about before. They're like parameters/variables but for types. People often use 'T' as a character for a generic 'Type' but you can actually use anything you want that isn't a reserved word. I'm going to use <code>Data</code>. Note that <code>data</code> is the parameter name and <code>Data</code> is the generic type name. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn dispatch_with_data_serialized&lt;Data&gt;(  
    name: &amp;str,  
    target_ref : NodeRef,  
    data: &amp;Data
    ) -&gt; Result&lt;bool, JsValue&gt;{  
    //....
}
<span class="boring">}</span></code></pre></pre>
<p>Here we're saying, a generic will be used called <code>Data</code> and the property <code>data</code> will be whatever type <code>Data</code> is, as a referenced value. We're telling Rust, this type can change.</p>
<p>As is, Rust will complain because we're using the value of <code>data</code> as an argument for  <code>serde_wasm_bindgen::to_value()</code>. Rust wants to confirm that whatever is being stored in <code>data</code>, accepted through the function call, can be safely passed to that <code>serde_wasm_bindgen::to_value()</code> function, meeting its type requirements.</p>
<p>Let's look at the definition of <code>serde_wasm_bindgen::to_value()</code> for a clue. It reads as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn to_value&lt;T: serde::ser::Serialize + ?Sized&gt;(value: &amp;T) -&gt; Result&lt;JsValue&gt; {
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Translation: &quot;Whatever you pass as the value of <code>value</code>  must be a reference to T. T is any value whoes type implements the the serde::ser::Serialize trait and is<code>Sized</code>.</p>
</blockquote>
<p>That's it. Our <code>Data</code> needs to fulfill the same type requirements as  <code>serde::ser::Serialize + ?Sized</code> The colon after 'T' indicates qualifiers for 'T'. These qualifiers are Traits. A Trait is a name that refers to a specification of behaviour/capabilities. If you've ever written object oriented code, these would be similar to interfaces. </p>
<h3 id="how-do-we-serialize-data"><a class="header" href="#how-do-we-serialize-data">How do we serialize data?</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn dispatch_with_data_serialized&lt;Data: Serialize + ?Sized&gt;(  
    name: &amp;str,  
    target_ref : NodeRef,  
    data: &amp;Data
    ) -&gt; Result&lt;bool, JsValue&gt;{  

	match serde_wasm_bindgen::to_value(data) {  
        Ok(data) =&gt; dispatch_with_data( name, target_ref, data),
        Err(_) =&gt; Err( JsValue::null() )  
	}
}
<span class="boring">}</span></code></pre></pre>
<p>Serde is included in Leptos and adds support for a bunch of types out of the box. We can also add serialization support for our own types with a macro.  Writing <code>#[derive(Serialize, Deserialize)]</code>
above a struct will tell Rust to write out the functionality to enable these fetures for you. You do, howver, need to import the traits <code>Serialize</code> and <code>Deserialize</code> with the following use statement:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde::{Serialize, Deserialize};
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>We are destructuring here in the use statement so that Serialize and Deserialize are being brought into scope from the serde crate (external module).</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Debug)]  
struct BLTSandwich {  
    bread: String,  
    lettuce: String,  
    tomato: String,  
    bacon: String,  
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>We're also adding Debug so that we can print this struct later in the lesson with the log macro.</p>
</blockquote>
<p>Now let's take a look at our BLT Sandwich component:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn BltSandwich(cx: Scope) -&gt; Element {  
    let dom_node_ref = NodeRef::new(cx);  
  
    let trigger_order_sandwich_event = move |event| {  
        component_custom_event::dispatch_with_data_serialized(  
            &quot;orderSandwich&quot;,  
            dom_node_ref,  
            &amp;BLTSandwich {  
                bread: &quot;canadian_rye&quot;.to_string(),  
                lettuce: &quot;romaine&quot;.to_string(),  
                tomato: &quot;black_krim&quot;.to_string(),  
                bacon: &quot;farm_smoked_apple_bacon&quot;.to_string(),  
            }        
        );  
    };  
    view! {  
        cx,  
        &lt;div _ref=dom_node_ref&gt;  
           &lt;h3&gt;&quot;BLT Sandwich&quot;&lt;/h3&gt;  
            &lt;button on:click=trigger_order_sandwich_event&gt;  
                &quot;Order Sandwich&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }
}
<span class="boring">}</span></code></pre></pre>
<p>It looks like there's one last missing piece of the pizzle. We need a function that will extract our serialized data back into our struct. We'll use as similar tactic to find the type requirements. The generic <code>Data</code> will end up in the return type as a type argument for Option. This means that the function may return Some of <code>Data</code>, which must implement the traits <code>serde::de::DeserializeOwned + ?Sized</code> or None.</p>
<p>Then we call <code>from_value()</code>, match it to handle a potential error and return our option types as the result of the match arm expressions.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn extract_serialized_data&lt;Data: serde::de::DeserializeOwned + ?Sized&gt;(event: web_sys::Event) -&gt; Option&lt;Data&gt; {  
    match serde_wasm_bindgen::from_value(extract_data(event)) {  
        Ok(data) =&gt; Some(data),  
        Err(_) =&gt; None  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>When using this function we need to provide it the type for <code>Data</code> which we can do with our type argument syntax, for example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>component_custom_event::extract_serialized_data::&lt;BLTSandwich&gt;(event)
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>The ::&lt;&gt; is a turbofish and used to inject a concrete type as an argument for a generic.</p>
</blockquote>
<h3 id="wrapping-it-up"><a class="header" href="#wrapping-it-up">Wrapping it up</a></h3>
<p>Here we have a working example of the whole thing!</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
use serde::{Serialize, Deserialize};  
  
mod component_custom_event {  
    use leptos::*;  
    use crate::wasm_bindgen::JsValue;  
  
    fn new(name: &amp;str, payload: Option&lt;JsValue&gt;) -&gt; Result&lt;web_sys::CustomEvent, JsValue&gt; {  
        let mut event_config = web_sys::CustomEventInit::new();  
        event_config.bubbles(true);  
        if let Some(data) = payload {  
            event_config.detail(&amp;data);  
        }  
        web_sys::CustomEvent::new_with_event_init_dict(name, &amp;event_config)  
    }  
    fn real_dispatch(name: &amp;str, target_ref: NodeRef, payload: Option&lt;JsValue&gt;) -&gt; Result&lt;bool, JsValue&gt; {  
        let event = new(name, payload);  
        let target = target_ref.get();  
  
        match (event, target) {  
            (Ok(event), Some(target)) =&gt; target.dispatch_event(&amp;event),  
            (_, _) =&gt; Err(JsValue::null())  
        }    }  
    pub fn dispatch(name: &amp;str, target_ref: NodeRef) -&gt; Result&lt;bool, JsValue&gt; {  
        real_dispatch(name, target_ref, None)  
    }  
    pub fn dispatch_with_data(name: &amp;str, target_ref: NodeRef, data: JsValue) -&gt; Result&lt;bool, JsValue&gt; {  
        real_dispatch(name, target_ref, Some(data))  
    }  
    pub fn dispatch_with_data_serialized&lt;T: serde::ser::Serialize + ?Sized&gt;(  
        name: &amp;str,  
        target_ref: NodeRef,  
        data: &amp;T) -&gt; Result&lt;bool, JsValue&gt; {  
        match serde_wasm_bindgen::to_value(data) {  
            Ok(data) =&gt; dispatch_with_data(name, target_ref, data),  
            Err(_) =&gt; Err(JsValue::null())  
        }    }  
    pub fn extract_data(event: web_sys::Event) -&gt; JsValue {  
        let custom_event = event.unchecked_into::&lt;web_sys::CustomEvent&gt;();  
        custom_event.detail()  
    }  
    pub fn extract_serialized_data&lt;Data: serde::de::DeserializeOwned + ?Sized&gt;(event: web_sys::Event) -&gt; Option&lt;Data&gt; {  
        match serde_wasm_bindgen::from_value(extract_data(event)) {  
            Ok(data) =&gt; Some(data),  
            Err(_) =&gt; None  
        }  
    }}  
  
#[derive(Serialize, Deserialize, Debug)]  
struct BLTSandwich {  
    bread: String,  
    lettuce: String,  
    tomato: String,  
    bacon: String,  
}  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;SandwichShopApp /&gt;  
        }    })}  
  
#[component]  
fn SandwichShopApp(cx: Scope) -&gt; Element {  
    let log_order = |event: web_sys::Event| {  
        leptos::log!(&quot;Our custom event happened&quot;);  
        leptos::log!( &quot;{:?}&quot;, component_custom_event::extract_serialized_data::&lt;BLTSandwich&gt;(event));  
    };  
    view! {  
        cx,  
        &lt;BltSandwich on:orderSandwich=log_order /&gt;  
    }}  
  
#[component]  
fn BltSandwich(cx: Scope) -&gt; Element {  
    let dom_node_ref = NodeRef::new(cx);  
  
    let trigger_order_sandwich_event = move |event| {  
        component_custom_event::dispatch_with_data_serialized(  
            &quot;orderSandwich&quot;,  
            dom_node_ref,  
            &amp;BLTSandwich {  
                bread: &quot;canadian_rye&quot;.to_string(),  
                lettuce: &quot;romaine&quot;.to_string(),  
                tomato: &quot;black_krim&quot;.to_string(),  
                bacon: &quot;farm_smoked_apple_bacon&quot;.to_string(),  
            },        );  
    };  
    view! {  
        cx,  
        &lt;div _ref=dom_node_ref&gt;  
           &lt;h3&gt;&quot;BLT Sandwich&quot;&lt;/h3&gt;  
            &lt;button on:click=trigger_order_sandwich_event&gt;  
                &quot;Order Sandwich&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }
}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="custom_event_module.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="custom_event_data_with_signals_and_effects.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="custom_event_module.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="custom_event_data_with_signals_and_effects.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
