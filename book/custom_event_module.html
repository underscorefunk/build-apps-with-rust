<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Custom Event Module - Building Apps with Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Preface</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Acknowledgements</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> About this Book</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> About the Author</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> If you get stuck or lose steam</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Introductions</li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Programming</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> What it is</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Why it's worth it</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Why it's hard</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> Programmer Thinking</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Languages</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> Meaning and Interpretation</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Architectures</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> How your computer works</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> How the web works</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.3.</strong> The frontend-backend divide</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Tools and Languages</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">9.1.</strong> Bash and the terminal</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.2.</strong> Rust</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.3.</strong> Trunk</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.4.</strong> Web browsers</div></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Rust and Leptos</li><li class="chapter-item expanded "><a href="setup_intro.html"><strong aria-hidden="true">10.</strong> Setup</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Foundations</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="html_intro.html"><strong aria-hidden="true">11.1.</strong> Intro to HTML</a></li><li class="chapter-item expanded "><a href="view_macro_html.html"><strong aria-hidden="true">11.2.</strong> HTML and the view! macro</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Architecture</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">12.1.</strong> Leptos Components - #[component]</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.2.</strong> Signals (reactive values) - create_signal</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.3.</strong> Effects (side effects) - create_effect</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> Leptos Components</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="leptos_component_intro.html"><strong aria-hidden="true">13.1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="view_macro_variables.html"><strong aria-hidden="true">13.2.</strong> Variables and the view! macro</a></li><li class="chapter-item expanded "><a href="leptos_component_properties.html"><strong aria-hidden="true">13.3.</strong> Component properties</a></li><li class="chapter-item expanded "><a href="leptos_component_dynamic_content_separation.html"><strong aria-hidden="true">13.4.</strong> Component dynamic content separation</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.5.</strong> Loops and conditionas in components</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> Client Side</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">14.1.</strong> Events</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="leptos_component_logging_events.html"><strong aria-hidden="true">14.1.1.</strong> Witnessing events</a></li><li class="chapter-item expanded "><a href="leptos_component_update_from_event.html"><strong aria-hidden="true">14.1.2.</strong> Reacting to events with event handlers</a></li><li class="chapter-item expanded "><a href="event_handlers_as_props.html"><strong aria-hidden="true">14.1.3.</strong> Event handers as props</a></li><li class="chapter-item expanded "><a href="event_bubbling_and_signal_generics.html"><strong aria-hidden="true">14.1.4.</strong> Event Bubbling and Signal Generics</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.1.5.</strong> Preventing bubbling and default event behaviours </div></li><li class="chapter-item expanded "><a href="custom_events.html"><strong aria-hidden="true">14.1.6.</strong> Custom Events</a></li><li class="chapter-item expanded "><a href="custom_event_data.html"><strong aria-hidden="true">14.1.7.</strong> Custom Event Data</a></li><li class="chapter-item expanded "><a href="custom_event_module.html" class="active"><strong aria-hidden="true">14.1.8.</strong> Custom Event Module</a></li><li class="chapter-item expanded "><a href="custom_event_module_with_data.html"><strong aria-hidden="true">14.1.9.</strong> Custom Event Module with Data</a></li><li class="chapter-item expanded "><a href="custom_event_data_with_signals_and_effects.html"><strong aria-hidden="true">14.1.10.</strong> Custom Event Data with Signals and Effects</a></li><li class="chapter-item expanded "><a href="custom_event_data_with_signals_and_effects_part2.html"><strong aria-hidden="true">14.1.11.</strong> Custom Event Data with Signals and Effects - Part 2</a></li></ol></li><li class="chapter-item expanded "><a href="forms.html"><strong aria-hidden="true">14.2.</strong> Forms</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> Server Side Rendering - Traditional</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">15.1.</strong> Responding to URL requests with HTML</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.2.</strong> Responding to form Post actions with HTML</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> Server Side Rendering - Partial with Hydration</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Building an Application</li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Design Patterns and Application Structure</li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Common Problems</li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Building Apps with Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="custom-event-module"><a class="header" href="#custom-event-module">Custom Event Module</a></h1>
<h2 id="what-we-know"><a class="header" href="#what-we-know">What we know</a></h2>
<ul>
<li>Data can be assocaited with custom events</li>
<li>There's a lot of boiler plate in with custom events</li>
</ul>
<h2 id="what-well-learn"><a class="header" href="#what-well-learn">What we'll learn</a></h2>
<ul>
<li>How to turn our code into a module that we can reuse</li>
</ul>
<h2 id="the-lesson"><a class="header" href="#the-lesson">The lesson</a></h2>
<h3 id="module-basics"><a class="header" href="#module-basics">Module basics</a></h3>
<p>Rust has the ability to create modules to encapsulate code. It allows you to expose parts of the code to the outside world, while keeping other parts of the code private to the module. </p>
<p>A module is defined by using the key word <code>mod</code> followed by the name of the module and curley braces which encapsulate the code in a module.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod my_module {  
	pub fn hello_world() {
		println!(&quot;Hi&quot;);
	}
	fn you_cant_call_me() {
		println!(&quot;Seeecrets&quot;);
	}
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>We've seen this pattern of <code>set the context</code> then <code>noun</code> the <code>content/definition</code> all over the place. These patterns repeat all over the place.</p>
</blockquote>
<p>The module can be used in the scope in which it is defined without any extra work. We must prefix functions with 'pub' in a module to specify that they are public. Functions in a module have access to private functions that are within the module because they're all in the same module scope. Calling a function inside a module requires you to specify the module's namespace followed by two colons and the function name. </p>
<pre><pre class="playground"><code class="language-rust">mod my_module {  
	pub fn hello_world() {
		println!(&quot;Hi&quot;);
	}
	fn you_cant_call_me() {
		println!(&quot;Seeecrets&quot;);
	}
}

fn main() {  
    // ✅ We can call this public function
    my_module::hello_world();
    
    // ❌ We can't call this private function
    my_module::you_cant_call_me();
}</code></pre></pre>
<h4 id="module-files"><a class="header" href="#module-files">Module files</a></h4>
<p>Modules can be moved to their own files as well. </p>
<ol>
<li>Create a my_module.rs file in the ./src folder fo your application</li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn hello_world() {
	println!(&quot;Hi&quot;);
}
fn you_cant_call_me() {
	println!(&quot;Seeecrets&quot;);
}
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li>Bring it into scope in your ./src/main.rs file with <code>mod my_module</code> which will automatically hook up the file my_module.rs</li>
</ol>
<pre><pre class="playground"><code class="language-rust">mod my_module;

fn main() {  
    my_module::hello_world();
}</code></pre></pre>
<p>Now, while you can do this, it's not ideal. </p>
<h3 id="librs"><a class="header" href="#librs">lib.rs</a></h3>
<p>The preferred orgnization is to create a lib.rs file, which is the entry point to your crate's functionality. It is called lib because it is a library of functionality and isn't intended to be directly executed. We'll deal with the details of this later. For this lesson we're going to create the module in the same main.rs file as your example application.</p>
<h2 id="the-refactor"><a class="header" href="#the-refactor">The refactor</a></h2>
<p>We started off with the following from a previous lesson:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
use crate::wasm_bindgen::JsValue;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;SandwichShopApp /&gt;  
        }  
    })  
}  
  
#[component]  
fn SandwichShopApp(cx: Scope) -&gt; Element {  
    let log_order = |event : web_sys::Event| {  
        leptos::log!(&quot;Our custom event happened&quot;);  
  
        let bread_type = event  
            .unchecked_into::&lt;web_sys::CustomEvent&gt;()  
            .detail()  
            .as_string()  
            .unwrap_or(String::new());  
  
        leptos::log!(&quot;{:?}&quot;, bread_type );  
    };  
    view! {  
        cx,  
        &lt;BltSandwich on:orderSandwich=log_order /&gt;  
    }  
}  
  
#[component]  
fn BltSandwich(cx: Scope) -&gt; Element {  
    let dom_node_ref = NodeRef::new(cx);  
  
    let trigger_order_sandwich_event = move |event| {  
  
        let mut event_config = web_sys::CustomEventInit::new();  
        event_config.bubbles(true);  
        let bread_type = JsValue::from(&quot;Canadian Rye&quot;);  
        event_config.detail( &amp;bread_type );  
        
        let event = web_sys::CustomEvent::new_with_event_init_dict(  
            &quot;orderSandwich&quot;,  
            &amp;event_config  
        );  
  
        match event {  
            Ok(event) =&gt; {  
                match dom_node_ref.get() {  
                    None =&gt; {}  
                    Some(dom_element) =&gt; {  
                        match dom_element.dispatch_event(&amp;event) {  
                            Ok(_) =&gt; { leptos::log!(&quot;Custom event sent&quot;) },  
                            Err(_) =&gt; { leptos::log!(&quot;Failed to send&quot;) }  
                        }  
                    }  
                }  
            }  
            Err(_) =&gt; {}  
        }  
        
    };  
    view! {  
        cx,  
        &lt;div _ref=dom_node_ref&gt;  
           &lt;h3&gt;&quot;BLT Sandwich&quot;&lt;/h3&gt;  
            &lt;button on:click=trigger_order_sandwich_event&gt;  
                &quot;Order Sandwich&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }  
}</code></pre></pre>
<p>We'll start by making a module.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod component_custom_event {
	
}
<span class="boring">}</span></code></pre></pre>
<p>For the time being we'll remove the complexity of dealing with the event data, omitting the following lines:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bread_type = JsValue::from(&quot;Canadian Rye&quot;);  
event_config.detail( &amp;bread_type );  
<span class="boring">}</span></code></pre></pre>
<p>How it's time to start moving things into the module and generalizing them or making them configurable. </p>
<p>I could see myself annotating the following code with a comment like <code>//first create a custom event</code>. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	let mut event_config = web_sys::CustomEventInit::new();  
	event_config.bubbles(true);  
	
	let event = web_sys::CustomEvent::new_with_event_init_dict(  
		&quot;orderSandwich&quot;,  
		&amp;event_config  
	);  
  
<span class="boring">}</span></code></pre></pre>
<p>This immediately tells me that there's a name I can give to these lines that summarizes them. We're creating a new custom event. We do need to give this new event a name, which instantly makes me think, &quot;Name is a parameter!&quot; We also know that <code>new_with_event_init_dict()</code> returns a Result type, which we handled before with our match statement. </p>
<p>Let's start by stubbing out the definition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod component_custom_event {
	fn new(name: &amp;str) -&gt; Result&lt;web_sys::CustomEvent, JsValue&gt; {  
		// do stuff
	}
<span class="boring">}</span></code></pre></pre>
<p>If this worked we could use <code>component_custom_event::new(&quot;orderSandwich&quot;)</code> and we should get what we expect to continue in our event handler.</p>
<p>A module is a separate scope. It acts in a similar way to main.rs, which has it's own scope. Rust is very good at being congruent like that.  web_sys and JsValue aren't defined in the module. To fix this we'll add some use statements.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use leptos::*;  //web_sys is imported as part of leptos's prelude
use leptos::wasm_bindgen::JsValue;
<span class="boring">}</span></code></pre></pre>
<p>Let's copy the code block in as the body:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod component_custom_event {
	use leptos::*;  
	use leptos::wasm_bindgen::JsValue;

	fn new(name: &amp;str) -&gt; Result&lt;web_sys::CustomEvent, JsValue&gt; {  
	    let mut event_config = web_sys::CustomEventInit::new();  
	    event_config.bubbles(true);  
	    let event = web_sys::CustomEvent::new_with_event_init_dict(  
			&quot;orderSandwich&quot;,  
			&amp;event_config  
		);  
	}
}
<span class="boring">}</span></code></pre></pre>
<p>And, we need to hook up our property so that it's arguments are used in the events configuration. To do this we need to replace the literal &quot;orderSandwich&quot; with name. Now the value of the <code>name</code> function parameter will be used as the event's <code>name</code>, passed as the first argument to <code>new_with_event_init_dict()</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod component_custom_event {
	
	fn new(name: &amp;str) -&gt; Result&lt;web_sys::CustomEvent, JsValue&gt; {  
	    let mut event_config = web_sys::CustomEventInit::new();  
	    event_config.bubbles(true);  
	    let event = web_sys::CustomEvent::new_with_event_init_dict(  
			name, 
			&amp;event_config  
		);  
	}
}
<span class="boring">}</span></code></pre></pre>
<p>But we're not quite done here. We have an assignment for the last expression with <code>let event =</code>. And the last expression has a semicolon <code>;</code> at the end. This would result in the new function returning a unit type, written as <code>()</code>. If we want to return the event we could write <code>event</code> at the end, without a semicolon, so that it would be the &quot;last word&quot; in the function. Recall that Rust is expression based and the last open expression is used as the return of functions and scope blocks (unless you write <code>return</code> and provide it something to explicitly return). Let's remove the assignment and semicolon, and we're done with this one.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod component_custom_event {
	
	fn new(name: &amp;str) -&gt; Result&lt;web_sys::CustomEvent, JsValue&gt; {  
		// configuration
	    let mut event_config = web_sys::CustomEventInit::new();  
	    event_config.bubbles(true);  
		// generation
	    web_sys::CustomEvent::new_with_event_init_dict(  
			name, 
			&amp;event_config  
		)
	}
}
<span class="boring">}</span></code></pre></pre>
<p>You might be tempted to try to do some form of chaining or nesting to make this even smaller. But <code>CustomEventInit::new()</code> returns a value that we need to mutate. It's the most clear to separate out the configuration stage from the custom event generation stage.</p>
<p>So now, my custom event dispatcher/handler looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let trigger_order_sandwich_event = move |event| {  
		
		component_custom_event::new(&quot;orderSandwich&quot;);
  
        match event {  
            Ok(event) =&gt; {  
                match dom_node_ref.get() {  
                    None =&gt; {}  
                    Some(dom_element) =&gt; {  
                        match dom_element.dispatch_event(&amp;event) {  
                            Ok(_) =&gt; { leptos::log!(&quot;Custom event sent&quot;) },  
                            Err(_) =&gt; { leptos::log!(&quot;Failed to send&quot;) }  
                        }  
                    }  
                }  
            }  
            Err(_) =&gt; {}  
        }  
        
    };  
<span class="boring">}</span></code></pre></pre>
<p>I'm looking at this and that whole <code>match event</code> block really looks like it summarizes as &quot;send event&quot;. In fact, it feels like that's what I'm doing with this whole thing. I'm just dispatching a custom event on a specific node, through it's reference.</p>
<p>Maybe what I'm looking for is something like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let trigger_order_sandwich_event = move |event| {  
	component_custom_event::dispatch(&quot;orderSandwich&quot;, dom_node_ref);
}
<span class="boring">}</span></code></pre></pre>
<p>Yeah, that's starting to look good! That says what I want to happen.</p>
<p>Now let's write the how. We'l start with defining a new function in the module. The name is going to pass right through, and we'll accept a NodeRef as a parameter. We know this because <code>NodeRef::new(cx)</code> returns a NodeRef type. If you got this wrong, Rust will actually inform you, &quot;Oh, you tried to use a NodeRef where your dispatch method was expecting a (whatever type you used).&quot; Our return type will be the same return type as <code>EventTarget.dispatch_event()</code>. We'll try to not deviate from the interface used in the standard methods. This will help us use these interchangably in the future.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// in mod component_custom_event {
pub fn dispatch( name: &amp;str, target_ref : NodeRef) -&gt; Result&lt;bool, JsValue&gt;{

}
<span class="boring">}</span></code></pre></pre>
<p>Now we need to create our new event from the name, and we need to send the event with our node ref. Our node ref needs to be converted into a target because we can only call dispatch_event methods on <code>EventTarget</code> type values.</p>
<p>And so we create a new event:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let event = new(name);  
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>We can just write <code>new</code> because <code>new</code> is defined in the local module scope! This is a great example of why modules are so convenient. They're like structs that have no data and only have class methods.</p>
</blockquote>
<p>And we create our target from the reference:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let target = target_ref.get();  
<span class="boring">}</span></code></pre></pre>
<p>Now, here's a really cool part. <code>event</code> is a <code>Result</code> and <code>target</code> is an <code>Option</code>. We know this because we defined the return type for the <code>new()</code> function. We can look up the return type of NodeRef.get(). We only want to dispatch the event if our event is valid and we have a target to send it on. Rust allows you to create tuples (groups of values where their type is known at specific locations) which we can use in matchs statements. They're like super powered pattern matching if statements.</p>
<p>We can create a <code>match</code> for a tuple with <code>event</code> and <code>target</code> to do something if both are Ok() and Some() respectively!</p>
<p>Take a look at this.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match (event, target) {  
	// We are matching on the Result and Option enums
	// and we're destructuring, all in one step!
	( Ok(event), Some(target) ) =&gt; target.dispatch_event(&amp;event),  
	// The underscore indicates any other option that didn't match.
	// You can think of it as any other possible value that is a 
	// valid value within the type (recall that types jsut define 
	// the bounds of valid values)
	(_,_) =&gt; Err(JsValue::null())  
}  
<span class="boring">}</span></code></pre></pre>
<p>Out whole method is finished!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn dispatch( name: &amp;str, target_ref : NodeRef) -&gt; Result&lt;bool, JsValue&gt;{  
  
    let event = new(name);  
    let target = target_ref.get();  
  
    match (event, target) {  
        ( Ok(event), Some(target) ) =&gt; target.dispatch_event(&amp;event),
        (_,_) =&gt; Err(JsValue::null())  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>A new things to note here is that match is the last statement in the dispatch method. The result of will be used as the return value. In our match arms, we don't include semiconons because we want those match arms to become the evaluated value of the match statement, which becomes the evaluated value of the dispatch method. It sounds complicated at first, but if you take your time to read it carefully it'll click and the beauty of this will shine through.</p>
<p>There are also a few interesting Rust syntax things here that might have you scratching your head.</p>
<ol>
<li>We use <code>event</code> in <code>match (event,target)</code> but then we also use <code>event</code> in the match arm's destructuring statement <code>( Ok(event), Some(target) )</code> and we use <code>&amp;event</code> in the match arm's body. We can do this because we're actually reassigning <code>event</code> to a different value as we go along. This is called <code>variable shadowing</code>. We can use <code>event</code> to evaluate the match arms. When evaluating the body of the match arm, Rust will destructure and assign the values stored in the <code>Ok()</code> and <code>Some()</code> enums to their <code>event</code> and <code>target</code> names respectively.</li>
<li>We've removed the curley brances from the branch arms. Rust allows us to drop curley brances for match arms if the contents of an arm's body is a single statement. It just helps keep visual clutter down.</li>
</ol>
<p>And like that, we're done.</p>
<p>If we look at our whole component, it's very easy to see the behaviour. We're able to focus on what is happening and not how it's happening. This is the power of declarative code. It allows our mind to think at one level of detail.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
mod component_custom_event {  
    use leptos::web_sys;  
    use leptos::wasm_bindgen::JsValue;  
  
    fn new(name: &amp;str) -&gt; Result&lt;web_sys::CustomEvent, JsValue&gt; {  
        // configuration  
        let mut event_config = web_sys::CustomEventInit::new();  
        event_config.bubbles(true);  
        // generation  
        web_sys::CustomEvent::new_with_event_init_dict(  
            name,  
            &amp;event_config,  
        )  
    }  
  
    pub fn dispatch( name: &amp;str, target_ref : NodeRef) -&gt; Result&lt;bool, JsValue&gt;{  
  
        let event = new(name);  
        let target = target_ref.get();  
  
        match (event, target) {  
            (Ok(event), Some(target)) =&gt; {  
                target.dispatch_event(&amp;event)  
            },  
            (_,_) =&gt; Err(JsValue::null())  
        }  
    }  
}  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;SandwichShopApp /&gt;  
        }  
    })  
}  
  
#[component]  
fn SandwichShopApp(cx: Scope) -&gt; Element {  
    let log_order = |event: web_sys::Event| {  
        leptos::log!(&quot;Our custom event happened&quot;);  
    };  
    view! {  
        cx,  
        &lt;BltSandwich on:orderSandwich=log_order /&gt;  
    }  
}  
  
#[component]  
fn BltSandwich(cx: Scope) -&gt; Element {  
    let dom_node_ref = NodeRef::new(cx);  
  
    let trigger_order_sandwich_event = move |event| {  
        component_custom_event::dispatch(&quot;orderSandwich&quot;, dom_node_ref);  
    };  
    view! {  
        cx,  
        &lt;div _ref=dom_node_ref&gt;  
           &lt;h3&gt;&quot;BLT Sandwich&quot;&lt;/h3&gt;  
            &lt;button on:click=trigger_order_sandwich_event&gt;  
                &quot;Order Sandwich&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }  
}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="custom_event_data.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="custom_event_module_with_data.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="custom_event_data.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="custom_event_module_with_data.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
