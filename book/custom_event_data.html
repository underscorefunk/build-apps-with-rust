<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Custom Event Data - Building Apps with Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Preface</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Acknowledgements</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> About this Book</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> About the Author</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> If you get stuck or lose steam</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Introductions</li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Programming</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> What it is</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Why it's worth it</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Why it's hard</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> Programmer Thinking</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Languages</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> Meaning and Interpretation</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Architectures</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> How your computer works</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> How the web works</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.3.</strong> The frontend-backend divide</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Tools and Languages</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">9.1.</strong> Bash and the terminal</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.2.</strong> Rust</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.3.</strong> Trunk</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.4.</strong> Web browsers</div></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Rust and Leptos</li><li class="chapter-item expanded "><a href="setup_intro.html"><strong aria-hidden="true">10.</strong> Setup</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Foundations</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="html_intro.html"><strong aria-hidden="true">11.1.</strong> Intro to HTML</a></li><li class="chapter-item expanded "><a href="view_macro_html.html"><strong aria-hidden="true">11.2.</strong> HTML and the view! macro</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Architecture</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">12.1.</strong> Leptos Components - #[component]</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.2.</strong> Signals (reactive values) - create_signal</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.3.</strong> Effects (side effects) - create_effect</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> Leptos Components</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="leptos_component_intro.html"><strong aria-hidden="true">13.1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="view_macro_variables.html"><strong aria-hidden="true">13.2.</strong> Variables and the view! macro</a></li><li class="chapter-item expanded "><a href="leptos_component_properties.html"><strong aria-hidden="true">13.3.</strong> Component properties</a></li><li class="chapter-item expanded "><a href="leptos_component_dynamic_content_separation.html"><strong aria-hidden="true">13.4.</strong> Component dynamic content separation</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.5.</strong> Loops and conditionas in components</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> Client Side</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">14.1.</strong> Events</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="leptos_component_logging_events.html"><strong aria-hidden="true">14.1.1.</strong> Witnessing events</a></li><li class="chapter-item expanded "><a href="leptos_component_update_from_event.html"><strong aria-hidden="true">14.1.2.</strong> Reacting to events with event handlers</a></li><li class="chapter-item expanded "><a href="event_handlers_as_props.html"><strong aria-hidden="true">14.1.3.</strong> Event handers as props</a></li><li class="chapter-item expanded "><a href="event_bubbling_and_signal_generics.html"><strong aria-hidden="true">14.1.4.</strong> Event Bubbling and Signal Generics</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.1.5.</strong> Preventing bubbling and default event behaviours </div></li><li class="chapter-item expanded "><a href="custom_events.html"><strong aria-hidden="true">14.1.6.</strong> Custom Events</a></li><li class="chapter-item expanded "><a href="custom_event_data.html" class="active"><strong aria-hidden="true">14.1.7.</strong> Custom Event Data</a></li><li class="chapter-item expanded "><a href="custom_event_module.html"><strong aria-hidden="true">14.1.8.</strong> Custom Event Module</a></li><li class="chapter-item expanded "><a href="custom_event_module_with_data.html"><strong aria-hidden="true">14.1.9.</strong> Custom Event Module with Data</a></li><li class="chapter-item expanded "><a href="custom_event_data_with_signals_and_effects.html"><strong aria-hidden="true">14.1.10.</strong> Custom Event Data with Signals and Effects</a></li></ol></li><li class="chapter-item expanded "><a href="forms.html"><strong aria-hidden="true">14.2.</strong> Forms</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> Server Side Rendering - Traditional</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">15.1.</strong> Responding to URL requests with HTML</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.2.</strong> Responding to form Post actions with HTML</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> Server Side Rendering - Partial with Hydration</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Building an Application</li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Design Patterns and Application Structure</li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Common Problems</li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Building Apps with Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="custom-event-data"><a class="header" href="#custom-event-data">Custom Event Data</a></h1>
<h2 id="what-we-know"><a class="header" href="#what-we-know">What we know</a></h2>
<ul>
<li>Custom events can be dispatched and bubbled up to handle events at different levels of your applications.</li>
<li>Custom events allow us to convert imperative events based on DOM interaction into domain specific events that are more declarative.</li>
</ul>
<h2 id="what-well-learn"><a class="header" href="#what-well-learn">What we'll learn</a></h2>
<ul>
<li>A deeper look in to declarative or domain specific code</li>
<li>Why and how to add data with custom events</li>
</ul>
<h2 id="caveat"><a class="header" href="#caveat">Caveat</a></h2>
<ul>
<li>Custom events with data isn't the most efficient way to send data around Leptos. There is a performance toll to be paid any time data crosses the WASM boundary. This lesson is really about showing you how to do JavaScript like things in Leptos/Rust. With that said, there are more efficient ways to send data around Leptos, but at the cost of JavaScript interoperatibilty, which we'll investigate in later lessons.</li>
</ul>
<h2 id="the-lesson"><a class="header" href="#the-lesson">The Lesson</a></h2>
<p>We introduced custom events in a previous lesson, with the following code:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;RadApp /&gt;  
        }  
    })  
}  
  
#[component]  
fn RadApp(cx: Scope) -&gt; Element {  
    let log_response = |_| {  
        leptos::log!(&quot;Our custom event happened&quot;)  
    };  
    view! {  
        cx,  
        &lt;MyComponent on:myCustomEvent=log_response /&gt;  
    }  
}  
  
#[component]  
fn MyComponent(cx: Scope) -&gt; Element {  
    let dom_node_ref = NodeRef::new(cx);  
  
    let trigger_sending_of_custom_event = move |_| {  
  
        let mut event_config = web_sys::CustomEventInit::new();  
        event_config.bubbles(true);  
        let event = web_sys::CustomEvent::new_with_event_init_dict(
	        &quot;myCustomEvent&quot;, 
	        &amp;event_config
	    );  
  
        match event {  
             Ok(event) =&gt; {  
                 match dom_node_ref.get() {  
                    None =&gt; {}  
                    Some(dom_element) =&gt; {  
                        match dom_element.dispatch_event(&amp;event) {  
                            Ok(_) =&gt; { leptos::log!(&quot;Custom event sent&quot;) },  
                            Err(_) =&gt; { leptos::log!(&quot;Failed to send&quot;) }  
                        }  
                    }  
                }  
            }  
            Err(_) =&gt; {}  
        }  
    };  
    view! {  
        cx,  
        &lt;div _ref=dom_node_ref&gt;  
            &lt;button on:click=trigger_sending_of_custom_event&gt;  
                &quot;Trigger custom event&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }  
}</code></pre></pre>
<p>In this code we have a Leptos component which contains a <code>view!</code> tempate with a div and a button. This button has a handler which is a closure passed to a <code>click</code> event via the <code>on:click</code> property (prop). </p>
<p>Leptos has a special private property for elements in <code>view!</code> templates. It's called <code>_ref</code> and it's used to allow Leptos to refer to HTML elements (by refering to them) in the client side runtime (in the browser). We create a reference in a given scope/context, and apply it as the value of the property <code>_ref</code>. </p>
<p>Recall that the root element of a <code>view!</code> template is interchangable with it's component tag. By placing a reference on the root <code>&lt;div&gt;</code> we're actually creating a reference to <code>&lt;MyComponent&gt;</code>.</p>
<p>The reference is used in the event handler so that our custom event appears to be dispatched from our Leptos component, allowing us to add a handler with <code>&lt;MyComponent on:myCustomEvent=... /&gt;</code>.</p>
<h3 id="platform-specific-to-domain-specific"><a class="header" href="#platform-specific-to-domain-specific">Platform specific to domain specific</a></h3>
<p>Systems and applications are full of complex mechanism. They contain behaviours that are described in code that reveal how the platform was designed and implemented. </p>
<p>Systems and applications are also full of domain specific complexity. They contain behaviours relating to the &quot;business logic&quot; or description of how the application solves a problem. How these problems are solved often describe activities relating to the problem, and not specifically relating to the technology that it runs on.</p>
<p>Or example, let's think about building a sandwich shop ecommerce application. And let's say we're clicking on a &quot;buy sandwich button&quot;. That button would have an on click event to add a sandwich to your cart. The idea of clicking and dispatching an event when something is clicked doesn't actually have anything to do with buying sandwiches. It actually has to do with the platform. </p>
<p>In our minds we may look at the button, the intention behind it, the text node as its label, and infering that clicking on the button should order a sandwich. This is implied and requires us to think about the intention of the application through its interaction with the platform.</p>
<p>If that event became an &quot;order sandwich&quot; event then we'd be in domain territory. It is specific to the language that describes activites and actions in the head space or domain of our problem—our sandwich shop.</p>
<p>Separating required knowledge of the platform from knowledge and interactions between business processes will allow you to focus on each area separately. This will allow you to change which things could trigger a sandwich order instead of introspecting and evaluating generic events.</p>
<p>This can make applications more flexible, robust, simple, and easier to understand. </p>
<h3 id="the-case-for-associated-event-data"><a class="header" href="#the-case-for-associated-event-data">The case for associated event data</a></h3>
<p>We've outlined that it's useful to separate platform events from application events, but we have't discussed the importance of associated data with those events yet. </p>
<p>Let's go back to our online sandwich shop as an example case. If have one sandwich, we're good. We can dispatch a custom event called &quot;orderSandwich&quot; and let that be that. But what do we do if we have more than one sandwich type? We'll need some way to know which sandwich we're ordering.</p>
<p>One solution could be to create one event per sandwich type. Perhaps we have orderRubinSandwich or orderBLTSandwich. This could be a completely valid solution if we only had a few sandwiches. Where things get tricky is when we start to think about configurations of sandwiches. We'll end with a combinatorial explosion of event types to match each sandwich configuration.</p>
<p>Our  Bacon Lettuce and Tomato sandwich, with the ability to select different breads, leafy greens, or tomato types, then we'd quickly end up with too many variants of event to manage.</p>
<p>This is a situation where we'd like our system to dispatch an event called orderSandwich, with data associated to configures what the sandwich is. It would be idea if we could send an orderBLTSandwich event where we specify which bread, leafy greens, or type of tomato are requeted by the customer.</p>
<blockquote>
<p>Beware, you may feel the urge to continue abstracting. It's not uncommon to think, &quot;Well, what if we want to sell different things at our sandwich shop? Why don't we just have orderItem as an event type and the configure of that item can include the item type, being a sandwich. If we ordered a drink, then drink would be the item type, and so forth.&quot; One could say that this is a premature generalization. The more general a system becomes the less its components express the function of the application. Moving from specific to generic actually adds some complexity in that you need to apply a case to think about the generalization. Try to start with the concrete, known, specific, and within the domain. Then refactor and generalize as needed as the application grows. There are no hard an fast rules for when to do this, just be aware that you do not need to hyper generalize your solutions at the start. Write what you mean, be clear, and you'll thank yourself later when you have to go in and edit things a month or year from now. :)</p>
</blockquote>
<h3 id="getting-the-configuration"><a class="header" href="#getting-the-configuration">Getting the configuration</a></h3>
<p>For the most simple example we can actually hard code the configuration into the event sender. We don't need to pull it out any HTML data attributes or input fields.</p>
<p>Our template could look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> view! {  
    cx,  
    &lt;div _ref=dom_node_ref&gt;  
     &lt;h3&gt;&quot;BLT Sandwich&quot;&lt;/h3&gt;  
        &lt;button  
         on:click=trigger_order_sandwich_event  
         &gt;  
            &quot;Order Sandwich&quot;  
        &lt;/button&gt;  
    &lt;/div&gt;  
}
<span class="boring">}</span></code></pre></pre>
<p>We need to update the event handler so that our new custom event is sent with this extra data. Web events have a property on their JavaScript object called <code>detail</code>, which we can use to story and carry arbitrary data. </p>
<p>After we initialize the <code>event_config</code>, we modify it so that it bubbles up (so that ancestors can respond to the event), and then we'll do another modification to add the detail data. Recall that if we're changing a piece of data we need to write <code>mut</code> before the name of it to specify that it can be changed, that it can be MUTated.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	let mut event_config = web_sys::CustomEventInit::new();  
    event_config.bubbles(true);  
    event_config.detail(&amp;data);
<span class="boring">}</span></code></pre></pre>
<p>But now you're probably wondering, what is <code>&amp;data</code>. We're providing the detail method on <code>event_config</code> with a reference (denoted with the <code>&amp;</code> ) to <code>data</code>. The detail method accepts any JsValue. In our simple example, we're only going to specify bread type. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bread_type = JsValue::from(&quot;Canadian Rye&quot;);  
event_config.detail( &amp;bread_type );
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>We are calling the from static method on the JsValue struct to create a new JsValue from our string slice &quot;Canadian Rye&quot;. We're then using the bread_type as an argument for the detail method, but we're passing the data as a reference, denoted with the <code>&amp;</code>; If you forget the ampersand the Rust compiler will actually make the recommendation for you to include it so that your usage matches the <code>detail()</code>  method's definition.</p>
</blockquote>
<p>To use JsValue we need to bring it into scope. At the top of your main.rs file, add </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use crate::wasm_bindgen::JsValue;
<span class="boring">}</span></code></pre></pre>
<p>Our whole BLT component looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn BltSandwich(cx: Scope) -&gt; Element {  
    let dom_node_ref = NodeRef::new(cx);  
  
    let trigger_order_sandwich_event = move |event| {  
  
        let mut event_config = web_sys::CustomEventInit::new();  
        event_config.bubbles(true);  
        let bread_type = JsValue::from(&quot;Canadian Rye&quot;);  
        event_config.detail( &amp;bread_type );  
        let event = web_sys::CustomEvent::new_with_event_init_dict(  
            &quot;orderSandwich&quot;,  
            &amp;event_config  
        );  
  
        match event {  
            Ok(event) =&gt; {  
                match dom_node_ref.get() {  
                    None =&gt; {}  
                    Some(dom_element) =&gt; {  
                        match dom_element.dispatch_event(&amp;event) {  
                            Ok(_) =&gt; { leptos::log!(&quot;Custom event sent&quot;) },  
                            Err(_) =&gt; { leptos::log!(&quot;Failed to send&quot;) }  
                        }  
                    }  
                }  
            }  
            Err(_) =&gt; {}  
        }  
    };  
    view! {  
        cx,  
        &lt;div _ref=dom_node_ref&gt;  
           &lt;h3&gt;&quot;BLT Sandwich&quot;&lt;/h3&gt;  
            &lt;button on:click=trigger_order_sandwich_event&gt;  
                &quot;Order Sandwich&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>Now let's look at the top part of our app with our mount_to_body and top level app component:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;SandwichShopApp /&gt;  
        }  
    })  
}  
  
#[component]  
fn SandwichShopApp(cx: Scope) -&gt; Element {  
    let log_order = |_| {  
        leptos::log!(&quot;Our custom event happened&quot;);  
    };  
    view! {  
        cx,  
        &lt;BltSandwich on:orderSandwich=log_order /&gt;  
    }  
}</code></pre></pre>
<p>Let's focus in on the orderSandwich event handler:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let log_order = |_| {  
	leptos::log!(&quot;Our custom event happened&quot;);  
};  
<span class="boring">}</span></code></pre></pre>
<p>Note that before we had a underscore for the event parameter of the handler. We had no need of the event in the context of our closure's body (in-between the curley braces) so we wrote an underscore to tell Rust that we're not using. This is a Rust convention.</p>
<p>Now we need the event but we don't know what type it is. We can let Rust do the work for us. Put any type in there and run <code>trunk serve</code> if you're not already.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let log_order = |event: i32| {  
	leptos::log!(&quot;Our custom event happened&quot;);  
};  
<span class="boring">}</span></code></pre></pre>
<p>The compiler will check for you and tell you about the mismatch.</p>
<pre><code>expected closure signature `fn(Event) -&gt; _`
   found closure signature `fn(i32) -&gt; _`
</code></pre>
<p>This tells us that it should be an Event type, not i32. :D The compiler is so helpful.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let log_order = |event: Event| {  
	leptos::log!(&quot;Our custom event happened&quot;);  
};  
<span class="boring">}</span></code></pre></pre>
<p>If we just write the above the compiler will also tell us that &quot;Event&quot; doesn't exist in our scope. It's telling us we need to be more specific about what we mean. Then it outlines ways that we can bring the definition of events into our scope.</p>
<pre><code>help: consider importing one of these items
   |
1  | use crate::web_sys::Event;
   |
1  | use web_sys::Event;
   |

</code></pre>
<p>Use <code>web_sys::Event</code> would force all <code>Event</code> types to be <code>web_sys::Event</code> types. Think of it like we're importing the type. We can also just manually write the type with the namespace in our closure. I prefer to include the crate or module as context for clarity. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let log_order = |event : web_sys::Event| {
<span class="boring">}</span></code></pre></pre>
<p>...feels more clear than...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let log_order = |event : Event| {
<span class="boring">}</span></code></pre></pre>
<p>Shorter code isn't always better code. Aim to be clear and to avoid ambiguity.</p>
<p>Now, unfortunately there is no <code>detail()</code> method on a <code>web_sys::Event</code>. But a <code>web_sys::Event</code> is a JsValue and we can turn it into a custom event:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let custom_event = event.unchecked_into::&lt;web_sys::CustomEvent&gt;();
<span class="boring">}</span></code></pre></pre>
<p>Here we're calling the <code>unchecked_into</code> method on the event and using the turbo fish <code>::&lt;&gt;</code> syntax to provide the destination type argument, which is a <code>web_sys::CustomEvent</code>.</p>
<p>It should be noted that this is a unique behaviour to working with things that are <code>JsValue</code> types at their core. Rust doesn't normally work this way and you can not just smash one type into another type with this ease. JavaScript is not a typed language. When we work with JsValues we're often taking the raw data from JavaScript and pushing it into a Rust context where we enforce type safety from there forward. This is how we can call <code>unchecked_into</code> to convert the regular event to the custom event, granting us access to the <code>.detail()</code> method.</p>
<p>Our app event handler now looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let log_order = |event : web_sys::Event| {  
    let custom_event = event.unchecked_into::&lt;web_sys::CustomEvent&gt;();  
    let sandwich_type = custom_event.detail();  
    leptos::log!(&quot;Our custom event happened&quot;);  
    leptos::log!(&quot;{:?}&quot;, sandwich_type );  
};
<span class="boring">}</span></code></pre></pre>
<p>You'll note that when we log the value of <code>sandwich_type</code>, the console in your browser will say <code>JsValue(&quot;Canadian Rye&quot;)</code>.  The value we pulled out of detail() is a JsValue and needs to be converted into a rust type to be used elsewhere in your system.</p>
<p>We can use a special method on <code>JsValue</code> values called <code>as_string()</code>, but it returns an Option type which we can handle with our match statements.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let log_order = |event : web_sys::Event| {  
  
	leptos::log!(&quot;Our custom event happened&quot;);  
    
    let custom_event = event.unchecked_into::&lt;web_sys::CustomEvent&gt;();  
  
    let bread_type_js = custom_event.detail();  
    let opt_bread_type_rs = bread_type_js.as_string();  
    
    match opt_bread_type_rs {  
        Some(bread_type) =&gt; { leptos::log!(&quot;{:?}&quot;, bread_type ) },  
        None =&gt; {}  
    }  
};
<span class="boring">}</span></code></pre></pre>
<p>We can reduce assignments here by chaining all of these together.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let log_order = |event : web_sys::Event| {  
    leptos::log!(&quot;Our custom event happened&quot;);  
    let bread_type = event  
        .unchecked_into::&lt;web_sys::CustomEvent&gt;()  
        .detail()  
        .as_string()  
        .unwrap_or(String::new());  
  
    leptos::log!(&quot;{:?}&quot;, bread_type );  
};
<span class="boring">}</span></code></pre></pre>
<p>The new method here is <code>unwrap_or</code>, which takes the Some value or uses a default value (provided as an argument) if none.</p>
<p>The whole thing together looks like this:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
use crate::wasm_bindgen::JsValue;  
  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;SandwichShopApp /&gt;  
        }  
    })  
}  
  
#[component]  
fn SandwichShopApp(cx: Scope) -&gt; Element {  
    let log_order = |event : web_sys::Event| {  
        leptos::log!(&quot;Our custom event happened&quot;);  
  
        let bread_type = event  
            .unchecked_into::&lt;web_sys::CustomEvent&gt;()  
            .detail()  
            .as_string()  
            .unwrap_or(String::new());  
  
        leptos::log!(&quot;{:?}&quot;, bread_type );  
    };  
    view! {  
        cx,  
        &lt;BltSandwich on:orderSandwich=log_order /&gt;  
    }  
}  
  
#[component]  
fn BltSandwich(cx: Scope) -&gt; Element {  
    let dom_node_ref = NodeRef::new(cx);  
  
    let trigger_order_sandwich_event = move |event| {  
  
        let mut event_config = web_sys::CustomEventInit::new();  
        event_config.bubbles(true);  
        let bread_type = JsValue::from(&quot;Canadian Rye&quot;);  
        event_config.detail( &amp;bread_type );  
        let event = web_sys::CustomEvent::new_with_event_init_dict(  
            &quot;orderSandwich&quot;,  
            &amp;event_config  
        );  
  
        match event {  
            Ok(event) =&gt; {  
                match dom_node_ref.get() {  
                    None =&gt; {}  
                    Some(dom_element) =&gt; {  
                        match dom_element.dispatch_event(&amp;event) {  
                            Ok(_) =&gt; { leptos::log!(&quot;Custom event sent&quot;) },  
                            Err(_) =&gt; { leptos::log!(&quot;Failed to send&quot;) }  
                        }  
                    }  
                }  
            }  
            Err(_) =&gt; {}  
        }  
    };  
    view! {  
        cx,  
        &lt;div _ref=dom_node_ref&gt;  
           &lt;h3&gt;&quot;BLT Sandwich&quot;&lt;/h3&gt;  
            &lt;button on:click=trigger_order_sandwich_event&gt;  
                &quot;Order Sandwich&quot;  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }  
}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="custom_events.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="custom_event_module.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="custom_events.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="custom_event_module.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
