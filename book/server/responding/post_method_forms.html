<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Post Method Forms - Building Apps with Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Preamble</li><li class="chapter-item expanded "><a href="../../read_me_first.html"><strong aria-hidden="true">1.</strong> Notice to Reader</a></li><li class="chapter-item expanded "><a href="../../preface.html"><strong aria-hidden="true">2.</strong> Preface</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Acknowledgements</div></li><li class="chapter-item expanded "><a href="../../about.html"><strong aria-hidden="true">4.</strong> About this Book</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> About the Author</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> If you get stuck or lose steam</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Introductions</li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Programming</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> What it is</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.2.</strong> Why it's worth it</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.3.</strong> Why it's hard</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.4.</strong> Programmer Thinking</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Languages</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> Meaning and Interpretation</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Architectures</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">9.1.</strong> What is architecture</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.2.</strong> How your computer works</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.3.</strong> How the web works</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.4.</strong> The frontend-backend divide</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.5.</strong> General application architecture</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.6.</strong> Trade-offs between WASM and JavaScript</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Tools and Languages</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">10.1.</strong> Web browsers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.2.</strong> HTML</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.3.</strong> Bash and the terminal</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.4.</strong> Rust</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.5.</strong> Trunk</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.6.</strong> Cargo Leptos</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Other Resources</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../intro/other_resources/rust.html"><strong aria-hidden="true">11.1.</strong> Rust</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Getting Started with Rust and Leptos</li><li class="chapter-item expanded "><a href="../../getting_started/setup.html"><strong aria-hidden="true">12.</strong> Setup</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> Architecture</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">13.1.</strong> Leptos Components - #[component]</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.2.</strong> Signals (reactive values) - create_signal</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.3.</strong> Effects (side effects) - create_effect</div></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Generting UI</li><li class="chapter-item expanded "><a href="../../client/summary.html"><strong aria-hidden="true">14.</strong> Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> Setup</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">15.1.</strong> Trunk</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> Introspection and Debugging</div></li><li class="chapter-item expanded "><a href="../../getting_started/html_intro.html"><strong aria-hidden="true">17.</strong> HTML</a></li><li class="chapter-item expanded "><a href="../../getting_started/view_macro_html.html"><strong aria-hidden="true">18.</strong> The view! macro</a></li><li class="chapter-item expanded "><a href="../../ui/leptos_component_intro.html"><strong aria-hidden="true">19.</strong> Leptos Components</a></li><li class="chapter-item expanded "><a href="../../ui/view_macro_variables.html"><strong aria-hidden="true">20.</strong> Variables and the view! macro</a></li><li class="chapter-item expanded "><a href="../../ui/leptos_component_properties.html"><strong aria-hidden="true">21.</strong> Component properties</a></li><li class="chapter-item expanded "><a href="../../ui/leptos_component_dynamic_content_separation.html"><strong aria-hidden="true">22.</strong> Component dynamic content separation</a></li><li class="chapter-item expanded "><a href="../../ui/loops_and_the_for_view_macro_tag.html"><strong aria-hidden="true">23.</strong> Loops and the &lt;For /&gt; view! macro tag</a></li><li class="chapter-item expanded "><a href="../../ui/conditional_display_and_the_show_macro.html"><strong aria-hidden="true">24.</strong> Conditional display and the &lt;Show&gt; view! macro tag</a></li><li class="chapter-item expanded "><a href="../../ui/tables_and_data_sets.html"><strong aria-hidden="true">25.</strong> Tables and data sets</a></li><li class="chapter-item expanded "><a href="../../ui/reserved_tags.html"><strong aria-hidden="true">26.</strong> Reserved Tags</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Client Side</li><li class="chapter-item expanded "><a href="../../client/summary.html"><strong aria-hidden="true">27.</strong> Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">28.</strong> Setup</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">28.1.</strong> Trunk</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">29.</strong> Introspection and Debugging</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">30.</strong> Responding to Events</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../client/responding/leptos_component_logging_events.html"><strong aria-hidden="true">30.1.</strong> Witnessing events</a></li><li class="chapter-item expanded "><a href="../../client/responding/leptos_component_update_from_event.html"><strong aria-hidden="true">30.2.</strong> Reacting to events with event handlers</a></li><li class="chapter-item expanded "><a href="../../client/responding/event_handlers_as_props.html"><strong aria-hidden="true">30.3.</strong> Event handers as props</a></li><li class="chapter-item expanded "><a href="../../client/responding/event_bubbling_and_signal_generics.html"><strong aria-hidden="true">30.4.</strong> Event Bubbling and Signal Generics</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">30.5.</strong> Preventing bubbling and default event behaviours </div></li><li class="chapter-item expanded "><a href="../../client/responding/custom_events.html"><strong aria-hidden="true">30.6.</strong> Custom Events</a></li><li class="chapter-item expanded "><a href="../../client/responding/custom_event_data.html"><strong aria-hidden="true">30.7.</strong> Custom Event Data</a></li><li class="chapter-item expanded "><a href="../../client/responding/custom_event_module.html"><strong aria-hidden="true">30.8.</strong> Custom Event Module</a></li><li class="chapter-item expanded "><a href="../../client/responding/custom_event_module_with_data.html"><strong aria-hidden="true">30.9.</strong> Custom Event Module with Data</a></li><li class="chapter-item expanded "><a href="../../client/responding/custom_event_data_with_signals_and_effects.html"><strong aria-hidden="true">30.10.</strong> Custom Event Data with Signals and Effects</a></li><li class="chapter-item expanded "><a href="../../client/responding/custom_event_data_with_signals_and_effects_part2.html"><strong aria-hidden="true">30.11.</strong> Custom Event Data with Signals and Effects - Part 2</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">31.</strong> Sending Data</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../client/responding/forms.html"><strong aria-hidden="true">31.1.</strong> Forms</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">31.2.</strong> Acton Forms</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">32.</strong> Sending and Receiving Data</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">32.1.</strong> Fetch</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">32.2.</strong> Web Socket</div></li></ol></li><li class="chapter-item expanded "><a href="../../client/store_data/summary.html"><strong aria-hidden="true">33.</strong> Saving/Persisting Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../client/store_data/web_storage.html"><strong aria-hidden="true">33.1.</strong> Local Storage</a></li><li class="chapter-item expanded "><a href="../../client/store_data/cookies.html"><strong aria-hidden="true">33.2.</strong> Cookies</a></li><li class="chapter-item expanded "><a href="../../client/store_data/indexeddb.html"><strong aria-hidden="true">33.3.</strong> IndexedDB</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Server Side</li><li class="chapter-item expanded "><a href="../../server/summary.html"><strong aria-hidden="true">34.</strong> Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">35.</strong> Setup</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../server/cargo_leptos/summary.html"><strong aria-hidden="true">35.1.</strong> Cargo Leptos</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../server/cargo_leptos/setup.html"><strong aria-hidden="true">35.1.1.</strong> Setup</a></li><li class="chapter-item expanded "><a href="../../server/cargo_leptos/file_structure.html"><strong aria-hidden="true">35.1.2.</strong> File Structure</a></li><li class="chapter-item expanded "><a href="../../server/cargo_leptos/config.html"><strong aria-hidden="true">35.1.3.</strong> Config</a></li><li class="chapter-item expanded "><a href="../../server/cargo_leptos/overview_main.html"><strong aria-hidden="true">35.1.4.</strong> Server Initialization and Main.rs</a></li><li class="chapter-item expanded "><a href="../../server/cargo_leptos/overview_app.html"><strong aria-hidden="true">35.1.5.</strong> Leptos app main component and app.rs</a></li><li class="chapter-item expanded "><a href="../../server/cargo_leptos/leptos_meta.html"><strong aria-hidden="true">35.1.6.</strong> Leptos_meta</a></li><li class="chapter-item expanded "><a href="../../server/cargo_leptos/leptos_router.html"><strong aria-hidden="true">35.1.7.</strong> Leptos_router</a></li></ol></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">36.</strong> Introspection and Debugging</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">37.</strong> Responding to Requests</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../server/responding/get_method_forms.html"><strong aria-hidden="true">37.1.</strong> Get Method Forms</a></li><li class="chapter-item expanded "><a href="../../server/responding/post_method_forms.html" class="active"><strong aria-hidden="true">37.2.</strong> Post Method Forms</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">37.3.</strong> Accessing Request Data</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">37.4.</strong> Responding Parts</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">37.4.1.</strong> Headers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">37.4.2.</strong> Cookies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">37.4.3.</strong> Body</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">37.5.</strong> HTML Requests - Routes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">37.6.</strong> Data Requests - Server Functions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">37.7.</strong> Behaviour Request - Server Actions</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">38.</strong> Client Server Communication</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../server/server_client_communication/server_functions.html"><strong aria-hidden="true">38.1.</strong> Server Functions</a></li><li class="chapter-item expanded "><a href="../../server/server_client_communication/transition.html"><strong aria-hidden="true">38.2.</strong> &lt;Transition&gt;</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">38.3.</strong> Form Actions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">38.4.</strong> Web Sockets</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">39.</strong> Saving/Persisting Data</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Deployment</li><li class="chapter-item expanded "><div><strong aria-hidden="true">40.</strong> Render.com</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">41.</strong> Fly.io</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">42.</strong> Cloudflare Workers</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Desktop Applications</li><li class="chapter-item expanded "><div><strong aria-hidden="true">43.</strong> Tauri</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Tutorial Projects</li><li class="chapter-item expanded "><a href="../../tutorial_projects/initiative_tracker/summary.html"><strong aria-hidden="true">44.</strong> RPG Initiative Tracker</a></li><li class="chapter-item expanded "><a href="../../tutorial_projects/chat/summary.html"><strong aria-hidden="true">45.</strong> Chat</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Quick Reference</li><li class="chapter-item expanded "><a href="../../quick_reference/rust/structuring_applictions.html"><strong aria-hidden="true">46.</strong> Structuring Applications</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Recipes</li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><div><strong aria-hidden="true">47.</strong> Common Application Behaviours</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">47.1.</strong> Form Validation</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">48.</strong> Common Design Patterns</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">48.1.</strong> Event Sourcing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">49.</strong> Common Problems and Concerns</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">49.1.</strong> Quality</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">49.1.1.</strong> UI Response Time</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">49.1.2.</strong> Bundle Size</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">49.1.3.</strong> Partial Hydration</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">49.2.</strong> Consistency</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">49.2.1.</strong> Offline Support and Data Sync</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">49.2.2.</strong> Observability and Logging</div></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Building Apps with Rust</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="post-method-forms-form-to-request-body"><a class="header" href="#post-method-forms-form-to-request-body">Post Method Forms (Form to Request Body)</a></h1>
<p>A very old pattern in web development involves setting up routes which will be the action targets for forms. Their post data would be handled on that page. In fact, you could serve pages that were the result of a <code>POST</code> request type. </p>
<p>Leptos enforces a separation where routes respond to <code>GET</code> request types (urls or using <code>method=&quot;get&quot;</code>), and <code>POST</code> request types are handled with server functions. They will provide a blank page as a response because they're not expected to respond. You can think of <code>GET</code> as a pull and <code>POST</code> as a push. We can, however, redirect after a <code>POST</code>/push to send the user to a route.</p>
<h4 id="server-action-dependencies"><a class="header" href="#server-action-dependencies">Server action dependencies</a></h4>
<p>Server actions require communication between the client and the server. This requires data to be serialized and deserialized to transport the data from one to the other. We'll need to add the serde library to our <code>cargo.toml</code> to take care of this.</p>
<pre><code class="language-toml">serde = {version = &quot;1.0.152&quot;, features = [&quot;derive&quot;] }
</code></pre>
<h4 id="server-actions-hooked-into-the-router"><a class="header" href="#server-actions-hooked-into-the-router">Server actions hooked into the router</a></h4>
<p>Leptos uses server functions to handle form actions. If we look at the main.rs of Cargo Leptos's setup file we'll see the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// main.rs

let app = Router::new()  
    .route(&quot;/api/*fn_name&quot;, post(leptos_axum::handle_server_fns))  
    .leptos_routes(leptos_options.clone(), routes, |cx| view! { cx, &lt;App/&gt; })  
    .fallback(file_and_error_handler)  
    .layer(Extension(Arc::new(leptos_options)));
<span class="boring">}</span></code></pre></pre>
<p>I'd like to draw your attention to this line:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.route(&quot;/api/*fn_name&quot;, post(leptos_axum::handle_server_fns))  
<span class="boring">}</span></code></pre></pre>
<p>Here we're setting up routes with the prefix &quot;/api&quot; followed by the function name. This is where server functions are hooked into the router to handle our <code>POST</code> requests.</p>
<h4 id="setting-up-the-routes"><a class="header" href="#setting-up-the-routes">Setting up the routes</a></h4>
<p>We start off with two routes, the one that has the form and our destination after the form as been submitted.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// app.rs

use leptos::*;  
use leptos_router::*;  
  
#[component]  
pub fn App(cx: Scope) -&gt; impl IntoView {  
    view! {  
        cx,  
        &lt;Router&gt;  
            &lt;Routes&gt;  
                &lt;Route path=&quot;&quot; view=|cx| view! { cx, &lt;FormPage/&gt; }/&gt;  
                // We will not have a handler route here, 
                // because it will be created from the action  
                // &lt;Route 
	            //    path=&quot;/form-action-handler&quot; 
	            //    view=|cx| view! { cx, &lt;FormActionHandler /&gt; }
	            //  /&gt;                
	            &lt;Route 
		            path=&quot;/form-action-processed&quot; 
		            view=|cx| view! { cx, &lt;FormActionProcessed /&gt; }
				/&gt;  
            &lt;/Routes&gt;  
        &lt;/Router&gt;  
    }}
<span class="boring">}</span></code></pre></pre>
<p>We'll need some components setup which we'll do now:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// app.rs

#[component]  
fn FormPage(cx: Scope) -&gt; impl IntoView {  
    view! { cx,  
        &lt;form action=&quot;/api/form-action-handler&quot; method=&quot;post&quot;&gt;  
            &lt;input 
	            type=&quot;text&quot; 
	            name=&quot;secret&quot; 
	            id=&quot;secret&quot; 
	            placeholder=&quot;Tell me a secret&quot; 
			/&gt;  
            &lt;input 
	            type=&quot;submit&quot; 
		        value=&quot;Send request&quot; 
			/&gt;  
        &lt;/form&gt;  
    }
}

#[component]  
fn FormActionProcessed(cx: Scope) -&gt; impl IntoView {  
    view!{cx, 
	    &quot;Server side response. This should 
	    display as a result of submitting the form.&quot;
	}  
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Note that our action is now located at <code>/api/form-action-handler</code>.</p>
</blockquote>
<h4 id="setting-up-the-server-functions"><a class="header" href="#setting-up-the-server-functions">Setting up the server functions</a></h4>
<p>We'll add our server function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// app.rs

#[server(FormActionHandler)]  
async fn form_action_handler(cx: Scope) -&gt; Result&lt;(), ServerFnError&gt; {  
    println!(&quot;Form submitted&quot;);  
    Ok(())  
}
<span class="boring">}</span></code></pre></pre>
<p>And we need to register the server function in our system before the routes are generated, so that a route can be generated for it. The <code>#[server(FormActionHandler)]</code> macro will expand and create a handle for us to register the derived server function. Keep in mind that the macro is writing a lot of boiler plate code for us. We're just adding the implementation here and declaring the intent. The handle to the macro expanded server function is <code>FormActionHandler</code>.</p>
<p>We'll add our registration call in our main.rs file. We don't need to prefix this with anything because it's in the top level of our library.rs. (it's not in a sub module). </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// main.rs

let _ = FormActionHandler::register();

<span class="boring">}</span></code></pre></pre>
<p>If we run our application with <code>cargo leptos watch</code> at this point we'll get something that doesn't quite work. Submitting a form will take you to a page with the following error:</p>
<pre><code>Could not find a server function at the route form-action-handler. 

It's likely that you need to call ServerFn::register() on the server function type, somewhere in your `main` function.
</code></pre>
<p>Leptos generates its own special name spaced URL for the action. If we add the following code in <code>main.rs</code> we can get rust to spit out the actual &quot;url&quot;.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _ = FormActionHandler::register();

// 2 new temporary lines 
println!(&quot;{:?}&quot;, FormActionHandler::url() );
return;                                 
<span class="boring">}</span></code></pre></pre>
<p>Which happens to be <code>src-app.rs-form_action_handler</code>. </p>
<p>Delete those two lines we added so that the application will run as expected and let's update our form with the new url part.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn FormPage(cx: Scope) -&gt; impl IntoView {  
    view! { cx,  
        &lt;form action=&quot;/api/src-app.rs-form_action_handler&quot; method=&quot;post&quot;&gt;  
            &lt;input type=&quot;text&quot; name=&quot;secret&quot; id=&quot;secret&quot; placeholder=&quot;Tell me a secret&quot; /&gt;  
            &lt;input type=&quot;submit&quot; value=&quot;Send request&quot; /&gt;  
        &lt;/form&gt;  
    }}
<span class="boring">}</span></code></pre></pre>
<p>If we run our application now, we'll see &quot;Form submitted&quot; in the <code>cargo leptos</code> log stream. Commenting out the following line in main.rs will silence the debug log, making your dev logging easier to read:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// simple_logger::init_with_level(log::Level::Debug).expect(&quot;couldn't initialize logging&quot;);
<span class="boring">}</span></code></pre></pre>
<h4 id="redirecting-on-submission"><a class="header" href="#redirecting-on-submission">Redirecting on submission</a></h4>
<p>So now we're capturing the action, but we'd like to go to our destination &quot;processed&quot; page. We can use the </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[server(FormActionHandler)]  
async fn form_action_handler(cx: Scope) -&gt; Result&lt;(), ServerFnError&gt; {  
    println!(&quot;Form submitted&quot;);  
    leptos_axum::redirect(cx, &quot;/form-action-processed&quot;);  
    Ok(())  
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Important note about SSR (Server Side) vs CSR (Client Side): If you write a use statement like <code>use leptos_axum::redirect;</code>, your server side binary will compile. You will receive an error compiling the client side version because <code>leptos_axum</code> is not a dependency for the client side code. When a server macro is expanded it runs in the context of the server code where <code>leptos_axum</code> <em>is</em> included. For this reason we can write <code>leptos_axum::redirect()</code> and be ok. A use statement exists in both server and client contexts. To solve this problem we can wrap the use statement in a conditional config. </p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cfg_if::cfg_if! {  
    if #[cfg(feature = &quot;ssr&quot;)] {  
       use leptos_axum::redirect;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<h4 id="capturing-post-data"><a class="header" href="#capturing-post-data">Capturing post data</a></h4>
<p>We want to capture form data from a form submission. We can do this in the server function by introspecting the request parts which are stored in the context provided to the server function.</p>
<p>We'll use <code>use_context::&lt;leptos_axum::RequestParts&gt;(cx)</code> to get the context with our type as a parameter to extract those components from the context.</p>
<p>We can match over these to start pulling data out. But the body of our parts, where our form data is stored, is in a bytes. We'll need to pass a reference to the &quot;body&quot; of our parts and convert the byes into a string slice <code>&amp;str</code>. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match use_context::&lt;leptos_axum::RequestParts&gt;(cx) {  
    Some(parts) =&gt; {  
        let body: &amp;str = std::str::from_utf8(&amp;parts.body).unwrap_or_default();  
    },  
    None =&gt; {}  
}
<span class="boring">}</span></code></pre></pre>
<p><code>body</code> at this point will look like a query string with <code>key=value&amp;key=value</code> formatting. We can naively parse this by splitting the string on ampersand  (<code>&amp;</code>) characters to get the key=value pairs. This is an extremely naive implementation and doesn't account for a variety of edge cases.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let body= std::str::from_utf8(&amp;parts.body).unwrap_or_default();  
let data: Vec&lt;Vec&lt;String&gt;&gt; = body  
    .split('&amp;')  // split the string into key=value, key=value
    .map(|kv| {  // convert the split kv strings into an array of [key, value]
        kv.split('=').collect()  
    })
	.collect();
<span class="boring">}</span></code></pre></pre>
<p>It would be a better idea to use the <a href="https://docs.rs/form_urlencoded/latest/form_urlencoded/">form_urlencoded</a> crate. The above is included for educational purposes.</p>
<p>Now we need something to store our secret in.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct SecretData(String);
<span class="boring">}</span></code></pre></pre>
<p>And we'll implement default for this as well.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Default for SecretData {  
    fn default() -&gt; Self {  
        Self(&quot;&quot;.to_string())  
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We can now kind of hack together a parser that will loop (iterate) over the key/value pairs to pluck the data out.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let form_data = SecretData::default();

for key_val_pairs in data.iter() {  
    match key_val_pairs.get(0).map(|k|k.deref()) {  
        Some(&quot;secret&quot;) =&gt; {  
            match key_val_pairs.get(1) {  
                Some(data) =&gt; {  
                    form_data = SecretData( data.to_string());  
                }  
                _ =&gt; {}  
            }  
        },        
        _ =&gt; {}  
    }
}

<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>This is a verbose version to show you the different stages of unwrapping. </p>
</blockquote>
<p>The whole thing looks pretty gnarly though:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut form_data = SecretData::default();  
  
match use_context::&lt;leptos_axum::RequestParts&gt;(cx) {  
    Some(parts) =&gt; {  
        let body= std::str::from_utf8(&amp;parts.body).unwrap_or_default();  
        let data: Vec&lt;Vec&lt;&amp;str&gt;&gt; = body  
            .split('&amp;')  
            .map(|kv| {  
                kv.split('=').collect()  
            })            .collect();  
  
        for key_val_pairs in data.iter() {  
            match key_val_pairs.get(0).map(|k|k.deref()) {  
                Some(&quot;secret&quot;) =&gt; {  
                    match key_val_pairs.get(1) {  
                        Some(data) =&gt; {  
                            form_data = SecretData( data.to_string());  
                        }  
                        _ =&gt; {}  
                    }  
                },                
                _ =&gt; {}  
            }        
		}        
		println!(&quot;{:?}&quot;, form_data );  
  
    },  
    None =&gt; {}  
}
<span class="boring">}</span></code></pre></pre>
<p>Let's wrap this all up in a nice function with some early returns to make the code less nested.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;ssr&quot;)]  
fn parse_secret_data(cx: Scope) -&gt; SecretData {  
    let parts = match use_context::&lt;leptos_axum::RequestParts&gt;(cx){  
        None =&gt; return SecretData::default(),  
        Some(parts) =&gt; parts  
    };  
  
    let body = match std::str::from_utf8(&amp;parts.body) {  
        Err(_) =&gt; return SecretData::default(),  
        Ok(data) =&gt; data  
    };  
  
    let key_val_pairs: Vec&lt;Vec&lt;&amp;str&gt;&gt; = body  
        .split('&amp;')  
        .map(|kv| kv.split('=').collect() )  
        .collect();  
  
    for kvp in key_val_pairs.iter() {  
        match ( 
	        kvp.get(0).map(|k|k.deref()), 
	        kvp.get(1).map(|k|k.deref()) 
		) {  
            ( Some(&quot;secret&quot;), Some(data)) =&gt; return SecretData( data.to_string() ),  
            _ =&gt; return SecretData::default(),  
        }    }  
    SecretData::default()  
}
<span class="boring">}</span></code></pre></pre>
<h4 id="forwarding-post-data-to-the-displayedredirected-route"><a class="header" href="#forwarding-post-data-to-the-displayedredirected-route">Forwarding post data to the displayed/redirected route</a></h4>
<p>The server isn't carrying state between the redirects. And actions are run independently of other aspects of Leptos. You can think of them as mini programs. We can, however, set a cookie that carries the data back to the client. We can also clear the data when we reach the destination page so that it's a short lived secret. </p>
<p>We'll use the following function to set our cookie:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;ssr&quot;)]  
fn set_cookie(cx: Scope, name: &amp;str, value: &amp;str ) {  
    use axum::http::header::{HeaderMap, HeaderValue, SET_COOKIE};  
    use leptos_axum::{ResponseOptions, ResponseParts};  
  
    let response = use_context::&lt;ResponseOptions&gt;(cx)
        .expect(&quot;to have leptos_axum::ResponseOptions provided&quot;);  
    let mut response_parts = ResponseParts::default();  
    let mut headers = HeaderMap::new();  
    headers.insert(  
        SET_COOKIE,  
        HeaderValue::from_str(&amp;format!(&quot;{name}={value}; Path=/&quot;))  
            .expect(&quot;to create header value&quot;),  
    );  
    response_parts.headers = headers;  
    response.overwrite(response_parts);  
}
<span class="boring">}</span></code></pre></pre>
<p>We'll call set cookie from our handler:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[server(FormActionHandler)]  
async fn form_action_handler(cx: Scope) -&gt; Result&lt;(), ServerFnError&gt; {  
    let secret_data = parse_secret_data( cx );  
    set_cookie(cx, &quot;my-secret&quot;, &amp;secret_data.0);   // &lt;--new
    leptos_axum::redirect(cx, &quot;/form-action-processed&quot;);  
    Ok(())  
}
<span class="boring">}</span></code></pre></pre>
<p>We'll use the following function read our cookie:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;ssr&quot;)]  
fn cookie(cx:Scope, name: &amp;str) -&gt; Option&lt;String&gt; {  
  
    let parts = match use_context::&lt;leptos_axum::RequestParts&gt;(cx){  
        None =&gt; return None,  
        Some(parts) =&gt; parts  
    };  
  
    let cookies_hv = match parts.headers.get(&quot;cookie&quot;) {  
        None =&gt; return None,  
        Some(cookies_hv) =&gt; cookies_hv.as_bytes()  
    };  
  
    let cookies_str = match std::str::from_utf8(cookies_hv) {  
        Ok(cookies_str) =&gt; cookies_str,  
        Err(_) =&gt; return None  
    };  
  
    let key_val_pairs: Vec&lt;Vec&lt;&amp;str&gt;&gt; = cookies_str  
        .split(&quot;; &quot;)  
        .map(|kv| kv.split(&quot;=&quot;).collect() )  
        .collect();  
  
    for kvp in key_val_pairs.iter() {  
        if kvp.get(0).map(|k|k.deref()) == Some( name ) {  
            return kvp.get(1).map(|k|k.to_string());  
        }  
    }
      
    None  
  
}
<span class="boring">}</span></code></pre></pre>
<p>When we submit the form, we trigger a server function in response. We're then forwarded to a route that displays the FormActionProcessed component. We'll update that component so that it reads our cookie's value and sets it to nothing after to clear it out.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(feature = &quot;ssr&quot;)]  
#[component]  
fn FormActionProcessed(cx: Scope) -&gt; impl IntoView {  
    let secret = cookie(cx, &quot;my-secret&quot;);  
    set_cookie(cx, &quot;my-secret&quot;, &quot;&quot;);  
    view!{cx,  
        &quot;Server side response. This should display as a \  
        result of submitting the form. Your secret is: &quot;  {secret}  
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="in-summary"><a class="header" href="#in-summary">In Summary</a></h2>
<p>The final <code>main.rs</code> looks like this. Keep in mind, this is focusing on Server Side Rendering (SSR)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// main.rs

use std::ops::Deref;  
use std::str::{FromStr, Utf8Error};  
use leptos::*;  
use leptos_router::*;  
  
#[derive(Debug, Clone)]  
struct SecretData(String);  
  
impl Default for SecretData {  
    fn default() -&gt; Self {  
        Self(&quot;&quot;.to_string())  
    }
}  

#[component]  
pub fn App(cx: Scope) -&gt; impl IntoView {  
  
    view! {  
        cx,  
        &lt;Router&gt;  
            &lt;Routes&gt;  
                &lt;Route 
	                path=&quot;&quot; 
	                view=|cx| view! { cx, &lt;FormPage/&gt; }
				/&gt;  
                &lt;Route 
	                path=&quot;/form-action-processed&quot; 
	                view=|cx| view! { cx, &lt;FormActionProcessed /&gt; }
				/&gt;  
            &lt;/Routes&gt;  
        &lt;/Router&gt;  
    }
}  

  
#[cfg(feature = &quot;ssr&quot;)]  
fn set_cookie(cx: Scope, name: &amp;str, value: &amp;str ) {  
    use axum::http::header::{HeaderMap, HeaderValue, SET_COOKIE};  
    use leptos_axum::{ResponseOptions, ResponseParts};  
  
    let response = use_context::&lt;ResponseOptions&gt;(cx)
	    .expect(&quot;to have leptos_axum::ResponseOptions provided&quot;);  
    let mut response_parts = ResponseParts::default();  
    let mut headers = HeaderMap::new();  
    headers.insert(  
        SET_COOKIE,  
        HeaderValue::from_str(&amp;format!(&quot;{name}={value}; Path=/&quot;))  
            .expect(&quot;to create header value&quot;),  
    );  
    response_parts.headers = headers;  
    response.overwrite(response_parts);  
}  
  
#[cfg(feature = &quot;ssr&quot;)]  
fn cookie(cx:Scope, name: &amp;str) -&gt; Option&lt;String&gt; {  
  
    let parts = match use_context::&lt;leptos_axum::RequestParts&gt;(cx){  
        None =&gt; return None,  
        Some(parts) =&gt; parts  
    };  
  
    let cookies_hv = match parts.headers.get(&quot;cookie&quot;) {  
        None =&gt; return None,  
        Some(cookies_hv) =&gt; cookies_hv.as_bytes()  
    };  
  
    let cookies_str = match std::str::from_utf8(cookies_hv) {  
        Ok(s) =&gt; s,  
        Err(_) =&gt; return None  
    };  
  
    let key_val_pairs: Vec&lt;Vec&lt;&amp;str&gt;&gt; = cookies_str  
        .split(&quot;; &quot;)  
        .map(|kv| kv.split(&quot;=&quot;).collect() )  
        .collect();  
  
    for kvp in key_val_pairs.iter() {  
        if kvp.get(0).map(|k|k.deref()) == Some( name ) {  
            return kvp.get(1).map(|k|k.to_string());  
        }  
    }  
    
    None  
}  
  
#[server(FormActionHandler)]  
async fn form_action_handler(cx: Scope) -&gt; Result&lt;(), ServerFnError&gt; {  
    let secret_data = parse_secret_data( cx );  
    set_cookie(cx, &quot;my-secret&quot;, &amp;secret_data.0);  
    leptos_axum::redirect(cx, &quot;/form-action-processed&quot;);  
    Ok(())  
}  
  
#[cfg(feature = &quot;ssr&quot;)]  
fn parse_secret_data(cx: Scope) -&gt; SecretData {  
    let parts = match use_context::&lt;leptos_axum::RequestParts&gt;(cx){  
        None =&gt; return SecretData::default(),  
        Some(parts) =&gt; parts  
    };  
  
    let body = match std::str::from_utf8(&amp;parts.body) {  
        Err(_) =&gt; return SecretData::default(),  
        Ok(data) =&gt; data  
    };  
  
    let key_val_pairs: Vec&lt;Vec&lt;&amp;str&gt;&gt; = body  
        .split('&amp;')  
        .map(|kv| kv.split('=').collect() )  
        .collect();  
  
    for kvp in key_val_pairs.iter() {  
        match ( kvp.get(0).map(|k|k.deref()), kvp.get(1).map(|k|k.deref()) ) {  
            (Some(&quot;secret&quot;), Some(data)) =&gt; return SecretData( data.to_string() ),  
            _ =&gt; return SecretData::default(),  
        }    
	}  
	
    SecretData::default()  
}  
  
#[component]  
fn FormPage(cx: Scope) -&gt; impl IntoView {  
    view! { cx,  
        &lt;form 
	        action=&quot;/api/src-app.rs-form_action_handler&quot; 
	        method=&quot;post&quot;
	    &gt; 				 
            &lt;input 
	            type=&quot;text&quot; 
		        name=&quot;secret&quot; 
		        id=&quot;secret&quot; 
		        placeholder=&quot;Tell me a secret&quot; 
			/&gt;  
            &lt;input 
	            type=&quot;submit&quot; 
	            value=&quot;Send request&quot; 
			/&gt;  
        &lt;/form&gt;  
    }
}  
  
#[cfg(feature = &quot;ssr&quot;)]  
#[component]  
fn FormActionProcessed(cx: Scope) -&gt; impl IntoView {  
    let secret = cookie(cx, &quot;my-secret&quot;);  
    set_cookie(cx, &quot;my-secret&quot;, &quot;&quot;);  
    view!{cx,  
        &quot;Server side response. This should display as a \  
        result of submitting the form. Your secret is: &quot;  {secret}  
    }
}  
  
#[cfg(not(feature = &quot;ssr&quot;))]  
#[component]  
fn FormActionProcessed(cx: Scope) -&gt; impl IntoView {  
    view!{cx, 
	    &quot;Client side response. This should display as a result 
	    of submitting the form on the client.&quot;
	}
}
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../server/responding/get_method_forms.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../server/server_client_communication/server_functions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../server/responding/get_method_forms.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../server/server_client_communication/server_functions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
