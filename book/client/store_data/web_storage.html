<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Local Storage - Building Apps with Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../preface.html"><strong aria-hidden="true">1.</strong> Preface</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Acknowledgements</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> About this Book</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> About the Author</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> If you get stuck or lose steam</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Introductions</li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Programming</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> What it is</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Why it's worth it</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Why it's hard</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> Programmer Thinking</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Languages</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> Meaning and Interpretation</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Architectures</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> What is architecture</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.2.</strong> How your computer works</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.3.</strong> How the web works</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.4.</strong> The frontend-backend divide</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.5.</strong> General application architecture</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Tools and Languages</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">9.1.</strong> Web browsers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.2.</strong> HTML</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.3.</strong> Bash and the terminal</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.4.</strong> Rust</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.5.</strong> Trunk</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.6.</strong> Cargo Leptos</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Other Resources</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../intro/other_resources/rust.html"><strong aria-hidden="true">10.1.</strong> Rust</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Getting Started with Rust and Leptos</li><li class="chapter-item expanded "><a href="../../getting_started/setup.html"><strong aria-hidden="true">11.</strong> Setup</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">12.</strong> Foundations</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../getting_started/html_intro.html"><strong aria-hidden="true">12.1.</strong> Intro to HTML</a></li><li class="chapter-item expanded "><a href="../../getting_started/view_macro_html.html"><strong aria-hidden="true">12.2.</strong> HTML and the view! macro</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> Architecture</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">13.1.</strong> Leptos Components - #[component]</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.2.</strong> Signals (reactive values) - create_signal</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.3.</strong> Effects (side effects) - create_effect</div></li></ol></li><li class="chapter-item expanded "><li class="part-title">Generting UI</li><li class="chapter-item expanded "><a href="../../ui/leptos_component_intro.html"><strong aria-hidden="true">14.</strong> Introduction to Leptos components</a></li><li class="chapter-item expanded "><a href="../../ui/view_macro_variables.html"><strong aria-hidden="true">15.</strong> Variables and the view! macro</a></li><li class="chapter-item expanded "><a href="../../ui/leptos_component_properties.html"><strong aria-hidden="true">16.</strong> Component properties</a></li><li class="chapter-item expanded "><a href="../../ui/leptos_component_dynamic_content_separation.html"><strong aria-hidden="true">17.</strong> Component dynamic content separation</a></li><li class="chapter-item expanded "><a href="../../ui/loops_and_the_for_view_macro_tag.html"><strong aria-hidden="true">18.</strong> Loops and the &lt;For /&gt; view! macro tag</a></li><li class="chapter-item expanded "><a href="../../ui/tables_and_data_sets.html"><strong aria-hidden="true">19.</strong> Tables and data sets</a></li><li class="chapter-item expanded affix "><li class="part-title">Client Side</li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.</strong> Responding to Events</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../client/responding/leptos_component_logging_events.html"><strong aria-hidden="true">20.1.</strong> Witnessing events</a></li><li class="chapter-item expanded "><a href="../../client/responding/leptos_component_update_from_event.html"><strong aria-hidden="true">20.2.</strong> Reacting to events with event handlers</a></li><li class="chapter-item expanded "><a href="../../client/responding/event_handlers_as_props.html"><strong aria-hidden="true">20.3.</strong> Event handers as props</a></li><li class="chapter-item expanded "><a href="../../client/responding/event_bubbling_and_signal_generics.html"><strong aria-hidden="true">20.4.</strong> Event Bubbling and Signal Generics</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">20.5.</strong> Preventing bubbling and default event behaviours </div></li><li class="chapter-item expanded "><a href="../../client/responding/custom_events.html"><strong aria-hidden="true">20.6.</strong> Custom Events</a></li><li class="chapter-item expanded "><a href="../../client/responding/custom_event_data.html"><strong aria-hidden="true">20.7.</strong> Custom Event Data</a></li><li class="chapter-item expanded "><a href="../../client/responding/custom_event_module.html"><strong aria-hidden="true">20.8.</strong> Custom Event Module</a></li><li class="chapter-item expanded "><a href="../../client/responding/custom_event_module_with_data.html"><strong aria-hidden="true">20.9.</strong> Custom Event Module with Data</a></li><li class="chapter-item expanded "><a href="../../client/responding/custom_event_data_with_signals_and_effects.html"><strong aria-hidden="true">20.10.</strong> Custom Event Data with Signals and Effects</a></li><li class="chapter-item expanded "><a href="../../client/responding/custom_event_data_with_signals_and_effects_part2.html"><strong aria-hidden="true">20.11.</strong> Custom Event Data with Signals and Effects - Part 2</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">21.</strong> Sending Data</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../client/responding/forms.html"><strong aria-hidden="true">21.1.</strong> Forms</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">21.2.</strong> Acton Forms</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.</strong> Sending and Receiving Data</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">22.1.</strong> Fetch</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">22.2.</strong> Web Socket</div></li></ol></li><li class="chapter-item expanded "><a href="../../client/store_data/summary.html"><strong aria-hidden="true">23.</strong> Saving/Persisting Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../client/store_data/web_storage.html" class="active"><strong aria-hidden="true">23.1.</strong> Local Storage</a></li><li class="chapter-item expanded "><a href="../../client/store_data/cookies.html"><strong aria-hidden="true">23.2.</strong> Cookies</a></li><li class="chapter-item expanded "><a href="../../client/store_data/indexeddb.html"><strong aria-hidden="true">23.3.</strong> IndexedDB</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Cargo Leptos</li><li class="chapter-item expanded affix "><li class="part-title">Server Side</li><li class="chapter-item expanded "><div><strong aria-hidden="true">24.</strong> Setup</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">25.</strong> Responding to Requests</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">26.</strong> Sending Data</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">26.1.</strong> Cookies</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">27.</strong> Saving/Persisting Data</div></li><li class="chapter-item expanded affix "><li class="part-title">Application Behaviours</li><li class="chapter-item expanded "><div><strong aria-hidden="true">28.</strong> Form Validation</div></li><li class="chapter-item expanded affix "><li class="part-title">Application Patterns</li><li class="chapter-item expanded "><div><strong aria-hidden="true">29.</strong> Event Sourcing</div></li><li class="chapter-item expanded affix "><li class="part-title">Common Problems</li><li class="chapter-item expanded "><div><strong aria-hidden="true">30.</strong> Offline Support and Data Sync</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">31.</strong> Observability and Logging</div></li><li class="chapter-item expanded affix "><li class="part-title">Usability Patterns and Performance Concerns</li><li class="chapter-item expanded "><div><strong aria-hidden="true">32.</strong> Bundle Size</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">33.</strong> Partial Hydration</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">34.</strong> UI Response Time</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Tutorial Projects</li><li class="chapter-item expanded "><a href="../../tutorial_projects/initiative_tracker/summary.html"><strong aria-hidden="true">35.</strong> RPG Initiative Tracker</a></li><li class="chapter-item expanded "><a href="../../tutorial_projects/chat/summary.html"><strong aria-hidden="true">36.</strong> Chat</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Building Apps with Rust</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="web-storage--local-storage"><a class="header" href="#web-storage--local-storage">Web Storage / Local Storage</a></h1>
<blockquote>
<p>For more information visit the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API">MDN Web Storage API documentation</a></p>
</blockquote>
<h2 id="what-we-know"><a class="header" href="#what-we-know">What we know</a></h2>
<ul>
<li>How to setup basic event handlers in Leptos</li>
</ul>
<h2 id="what-well-learn"><a class="header" href="#what-well-learn">What we'll learn</a></h2>
<ul>
<li>How to store and retrieve data from a domain's local storage in the client</li>
</ul>
<h2 id="whats-missing"><a class="header" href="#whats-missing">What's missing</a></h2>
<ul>
<li>Type safety guarantees for non-string types</li>
<li>Session storage and local persistant storage</li>
</ul>
<h2 id="caveats"><a class="header" href="#caveats">Caveats</a></h2>
<ul>
<li>Local storage can be modified by users and other applications running on the same domain. As with pretty much everything happening on the client, you can't trust it.</li>
</ul>
<h2 id="the-lesson"><a class="header" href="#the-lesson">The lesson</a></h2>
<p>Web storage allows us to store data in the browser that will live for the duration that the browser is open (session storage) or will persist until the browser's data is cleared (local storage). </p>
<p>How these differ from cookies:</p>
<ul>
<li>Larger amounts of data can be stored</li>
<li>The api to interact with them is easier to use. The web storage api is much newer than cookies.</li>
<li>They're not sent to the server when making new requests.</li>
</ul>
<p>In this lesson we're going to initialize a local storage value, apply some modifications to it, and read the value. Our example will be a counter.</p>
<p>Let's start with a basic client side leptos app that has a button to initialize our local storage value. Currently we just have a log message that will print a message to the browser's console when the button is clicked. This way we can confirm the handler is working.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;App /&gt;  
        }
	})
}  
  
#[component]  
fn App(cx: Scope) -&gt; Element {  
    let initialize_value = |_|{  
      leptos::log!(&quot;Initialize a value in local storage&quot;);  
    };  
    view! {  
        cx,  
        &lt;div&gt;  
            &lt;button on:click=initialize_value&gt;
	            &quot;Initialize value&quot;
			&lt;/button&gt;  
        &lt;/div&gt;  
    }
}</code></pre></pre>
<h3 id="accessing-the-web-storage-api"><a class="header" href="#accessing-the-web-storage-api">Accessing the Web Storage API</a></h3>
<p>We will need to find a way to call out to the Web Storage API through web_sys. The first step is finding out where web storage exists in JavaScript in the browser. The <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API">MDN Web Storage API documentation</a> state, &quot;These mechanisms are available via the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage"><code>Window.sessionStorage</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage"><code>Window.localStorage</code></a> properties.&quot;</p>
<p>Leptos provides us with a <code>window()</code> function which will efficiently return a <code>web_sys::Window</code>, allowing us to communicate to the browser's <code>window</code>. </p>
<p>If we look at the <code>web_sys::Window</code> <a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Window.html#method.local_storage">documentation</a>, we'll see that there is a <code>local_storage</code> method!</p>
<p>Calling <code>local_storage</code> returns a <code>Result&lt;Option&lt;web_sys::Storage&gt;, web_sys::JsValue&gt;</code>.  We'll need to get the <code>Ok(Some(storage))</code> from it (<code>Ok</code> because of the result which contains <code>Some</code> because of the option). Once we do, we'll get that <code>web_sys::Storage</code>, which we can work with. The <a href="https://rustwasm.github.io/wasm-bindgen/api/web_sys/struct.Storage.html"><code>web_sys::Storage</code> struct's documentation</a> enumerates all of the methods we can call, including <code>get()</code> and  <code>set()</code>!</p>
<h4 id="chaining-unwraps"><a class="header" href="#chaining-unwraps">Chaining Unwraps</a></h4>
<p>You can use unwarps to extract the <code>Ok</code> and <code>Some</code> like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let storage = window().local_storage().unwrap().unwrap();
<span class="boring">}</span></code></pre></pre>
<p>The problem is that <code>upwrap()</code> will throw a panic if it's the <code>Err</code> or <code>None</code> variants of <code>Result</code> and <code>Option</code> respectively. We don't want our application to panic! </p>
<h4 id="nested-matches"><a class="header" href="#nested-matches">Nested Matches</a></h4>
<p>We can use pattern matching as a potential solution:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match window().local_storage() {
	Ok( maybe_some_storage ) =&gt; match maybe_some_storage {
		Some( storage ) =&gt; {
			// Do your stuff wth storage
		},
		None =&gt; {}
	},
	Err() =&gt; {}
}
<span class="boring">}</span></code></pre></pre>
<p>This solution doesn't panic, which is great. But it does put our code in deeply nested scopes which makes it hard to read.</p>
<h4 id="assigning-the-value-of-a-match"><a class="header" href="#assigning-the-value-of-a-match">Assigning the value of a match</a></h4>
<p>What we're looking to do is assign the value to <code>storage</code> if it can be retrieved from the nested Result/Option, otherwise we'll do nothing. Do keep in mind that most applications will want to do something in the event that expected behaviour can't be followed. </p>
<p>A match statemetn will evaluate to the value of its matched expression. We can assign that value to a variable!</p>
<p>Currently that value is wrapped in an Option, which is then wrapped in a Result. We are able to use the same nesting of our return types to create a patterns to extract the value we're looking for. By combining these we can say, &quot;If local_storage() returns an <code>Ok</code> that has <code>Some</code> <code>storage</code>, let the value of the match statement be <code>storage</code>.&quot; The other pattern marked with an underscore (<code>_</code>)  indicates a catch-all. Anything that doesn't match what we want will return, breaking out of our closure!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let storage : web_sys::Storage = match window().local_storage() {  
    Ok(Some(storage)) =&gt; storage,  
    _ =&gt; return   
};
// We will only run code here if storage was able to be unwrapped by the match
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>I added the <code>web_sys::Storage</code> type to make this more clear, but Rust will infer the type. You do not need to write it.</p>
</blockquote>
<h3 id="working-with-the-web-storage-api"><a class="header" href="#working-with-the-web-storage-api">Working with the web storage API</a></h3>
<h4 id="setting-a-value"><a class="header" href="#setting-a-value">Setting a value</a></h4>
<p>We can now call the <code>Storage</code> api through our <code>storage</code> variable (note the lowercase 's'. <code>Storage</code> is the struct/type, <code>storage</code> is our value). </p>
<p>Here we are assigning (setting) the key &quot;my-counter&quot; with a value of <code>0</code>. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>storage.set(&quot;my-counter&quot;, &amp;0.to_string());
<span class="boring">}</span></code></pre></pre>
<p>It's important to note that the web storage api stores strings. We can represent numbers and complex data in string form, being as the numerical character or as serialized data respectively. Rust requires that we convert our integer <code>0</code> to a string with the <code>to_string()</code> method. This provides us with an owned string. As per the documentation set is looking for a reference to a string, a string slice (<code>&amp;str)</code>. We can meet these requirements by prefixing the whole thing with an ampersand <code>&amp;</code>.</p>
<h3 id="retrieving-a-value"><a class="header" href="#retrieving-a-value">Retrieving a value</a></h3>
<p>We can use the get method to retrieve a value from a given key.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_counter_value = storage.get(&quot;my-counter&quot;);
<span class="boring">}</span></code></pre></pre>
<p>The return type of <code>get</code> is <code>Result&lt;Option&lt;String&gt;,JsValue&gt;</code>. We can use unwrap_or_default to safely unwarp or fail. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_counter_value : String = storage  
    .get(&quot;my-counter&quot;)   // at this point we have a Result&lt;Option&lt;String&gt;,JsValue&gt;
    .unwrap_or_default() // Gives us Option&lt;string&gt; or the default value
    .unwrap_or_default(); // Gives us string or the default value, an empty string
<span class="boring">}</span></code></pre></pre>
<p>In our case, we're using a number, so we'll need to parse it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_counter_value = storage  
    .get(&quot;my-counter&quot;)  
    .unwrap_or_default()  
    .unwrap_or_default()  
    .parse::&lt;i8&gt;()  // attempt to parse the string as an 8 bit integer
    .unwrap_or_default(); 
    // ^ Return the Ok result, which is an 8 bit integer 
	//   or if there was a parse error, return the default value for an 8 bit integer
<span class="boring">}</span></code></pre></pre>
<p>We can also write this as follows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_counter_value : i8 = storage  
    .get(&quot;my-counter&quot;)  
    .unwrap_or_default()  
    .unwrap_or_default()  
    .parse()  
    .unwrap_or_default();
<span class="boring">}</span></code></pre></pre>
<p>We could rewrite this as a a match statement. Here's an example with a little twist. We're specifying what the fallback value should be in a more visible way:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_counter_value: i8 = match storage.get(&quot;my-counter&quot;) {  
    Ok(Some(value)) =&gt; value.parse().unwrap_or(0),  
    _ =&gt; 0  
};
<span class="boring">}</span></code></pre></pre>
<h3 id="making-a-module"><a class="header" href="#making-a-module">Making a module</a></h3>
<p>We can wrap these two bits of functionality into a nice little module for reuse:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>mod local_storage {  
  
    use leptos::*;  
  
    pub fn set(key : &amp;str , val : &amp;str ) {  
        let storage = match window().local_storage() {  
            Ok(Some(storage)) =&gt; storage,  
            _ =&gt; return  
        };  
        storage.set(key, val);  
    }  
  
    pub fn get(key : &amp;str ) -&gt; String {  
        let storage = match window().local_storage() {  
            Ok(Some(storage)) =&gt; storage,  
            _ =&gt; return &quot;&quot;.to_string()  
        };  
  
        match storage.get(key) {  
            Ok(Some(val)) =&gt; val,  
            _ =&gt; &quot;&quot;.to_string()  
        }
	}
	
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Again it is important to note that we are not handling any errors here. </p>
</blockquote>
<p>Calls to our local storage module are all nicely cleaned up:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// set a value
local_storage::set( &quot;my-counter&quot;, &amp;22.to_string() );  

// get a value
let v: i8 = local_storage::get(&quot;my-counter&quot;).parse().unwrap_or_default();
<span class="boring">}</span></code></pre></pre>
<p>It would be great to avoid this whole parse and unwrap business as well. Let's see if we can't clean that up even more.</p>
<p>We'll need a generic type here. I'm going to use <code>Val</code> because it'll connect with <code>val</code> (the actual value). Many people use <code>T</code>. The letter doesn't matter. We'll provide it as a type argument by adding <code>&lt;Val&gt;</code> after <code>get</code> and before the parameter lsit. Then we'll set the return type to be of type <code>Val</code> as well, with <code>-&gt; Val</code> after the parameter list. I'd like to be able to explicitly set the default value, so I'll add that as a parameter called <code>default</code> of type <code>Val</code>. The only thing left to do is add the <code>default</code> in where we had empty strings before. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get&lt;Val&gt;(key : &amp;str, default: Val ) -&gt; Val {  
    let storage: web_sys::Storage = match window().local_storage() {  
        Ok(Some(storage)) =&gt; storage,  
        _ =&gt; return default  
    };  
  
    match storage.get(key) {  
        Ok(Some(val)) =&gt; val.parse().unwrap_or( default ),  
        _ =&gt; default  
    }  
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>You might think that we'd need to provide <code>Val</code> in a turbofish for <code>val.parse::&lt;Val&gt;()</code> but we don't. Rust's compiler is smart enough (so darn smart). It knows that the final match statement doesn't end in a semicolon, so it must be the final expression. The result of the match will be our return value. This must be a <code>Val</code> type. It knows that if it's going to parse it <em>has</em> to parse to a <code>Val</code> value type!</p>
</blockquote>
<p>This isn't quite there yet though. We need to add some type bounds for Val. We can't just accept anything. We want to only acccept thing that are of type <code>Val</code> if they can actually be parsed from a string. We can do this by adding the trait bound to the generic <code>&lt;Val: std::str::FromStr&gt;</code>. This means that whatever type <code>Val</code> is, it must implement the <code>std::str::FromStr</code> trait.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get&lt;Val: std::str::FromStr&gt;(key : &amp;str, default: Val ) -&gt; Val {  
    let storage: web_sys::Storage = match window().local_storage() {  
        Ok(Some(storage)) =&gt; storage,  
        _ =&gt; return default  
    };  
  
    match storage.get(key) {  
        Ok(Some(val)) =&gt; val.parse::&lt;Val&gt;().unwrap_or( default ),  
        _ =&gt; default  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>Actually, while we're in here, let's make the local storage setter more flexible too. By adding a generic <code>Val</code> type we can call to_string() and turn it into a reference within this function. We do need to add constraints to the function. <code>Val: std::fmt::Display</code> guarantees that we can call to_string() on whatever type <code>Val</code> is.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The function definition's type constraint can also be written with a 
// where keyword after the parameter list as follows.
// pub fn set&lt;Val&gt;(key : &amp;str , val : Val ) where Val: std::fmt::Display {  
pub fn set&lt;Val: std::fmt::Display&gt;(key : &amp;str , val : Val ) {  
    let storage: web_sys::Storage = match window().local_storage() {  
        Ok(Some(storage)) =&gt; storage,  
        _ =&gt; return  
    };  
    storage.set(key, &amp;val.to_string());  
}
<span class="boring">}</span></code></pre></pre>
<p>Now, as you look at this, you should be thinking, &quot;But wouldn't I want to know if I failed to read a value? Won't this module make it look like local storage is working correctly even if it's not?!&quot; Use the knowledge you've gained in this lesson to refactor the module so that your code expresses the behaviour of your application. Think critically about where failures are important to note and handle, and where they're not.</p>
<h2 id="the-final-code"><a class="header" href="#the-final-code">The final code</a></h2>
<p>Here's the code all wrapped up and rolled together.</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;App /&gt;  
        }
	})
}  
  
  
mod local_storage {  
    use leptos::*;  
  
    pub fn set&lt;Val: std::fmt::Display&gt;(key: &amp;str, val: Val) {  
        let storage: web_sys::Storage = match window().local_storage() {  
            Ok(Some(storage)) =&gt; storage,  
            _ =&gt; return  
        };  
        storage.set(key, &amp;val.to_string());  
    }  
  
    pub fn get&lt;Val: std::str::FromStr&gt;(key: &amp;str, default: Val) -&gt; Val {  
        let storage: web_sys::Storage = match window().local_storage() {  
            Ok(Some(storage)) =&gt; storage,  
            _ =&gt; return default  
        };  
  
        match storage.get(key) {  
            Ok(Some(val)) =&gt; val.parse().unwrap_or(default),  
            _ =&gt; default  
        }  
    }}  
  
#[component]  
fn App(cx: Scope) -&gt; Element {  
    let initialize_value = |_| {  
        local_storage::set(&quot;my-counter&quot;, 0);  
        leptos::log!(&quot;Init counter to {}&quot;, local_storage::get(&quot;my-counter&quot;, 0));  
    };  
  
    let increment_value = |_| {  
        let value: i32 = local_storage::get(&quot;my-counter&quot;, 0);  
        local_storage::set(&quot;my-counter&quot;, value.saturating_add(1));  
        leptos::log!(&quot;Increment counter to {}&quot;, local_storage::get(&quot;my-counter&quot;, 0));  
    };  
  
    let decrement_value = |_| {  
        let value: i32 = local_storage::get(&quot;my-counter&quot;, 0);  
        local_storage::set(&quot;my-counter&quot;, value.saturating_sub(1));  
        leptos::log!(&quot;Decrement counter to {}&quot;, local_storage::get(&quot;my-counter&quot;, 0));  
    };  
  
    view! {  
        cx,  
        &lt;div&gt;  
            &lt;button on:click=initialize_value&gt;&quot;Initialize value&quot;&lt;/button&gt;  
            &lt;button on:click=increment_value&gt;&quot;+&quot;&lt;/button&gt;  
            &lt;button on:click=decrement_value&gt;&quot;-&quot;&lt;/button&gt;  
        &lt;/div&gt;  
    }
}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../client/store_data/summary.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../client/store_data/cookies.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../client/store_data/summary.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../client/store_data/cookies.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
