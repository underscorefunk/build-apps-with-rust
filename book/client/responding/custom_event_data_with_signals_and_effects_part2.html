<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Custom Event Data with Signals and Effects - Part 2 - Building Apps with Rust</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../highlight.css">
        <link rel="stylesheet" href="../../tomorrow-night.css">
        <link rel="stylesheet" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../read_me_first.html"><strong aria-hidden="true">1.</strong> Notice to Reader</a></li><li class="chapter-item expanded "><a href="../../preface.html"><strong aria-hidden="true">2.</strong> Preface</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.</strong> Acknowledgements</div></li><li class="chapter-item expanded "><a href="../../about.html"><strong aria-hidden="true">4.</strong> About this Book</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> About the Author</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> If you get stuck or lose steam</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Introductions</li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Programming</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> What it is</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.2.</strong> Why it's worth it</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.3.</strong> Why it's hard</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.4.</strong> Programmer Thinking</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Languages</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">8.1.</strong> Meaning and Interpretation</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Architectures</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">9.1.</strong> What is architecture</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.2.</strong> How your computer works</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.3.</strong> How the web works</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.4.</strong> The frontend-backend divide</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.5.</strong> General application architecture</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Tools and Languages</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">10.1.</strong> Web browsers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.2.</strong> HTML</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.3.</strong> Bash and the terminal</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.4.</strong> Rust</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.5.</strong> Trunk</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.6.</strong> Cargo Leptos</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">11.</strong> Other Resources</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../intro/other_resources/rust.html"><strong aria-hidden="true">11.1.</strong> Rust</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><li class="part-title">Getting Started with Rust and Leptos</li><li class="chapter-item expanded "><a href="../../getting_started/setup.html"><strong aria-hidden="true">12.</strong> Setup</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">13.</strong> Foundations</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../getting_started/html_intro.html"><strong aria-hidden="true">13.1.</strong> Intro to HTML</a></li><li class="chapter-item expanded "><a href="../../getting_started/view_macro_html.html"><strong aria-hidden="true">13.2.</strong> HTML and the view! macro</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> Architecture</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">14.1.</strong> Leptos Components - #[component]</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.2.</strong> Signals (reactive values) - create_signal</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.3.</strong> Effects (side effects) - create_effect</div></li></ol></li><li class="chapter-item expanded "><li class="part-title">Generting UI</li><li class="chapter-item expanded "><a href="../../ui/leptos_component_intro.html"><strong aria-hidden="true">15.</strong> Introduction to Leptos components</a></li><li class="chapter-item expanded "><a href="../../ui/view_macro_variables.html"><strong aria-hidden="true">16.</strong> Variables and the view! macro</a></li><li class="chapter-item expanded "><a href="../../ui/leptos_component_properties.html"><strong aria-hidden="true">17.</strong> Component properties</a></li><li class="chapter-item expanded "><a href="../../ui/leptos_component_dynamic_content_separation.html"><strong aria-hidden="true">18.</strong> Component dynamic content separation</a></li><li class="chapter-item expanded "><a href="../../ui/loops_and_the_for_view_macro_tag.html"><strong aria-hidden="true">19.</strong> Loops and the &lt;For /&gt; view! macro tag</a></li><li class="chapter-item expanded "><a href="../../ui/conditional_display_and_the_show_macro.html"><strong aria-hidden="true">20.</strong> Conditional display and the &lt;Show&gt; view! macro tag</a></li><li class="chapter-item expanded "><a href="../../ui/tables_and_data_sets.html"><strong aria-hidden="true">21.</strong> Tables and data sets</a></li><li class="chapter-item expanded "><a href="../../ui/reserved_tags.html"><strong aria-hidden="true">22.</strong> Reserved Tags</a></li><li class="chapter-item expanded affix "><li class="part-title">Client Side</li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.</strong> Responding to Events</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../client/responding/leptos_component_logging_events.html"><strong aria-hidden="true">23.1.</strong> Witnessing events</a></li><li class="chapter-item expanded "><a href="../../client/responding/leptos_component_update_from_event.html"><strong aria-hidden="true">23.2.</strong> Reacting to events with event handlers</a></li><li class="chapter-item expanded "><a href="../../client/responding/event_handlers_as_props.html"><strong aria-hidden="true">23.3.</strong> Event handers as props</a></li><li class="chapter-item expanded "><a href="../../client/responding/event_bubbling_and_signal_generics.html"><strong aria-hidden="true">23.4.</strong> Event Bubbling and Signal Generics</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">23.5.</strong> Preventing bubbling and default event behaviours </div></li><li class="chapter-item expanded "><a href="../../client/responding/custom_events.html"><strong aria-hidden="true">23.6.</strong> Custom Events</a></li><li class="chapter-item expanded "><a href="../../client/responding/custom_event_data.html"><strong aria-hidden="true">23.7.</strong> Custom Event Data</a></li><li class="chapter-item expanded "><a href="../../client/responding/custom_event_module.html"><strong aria-hidden="true">23.8.</strong> Custom Event Module</a></li><li class="chapter-item expanded "><a href="../../client/responding/custom_event_module_with_data.html"><strong aria-hidden="true">23.9.</strong> Custom Event Module with Data</a></li><li class="chapter-item expanded "><a href="../../client/responding/custom_event_data_with_signals_and_effects.html"><strong aria-hidden="true">23.10.</strong> Custom Event Data with Signals and Effects</a></li><li class="chapter-item expanded "><a href="../../client/responding/custom_event_data_with_signals_and_effects_part2.html" class="active"><strong aria-hidden="true">23.11.</strong> Custom Event Data with Signals and Effects - Part 2</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">24.</strong> Sending Data</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../client/responding/forms.html"><strong aria-hidden="true">24.1.</strong> Forms</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">24.2.</strong> Acton Forms</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">25.</strong> Sending and Receiving Data</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">25.1.</strong> Fetch</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">25.2.</strong> Web Socket</div></li></ol></li><li class="chapter-item expanded "><a href="../../client/store_data/summary.html"><strong aria-hidden="true">26.</strong> Saving/Persisting Data</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../client/store_data/web_storage.html"><strong aria-hidden="true">26.1.</strong> Local Storage</a></li><li class="chapter-item expanded "><a href="../../client/store_data/cookies.html"><strong aria-hidden="true">26.2.</strong> Cookies</a></li><li class="chapter-item expanded "><a href="../../client/store_data/indexeddb.html"><strong aria-hidden="true">26.3.</strong> IndexedDB</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Getting started with Cargo Leptos</li><li class="chapter-item expanded "><a href="../../cargo_leptos/setup.html"><strong aria-hidden="true">27.</strong> Setup</a></li><li class="chapter-item expanded "><a href="../../cargo_leptos/file_structure.html"><strong aria-hidden="true">28.</strong> File Structure</a></li><li class="chapter-item expanded "><a href="../../cargo_leptos/config.html"><strong aria-hidden="true">29.</strong> Config</a></li><li class="chapter-item expanded "><a href="../../cargo_leptos/overview_main.html"><strong aria-hidden="true">30.</strong> Server Initialization and Main.rs</a></li><li class="chapter-item expanded "><a href="../../cargo_leptos/overview_app.html"><strong aria-hidden="true">31.</strong> Leptos app main component and app.rs</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">32.</strong> Extern</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../cargo_leptos/leptos_meta.html"><strong aria-hidden="true">32.1.</strong> Leptos_meta</a></li><li class="chapter-item expanded "><a href="../../cargo_leptos/leptos_router.html"><strong aria-hidden="true">32.2.</strong> Leptos_router</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Server Side</li><li class="chapter-item expanded "><a href="../../server/responding.html"><strong aria-hidden="true">33.</strong> Responding to Requests</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">33.1.</strong> Headers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">33.2.</strong> Cookies</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">33.3.</strong> Body</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">34.</strong> Responding to Requests</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../server/responding/accessing_request_data.html"><strong aria-hidden="true">34.1.</strong> Accessing Request Data</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">34.2.</strong> Server Functions</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">34.2.1.</strong> HTML</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">34.2.2.</strong> Data / API Endpoints</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">34.3.</strong> Server Actions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">34.4.</strong> Form Actions</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">35.</strong> Sending Data</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">35.1.</strong> Cookies</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">36.</strong> Sending and Receiving Data</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">36.1.</strong> Web Sockets</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">37.</strong> Saving/Persisting Data</div></li><li class="chapter-item expanded affix "><li class="part-title">Deployment</li><li class="chapter-item expanded "><div><strong aria-hidden="true">38.</strong> Render.com</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">39.</strong> Fly.io</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">40.</strong> Cloudflare Workers</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Desktop Applications</li><li class="chapter-item expanded "><div><strong aria-hidden="true">41.</strong> Tauri</div></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Tutorial Projects</li><li class="chapter-item expanded "><a href="../../tutorial_projects/initiative_tracker/summary.html"><strong aria-hidden="true">42.</strong> RPG Initiative Tracker</a></li><li class="chapter-item expanded "><a href="../../tutorial_projects/chat/summary.html"><strong aria-hidden="true">43.</strong> Chat</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Quick Reference</li><li class="chapter-item expanded "><a href="../../quick_reference/rust/structuring_applictions.html"><strong aria-hidden="true">44.</strong> Structuring Applications</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Recipes</li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Appendix</li><li class="chapter-item expanded "><div><strong aria-hidden="true">45.</strong> Common Application Behaviours</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">45.1.</strong> Form Validation</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">46.</strong> Common Design Patterns</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">46.1.</strong> Event Sourcing</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">47.</strong> Common Problems and Concerns</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">47.1.</strong> Quality</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">47.1.1.</strong> UI Response Time</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">47.1.2.</strong> Bundle Size</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">47.1.3.</strong> Partial Hydration</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">47.2.</strong> Consistency</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">47.2.1.</strong> Offline Support and Data Sync</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">47.2.2.</strong> Observability and Logging</div></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Building Apps with Rust</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="custom-event-data-with-signals-and-effects---part-2"><a class="header" href="#custom-event-data-with-signals-and-effects---part-2">Custom Event Data with Signals and Effects - Part 2</a></h1>
<h2 id="what-we-know"><a class="header" href="#what-we-know">What we know</a></h2>
<ul>
<li>We can use signals as message busses and effects as message bus watchers to react to changes in our application</li>
</ul>
<h2 id="what-well-learn"><a class="header" href="#what-well-learn">What we'll learn</a></h2>
<ul>
<li>How to create a state struct to hold application state and accept events to update the data in an application.</li>
</ul>
<h2 id="the-lesson"><a class="header" href="#the-lesson">The lesson</a></h2>
<p>In our previous lesson, our code looked like this:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
#[derive(Clone, Debug)]  
enum Sandwich{  
    BLT,  
    Rubin,  
    PBandJ  
}  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;SandwichShop /&gt;  
        }    })}  
  
#[component]  
fn SandwichShop(cx: Scope) -&gt; Element {  
  
    let (  
        last_order,  
        new_order  
    ) = create_signal(cx, None::&lt;Sandwich&gt;);  
  
    create_effect(cx, move |_| {  
        match last_order.get() {  
            Some(sandwich) =&gt; {  
                leptos::log!(&quot;A sandwich was ordered: {:?}&quot;, sandwich);  
            },  
            None =&gt; {}  
        }    });  
  
    view! {  
        cx,  
        &lt;div&gt;  
            &lt;Sandwich new_order sandwich=Sandwich::BLT label=&quot;Bacon, Lettuce. Tomato&quot;/&gt;  
            &lt;Sandwich new_order sandwich=Sandwich::Rubin label=&quot;Rubin&quot;/&gt;  
            &lt;Sandwich new_order sandwich=Sandwich::PBandJ label=&quot;Peanutbutter and Jelly&quot;/&gt;  
        &lt;/div&gt;  
    }}  
  
#[component]  
fn Sandwich(
	cx: Scope, 
	new_order: WriteSignal&lt;Option&lt;Sandwich&gt;&gt;, 
	sandwich: Sandwich, label: &amp;'static str 
) -&gt; Element{  

	let place_order = move |_|{  
        leptos::log!(&quot;Place order&quot;);  
        new_order.set( Some(sandwich.clone()) );  
    };  

	view! {  
        cx,  
        &lt;div&gt;  
           &lt;button on:click=place_order&gt;  
                &quot;Order &quot; {label}  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }
}</code></pre></pre>
<p>There are some problems  with this approach. The application component has a lot of functionality rolled into it. It would be preferrable if we could split this stuff out so that it's a bit easier to see the application logic from it's user iterface. </p>
<p>First things first, let's split our application state out from the application Leptos component. The state of our application is a snapshot of the application's data.</p>
<p>We'll also make a piece of data in the state to hold the last_event. We'll also go so far as to make an enum that stores the possible events as well.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>// Things that can happen in a sandwich shop
#[derive(Debug, Clone, Copy)]
enum Event {
	OrderSandwich(Sandwich),
	None
}

#[derive(Debug, Clone, Copy)] 
struct State { 
	last_event: Event
}
<span class="boring">}</span></code></pre></pre>
<p>We'll need an easy way to setup a default state. We can implement the default trait for the <code>State</code> struct. Recall that traits are a specification of behaviours/capabilities of a type. Traits are also types. We can use traits as bounds for argument types by writing their names as the required types for parameters.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example_trait_requirement( my_parameter: SomeTrait) { 
	//...
}
<span class="boring">}</span></code></pre></pre>
<p>Implementing the default trait on a type requires the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Default for State {  
    fn default() -&gt; Self {  
        Self {  
            last_event: Event::None  
        }  
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We now have the ability to call <code>State::default()</code> and we'll receive a <code>State</code> struct value with <code>last_event</code> set to the <code>Event</code> enum variant of <code>None</code>. This is a bit more streamlined than dealing with the option type in our previous example.</p>
<p>We also want to be able to update our state. We are going to force the updating of state through a <code>State</code> <code>update</code> method, requiring an event. This pattern of adding constraint like, &quot;You MUST have THIS to do THAT&quot; is how we make stable applications. You'll see this enforced all over the place in Rust.</p>
<p>To add functions associated with the <code>State</code> struct, we can write <code>impl</code> (for implement) <code>State</code> (the name of the struct), and define a scope with curley braces to contain the implementations of our methods. We are not writing the implementation of a Trait, so we don't need to write <code>impl TraitName for StructName</code>, like we did with the <code>Default</code> trait. It's the same idea though.</p>
<p>Our update method will take a mutable reference to itself so that it can update its own data, and it takes an event which dictates how it's own data will be updated. We then match on the events and handle the updates accordingly. At the end, we'll update the last_event with the event used for the update so that we know what happened.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl State {  
    fn update(&amp;mut self, event: Event) {  
        match event {  
            Event::OrderSandwich(sandwich) =&gt; {  
                leptos::log!(&quot;A sandwich was ordered: {:?}&quot;, sandwich);  
            },  
            Event::None =&gt; {}  
        }        
        self.last_event = event;  
    }  
}
<span class="boring">}</span></code></pre></pre>
<p>As cool as all of this is, we're no further ahead. As developers we have to be careful of things that look like cool patterns but don't add any extra functionality. It's easy to get caught up in what feels satisfying to write because it's clever. Often things that are mentally taxing to write or figure out are the most stimulating. Try to avoid this siren song. Err on the side of simplicity.</p>
<p>We're now going to hook this into our reactive system so that it makes a meaningful change and we'll review the complexity to see if we've simplified our system or made it more complex.</p>
<p>Let's dig in...</p>
<p>We know when we start our app up, we're going to need to initialize a state. We want the state to handle its own updates though and we do not want the state to be rewritten. For this reason, we'll crate a signal to store a reactive value of type <code>State</code>, but we're only going to grab the read signal. </p>
<p>We need a context/scope to create the signal, and our default values.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn SandwichShop(cx: Scope) -&gt; Element {  
    let (state, _) = create_signal(cx, State::default() );
<span class="boring">}</span></code></pre></pre>
<p>This feels overly complicated. There's a lot happening here when I really want to just write, &quot;Give me a <code>State</code> struct.&quot; </p>
<p>Let's change this to something like...</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let state = State::new(cx);
<span class="boring">}</span></code></pre></pre>
<p>Notice how we're distilling down a previously complicated statement into one that expresses exactly what we want. </p>
<p>Now we need to refactor our state struct to represent this. The first step is, let's just delete the whole <code>impl Default for State</code> block. We're not allowing people to create a default state anymore.</p>
<p>We do need to update our <code>State</code> implementations to include the addition of a <code>new</code> method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl State {  
  
    pub fn new(cx: Scope) -&gt; ReadSignal&lt;State&gt; {  
        let init_state = Self {  
            cx,  
            last_event: Event::Init  
        };  
        let (state, _) = create_signal( cx, init_state );  
        state  
    }
	// ...
}
<span class="boring">}</span></code></pre></pre>
<p>You can see where we took some of the complexity of things that happened in our application and pushed it into this method. It makes our SandwichShop Leptos component 
much more simple and clear.</p>
<p>We also need to update our struct's properties so that we can store a <code>Scope</code> within the state as well.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy)]  
struct State {  
    cx: Scope,  
    last_event: Event  
}
<span class="boring">}</span></code></pre></pre>
<p>Let's turn our eyes to this <code>last_event</code> property. It also needs to be made into a signal so that we can update it and respond reactively. We'll update the struct literal syntax with a create signal call for <code>last_event</code>'s value.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new(cx: Scope) -&gt; ReadSignal&lt;State&gt; {  
    let init_state = Self {  
        cx,  
        last_event: create_signal( cx, Event::Init)  
    };  
    let (state, _) = create_signal( cx, init_state );  
    state  
}
<span class="boring">}</span></code></pre></pre>
<p>We also need to update our struct to match this new value type.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug, Clone, Copy)]  
struct State {  
    cx: Scope,  
    last_event: last_event: (ReadSignal&lt;Event&gt;, WriteSignal&lt;Event&gt;)
}
<span class="boring">}</span></code></pre></pre>
<p>The last piece of this refactor is in the State <code>update</code> method. We were storing the event we were responding as the value of <code>last_event</code>. The type of this property on the <code>State</code> struct has changed. It's not an <code>Event</code> anymore. </p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn update(&amp;mut self, event: Event) {  
        match event {  
            Event::OrderSandwich(sandwich) =&gt; leptos::log!(&quot;A sandwich was ordered: {:?}&quot;, sandwich),  
            _ =&gt; {}  
        }        
        self.last_event = event;  
    }  
<span class="boring">}</span></code></pre></pre>
<p>We need to change:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.last_event = event;  
<span class="boring">}</span></code></pre></pre>
<p>To the following:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>self.last_event.1.set( event );
<span class="boring">}</span></code></pre></pre>
<p><code>last_event</code> is a tuple with two values as index 0 and 1. Index 1 contains the write signal, which has a set method. We're using that value's set method to update the reactive value of the signal.</p>
<p>This feels unclear to me so i'll rewrite it as:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	self.update_last_event( event );
<span class="boring">}</span></code></pre></pre>
<p>And create a private method on self that hides the read/write implementation feature.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_last_event( &amp;mut self, event: Event ) {  
    self.last_event.1.set(event );  
}
<span class="boring">}</span></code></pre></pre>
<p>You may notice that the previous methods had the <code>pub</code> keyword before the <code>fn</code> keyword. Excusion of the <code>pub</code> keyword for <code>update_last_event</code> prevents the method from being called by external callers. Only methods on the <code>State</code> struct can call <code>update_last_event</code>.</p>
<h3 id="updating-the-effect"><a class="header" href="#updating-the-effect">Updating the effect</a></h3>
<p>Our previous example had an effect that would respond to changes to our application's last order.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>create_effect(cx, move |_| {  
    match last_order.get() {  
        Some(sandwich) =&gt; leptos::log!(
	        &quot;A sandwich was ordered: {:?}&quot;, 
	        sandwich
			),  
        None =&gt; {}  
    }
});
<span class="boring">}</span></code></pre></pre>
<p>We actually don't need to use this anymore because we've got a state value that we can directly update and react to, all in one contained struct.</p>
<h3 id="updating-the-sandwich-components"><a class="header" href="#updating-the-sandwich-components">Updating the sandwich components</a></h3>
<p>We no longer need to pass more complicated handlers on down. We can just pass <code>state</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn SandwichShop(cx: Scope) -&gt; Element {  
    let state = State::new(cx);  
    view! {  
        cx,  
        &lt;div&gt;  
            &lt;Sandwich state sandwich=Sandwich::BLT label=&quot;Bacon, Lettuce. Tomato&quot;/&gt;  
            &lt;Sandwich state sandwich=Sandwich::Rubin label=&quot;Rubin&quot;/&gt;  
            &lt;Sandwich state sandwich=Sandwich::PBandJ label=&quot;Peanutbutter and Jelly&quot;/&gt;  
        &lt;/div&gt;  
    }}
<span class="boring">}</span></code></pre></pre>
<p>Recall that our <code>State::new()</code> gives us a read signal so that we can easily pass it around our system. We need to update our Sandwich components to match with a new property type for <code>state</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	state: ReadSignal&lt;State&gt;
<span class="boring">}</span></code></pre></pre>
<p>And we'll update the place_order closure so that it calles an update method on the actual state object.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[component]  
fn Sandwich(
	cx: Scope, 
	state: ReadSignal&lt;State&gt;, // &lt;- here
	sandwich: Sandwich, 
	label: &amp;'static str 
) -&gt; Element{

	let place_order = move |_|{  
	    state.get().update(Event::OrderSandwich(sandwich))  
	};
	//...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="what-remains"><a class="header" href="#what-remains">What remains</a></h3>
<p>When I had set out to do this refactor I was thinking that we'd need the <code>last_event</code> as a signal to respond to, so that we could build reactvity off of it with <code>create_effect()</code>. The reality is that in this example, we don't even actually need that. :)</p>
<p>My hope is that this lesson gives you some insight into the thought process of refactoring and adding constraint to changes.</p>
<p>Here's what the finished code looks like:</p>
<pre><pre class="playground"><code class="language-rust">use leptos::*;  
  
#[derive(Debug, Clone, Copy)]  
enum Sandwich{  
    BLT,  
    Rubin,  
    PBandJ  
}  
  
#[derive(Debug, Clone, Copy)]  
enum Event {  
    OrderSandwich(Sandwich),  
    Init  
}  
  
#[derive(Debug, Clone, Copy)]  
struct State {  
    cx: Scope,  
    last_event: (ReadSignal&lt;Event&gt;, WriteSignal&lt;Event&gt;)  
}  
  
impl State {  
  
    pub fn new(cx: Scope) -&gt; ReadSignal&lt;State&gt; {  
        let init_state = Self {  
            cx,  
            last_event: create_signal( cx, Event::Init)  
        };  
        let (state, _) = create_signal( cx, init_state );  
        state  
    }  
  
    pub fn update(&amp;mut self, event: Event) {  
        match event {  
            Event::OrderSandwich(sandwich) =&gt; leptos::log!(&quot;Yay! A sandwich was ordered: {:?}&quot;, sandwich),  
            _ =&gt; {}  
        }        
        self.update_last_event(event );  
    }  
  
    fn update_last_event( &amp;mut self, event: Event ) {  
        self.last_event.1.set(event );  
    }  
  
}  
  
fn main() {  
    mount_to_body(|cx| {  
        view! {  
            cx,  
            &lt;SandwichShop /&gt;  
        }
	})
}  
  
#[component]  
fn SandwichShop(cx: Scope) -&gt; Element {  
    let state = State::new(cx);  
    view! {  
        cx,  
        &lt;div&gt;  
            &lt;Sandwich state sandwich=Sandwich::BLT label=&quot;Bacon, Lettuce. Tomato&quot;/&gt;  
            &lt;Sandwich state sandwich=Sandwich::Rubin label=&quot;Rubin&quot;/&gt;  
            &lt;Sandwich state sandwich=Sandwich::PBandJ label=&quot;Peanutbutter and Jelly&quot;/&gt;  
        &lt;/div&gt;  
    }}  
  
#[component]  
fn Sandwich(
	cx: Scope, 
	state: ReadSignal&lt;State&gt;, 
	sandwich: Sandwich, 
	label: &amp;'static str 
) -&gt; Element{  

	let place_order = move |_|{  
        state.get().update(Event::OrderSandwich(sandwich))  
    };  
    
    view! {  
        cx,  
        &lt;div&gt;  
           &lt;button on:click=place_order&gt;  
                &quot;Order &quot; {label}  
            &lt;/button&gt;  
        &lt;/div&gt;  
    }
    
}</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../client/responding/custom_event_data_with_signals_and_effects.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../client/responding/forms.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../client/responding/custom_event_data_with_signals_and_effects.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../client/responding/forms.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
